These subcommands manage databases that map functions to the testcases that
invoke them.  To create the mapping, a function must invoke Debug::ft and
be captured in a *.funcs.txt function trace (using >save funcs in the >nt
CLI increment).  A code coverage database can then be created as follows:

1. copy all testcase function trace summaries (*.funcs.txt) to OutputPath/
2. >read buildlib         // set up compile environment
3. >parse - win32 $files  // compile the code base (here, for Win32)
4. >check rsc $files      // inserts functions that invoke Debug::ft
5. >coverage build        // inserts testcases (OutputPath/*.funcs.txt)
6. >coverage dump db1     // saves the database in db1.cover.txt

The database can be load later with >coverage load db1, which makes it the
"previous" database.  A "current" database, which captures changes that you
have made to the code base since the previous database was saved, is created
using steps 2 to 5.  This current database can be a subset where OutputPath/
only contains the *.funcs.txt files generated while testing your changes.
Creating this database allows used of >coverage diff to list the functions
and testcases that you have added, changed, or deleted.  If you then enter
>coverage dump db2, a new database is generated by merging the more recent
information in the current database (which is only in memory at this point)
with the previous database (db1).

If the goal is to have at least N testcases that invoke each function, a list
of all the functions that are invoked by fewer testcases can be produced with
>coverage under N.