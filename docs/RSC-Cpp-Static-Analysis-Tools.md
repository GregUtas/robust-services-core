# Robust Services Core: C++ Static Analysis Tools

The C++ static analysis tools are accessed through the `ct` increment,
which is entered with the CLI command `>ct`.  The commands available
in that increment are described [here](/output/help.cli.txt),
starting after the line `ct>help full`.

The contents of the code library must be defined before any of the tools
can be used. This can be done with `>read buildlib`, which imports the
entire code base using the [`buildlib`](/input/buildlib.txt) script (which,
in turn, uses the [`lib.create`](/input/lib.create.txt) script).

As the library is built, `#include` relationships are noted.  This allows
`#include` dependencies to be analyzed by the operators `us`, `ub`, `as`,
`ab`, `ca`, `ns`, and `nb`, which are described in the full help documentation.

Some commands cannot be used without first parsing the code.  The command
`>parse - win64 $files` parses all of the files in the library (for 64-bit
Windows).  If a file has not been parsed, parsing occurs when a command that
requires it is used.  These commands include

* `>check`, to look for violations of C++ design guidelines
* `>fix`, which modifies source code files to eliminate some of the warnings
found by `>check`
* `>export`, to write out the code in a standard format
* `>trim`, to determine which `#include` and `using` directives, and forward
declarations, should be added or removed
* the `im` operator, which finds the .cpp's that implement a set of .h's

The [`output`](/output) directory contains the files generated by the
[`>check`](/output/rsc.check.txt), [`>export`](/output/rsc.lib.txt),
and [`>trim`](/output/rsc.trim.txt) commands for the current version of
the entire code base.

The parser currently supports everything used within RSC.  Because this is
not everything in C++11, there are limitations, some of which are noted in the
comments at the beginning of [`Parser.h`](/ct/Parser.h).  The goal is to support
whatever the code base uses, although some things would be deemed undesirable
or marginal and would therefore not be introduced.

The `>check` and `>trim` commands occasionally generate false positives.  A few
examples are

  * If the member `a.b.c` is modified, `a` can be flagged as "could be const",
because a write is only noted on what immediately precedes a reference-select
(`.`) operator.
  * A variable that is only modified in the second clause following a `?`
operator is flagged as "could be const" by `>check`, because writes are only
tracked in the first clause.
  * Because external headers in the [`subs`](/subs) directory do not contain
source code, `>trim` can suggest removing an `#include` that is actually needed
to make a destructor visible to a `unique_ptr` template instance.
