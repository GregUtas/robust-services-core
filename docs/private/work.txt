+==============================================================================+
| o = open  v = implemented  x = rejected  i = informational  ? = tbd  * = bug |
+==============================================================================+

CODE TOOLS
o look at using GetValue() to evaluate expressions (e.g. for constexpr)
o all GetValue() functions return a Literal
o create CxxToken from underlying value of #defined symbol, and use in StackArg
o IntLiteral can push num_ onto stack
o have Display show GetValue() constant in a /* */ comment

o test #if with !defined and other operators once expressions can be evaluated
o split Macro.refs_, based on whether defined when referenced?
o instead of erasing a #defined symbol that maps to an empty string, replace
  it with something like @1, @2 so that Display can regenerate it

o support ..." <blanks> "... as continuation of string literal
o retain access control keywords as tokens for regenerating code
o left-align directives in Display functions: problem is knowing where left
  margin is, as it varies (e.g. nested namespaces): may have to change Display
  to specify the position of the left margin
--------------------------------------------------------------------------------
PREPROCESSOR
i search on "C++ preprocessor" for documentation
v use cases for #define:
  v include guards (e.g. #ifndef HEADER_H_INCLUDED; #define HEADER_H_INCLUDED)
  v tags (e.g. #define noexcept, #define override for C++11 compatibility)
  v targeting (e.g. #define WORDSIZE_32, #define FIELD_LOAD)
  v numeric constants (e.g. #define SIGBUS 11)
? apply #undef to the affected-by set; need to support multiple definitions of
  the same symbol if it is redefined after #undef
o unsupported:
  --space between '#' and keyword, or no keyword at all ('#' as comment)
  --#include over more than one line
v #if and #elif use operators defined, !defined, defined(), !defined(),
  == != <= >= < > && || etc
o #define (x = unsupported)
  v single identifier
  v integral constants: identifier <integer>
  ? float constants: identifier <float>
  ? character literals: identifier 'char'
  ? string literals: identifier ("text" | L"text")
  x code alias: identifier <code>
  x function macros: identifier(<arguments>) <code>
  x # operator (stringification) on rhs
  x ## operator (concatenation) on rhs
i VS C++ header files:
  C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\include\
  C:\Program Files (x86)\Windows Kits\8.1\Include\shared\
  C:\Program Files (x86)\Windows Kits\8.1\Include\um
  C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\
................................................................................
TRIM BUGS & ENHANCEMENTS
o recommendations for .cpp should take .h into account: a common example is
  adding/removing an #include from a .h, which the .cpp must then remove/add
o support adding/removing forward declaration in >apply
o support removing using declaration in >apply
o >apply should not remove or relocate a commented #include, using, or forward
  --when >apply encounters a non-#include (e.g. a comment line) in an #include
    sequence, it ignores any other #includes that follow the comment
  --if an #include is commented, >apply won't remove it, because string matching
    fails (the comment being "extra")
o CodeTypes.h: -vector
  --occurs because std::vector only appears as the type of a function template's
    argument, and function templates are not compiled
o CxxStatement.cpp: -CxxScope.h
  --CxxStatement.h declares classes with BlockPtr members
  --definition of Block (in CxxScope.h) must therefore be visible in order to
    instantiate deleter for BlockPtr (unique_ptr<Block>)
  --CxxStatement.h should #include CxxScope.h so that its users don't need to
o CodeFile.h: -CxxNamed.h, -CxxScoped.h
  --needed to make CodeFile members IncludePtr and UsingPtr visible to unique_ptr
  --IncludePtr is not instantiated until a .cpp #includes CodeFile.h, at which
    time incls_.push_back probably has a clause (e.g. failure to expand vector)
    in which it deletes IncludePtr
  --Include's definition must then be visible so that unique_ptr can delete it
  --same occurs for UsingPtr and UsingDecl
  --template may need to see a function (e.g. unique_ptr seeing a destructor)
  --possible ways to detect this:
    (a) tag template as "nontransparent"
    (b) have template define a function named "nontransparent"
    (c) check (during parsing) if template uses any members of its parameters,
        although this is a problem if no code is provided, which is the case
        for templates in extern.h
    (d) "instantiate" auxiliary code for destructors, to invoke destructors
        of embedded classes
o TlvMessage.h: -Debug.h
  --occurs because template functions are not executed
  --possible solutions are: (a) execute templates to track usage, which will
    require enhancements to avoid logging errors caused by template parameters
    not having referents; (b) when template is instantiated, add usages to the
    file that provided its source code, except for those associated with
    template arguments
o CodeTypes.h: -SysTypes.h
  --"using namespace NodeBase" then caused a compile error because NodeBase was
    no longer defined
  --after determining which files to #include, check using directives to verify
    that some file being transitively included actually defines an item in that
    namespace
o CxxString.h had a compile error because "using namespace NodeBase" was absent;
  had been picking it up from CodeTypes.h, which had been told to delete it
  --for each symbol resolved by a using statement, check that the file contains
    a using statement that resolves that symbol
................................................................................
TRIM: NOTES & COMPLETED CHANGES
v ThreadRegistry.h: +SysMutex.h, -Thread forward declaration: SysMutex is
  transitively #included; is it dubious to #include it only for its forward
  declaration of Thread* [no; could be decoupled later]
v various: +TraceRecord.h
  --suggested because of TraceRecord::Id, which subclasses use as "Id": this
    is inherited, directly or indirectly, so an #include is unnecessary
v IpBuffer.cpp: -SysTcpSocket.h
  --caused a compiler error because result of GetSocket (SysTcpSocket*) was
    assigned to a SysSocket*, which means that SysTcpSocket must be #included
	to ascertain that it is a subclass of SysSocket [since fixed by invoking
	CompatibilityWith for lhs and rhs of assignments]
x when suggesting the addition of a forward declaration, look for an existing
  (courtesy) forward declaration if the symbol is not in the same namespace as
  its user [no: the courtesy declaration will be found if it is transitively
  #included; if it isn't, then it isn't clear that it should be #included]
x in >trim report, include friend declarations that have no users; if friend
  is external, such as deleter_type, indicate that it may actually be needed
  [no: already included in >check report]
x when showing which items need qualification to remove using statements,
  separate full template instance names into their components [no: cosmetic]
x when showing which items need qualification to remove using statements,
  display aliases (e.g. suggests qualifying SwitchStub::PortId when code
  reads Switch::PortId)
  --generating Switch::PortId is difficult because no item has this as its
    scoped name
  --QualName.class_ = Switch, so perhaps it could override of ScopedName to
    generate the alias
  --this would involve merging the alias with the true scoped name
  --[no: showing the true name may actually be useful]
x flag using statement that .cpp repeats from .h (a base usage file)
  --dubious because it discourages .h from removing using statements? (counter
    argument is that it is no more dubious than logging an #include that .cpp
    repeats from .h, because this discourages .h from trimming its #includes)
  --guideline: OK to rely on a using statement in your own .h but not another
  --[no: difficult to implement because it requires knowing base class files,
    which only >trim calculates]
x some base class constructors are not shown as direct usages; only the base
  class is a direct usage [no: this is arguably correct, shouldn't have a
  negative effect, and trying to "fix" it causes problems because auto v = C()
  fails to find a referent for C when looking for a function, as it expects to
  find C::C, not C]
x a derived class can use a base class item without namespace qualification,
  the only exception being when it initially names its base class
x do not show members as direct usages: only the class itself needs to be
  shown [no: members still shown because this is useful as a reference]
v to document reliance on a forward declaration, >trim suggests #including
  the file that defines it, even if that file is transitively included,
  unless the file contains a base class (even a transitive base class)
v do not need to #include item defined in
  --indirect base class
  --base class of #included class [dubious? no: must compile affected-by]
v investigate if name of friend in another namespace can be qualified (yes,
  but must be forward declared first: can only inject a name into the current
  namespace)
x have >check log unused forward and using declarations [no: those that don't
  resolve symbols should nonetheless be kept if the file might require them;
  this is better than relying on #include dependencies that can change, and
  >trim does a better job of analyzing #includes, usings, and forwards]
v do not suggest adding a forward declaration if
  v the item is defined in a file that will be #included, even transitively
    [in fact, removing an #include that will be picked up transitively is
	probably only suggested for items in transitive base classes]
  v the forward declaration already exists in this file: this can occur when
    the forward declaration resolves a function *declaration's* argument that
	is subsequently replaced by the argument parsed in the function's
	*definition*: in the definition file, the item may be directly visible,
	and so the forward declaration is not inserted in symbols[ForwardUsage],
	and its existence is unknown
  v a file containing the forward declaration will be #included
  x a file that is used transitively, and can therefore be recommended to be
    #included [this is dubious because there may not be a true dependency on
    that file, in which case it should not be included simply to access its
    forward declaration]
v ignore a template instance for usage purposes if added to the same scope as
  its template, because its template argument(s) only need to be visible at
  the point where the instance is used
v decide how to handle forward declarations:
  --relying on Singleton.h as a transitive #include is dubious because there
    is no hard dependency (other than to replace the forward declaration)
  --including NbTypes.h, which is *already* included transitively, allows the
    forward declaration to be removed, and NbTypes.h may even be providing its
    forward as a courtesy
                       Singleton forward  include NbTypes.h  Affecters
  CfgParmRegistry      add                remove             NbTypes, Singleton
  CinThread            add                remove             NbTypes, Singleton
  NbModule             remove             add                NbTypes
  ObjectPoolRegistry   remove             included           NbTypes
  PosixSignalRegistry  remove             add                NbTypes
  SysSignals           remove             add                NbTypes
v when using a typedef of a template instance, do not suggest replacing it with
  a forward declaration
v need to forward declare a class template if it isn't visible (e.g. Singleton)
v execution treats typedef transparently, but >trim cannot (hence DirectType)
v do not suggest qualification for an item in the same namespace
v do not suggest adding a forward declaration for an external item
v suggest qualification for a template instance whose class template is in
  another namespace
v NbTracer.h
  --suggests removing the forward declaration of IpBuffer, which *is* used
    indirectly but is also declared in NbTypes.h, which is #included (and
    which is the forward declaration that resolves IpBuffer)
v TcpIoThread.h
  --suggests including SysIpL3Addr.h to pick up forward declaration of
    SysTcpSocket: this is OK, because that is the forward declaration that
    resolved SysTcpSocket, so TcpIoThread.h must already use it transitively
x analyze overridden functions, flagging their usages as "inherited": including
  or declaring forward anything that is inherited is unnecessary (but it isn't
  wrong, and removing it won't eliminate any dependencies, so leave it alone)
x types that underlie public and protected data members are also inherited, but
  derived classes should allow transparent NUC changes in base classes;
  consequently, only types in virtual functions should be considered inherited
x the way #includes and forwards are analyzed is file-based but should probably
  be class-based, because a file can define multiple classes [break the file up
  if you want this!]
x log reliance on a forward declaration in another header [no: one practice
  is to define a header with courtesy forward declarations, such as <iosfwd>]
................................................................................
CHECK BUGS & ENHANCEMENTS
o W008 Cast removes const qualification
  1  C:/Users/gregu/Documents/rsc/rsc/nb/ObjectPool.cpp(828):
       auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
     in a const function, the member blockSize_ appears to transfer constness
	 to the local maxdiff, even through what should be a temporary result
i W039 Data is write-only
  1 C:/Users/gregu/Documents/rsc/rsc/ct/Library.h(211):
      LibraryVarSet* varSet_;
    this doesn't mean that varSet_ can be deleted, because it is used to create
    the symbol "$vars"
o W044 Data could be const
  1 C:/Users/gregu/Documents/rsc/rsc/ct/CxxExecute.h(266):
      CxxToken* via_;
  2 C:/Users/gregu/Documents/rsc/rsc/ct/CodeFile.cpp(79):
      stringVector intIncls_;
	cannot be const because assigned to a non-const reference in a conditional
    statement, but as the "else" clause: fixing this is difficult, as it would
    involve tracking two stack arguments for the assignment operator
o W076 Argument could be const
  1 C:/Users/utas/Documents/rsc/rsc/sb/TlvMessage.h(188/1):
      virtual void DeleteParm(TlvParmLayout& parm);
    parm.header.pid is LHS of = : a single via_ can't track a chain of "."
o enhance >check to detect
  o function whose returned value is never used
  o byte members that are displayed as chars instead of ints (could also check
    pointers for 8/16-byte formatting--look for calls to ostream::operator<< in
    Function.WasCalled)
  o lines that could be merged and still fall within 80-character limit
  o assigning the result of new to a stack or member pointer instead of to a
    unique_ptr or shared_ptr
  o default copy constructor invoked
  o copy constructor does not invoke base class copy constructor (default is
    to invoke base class constructor, not copy constructor)
  o Myers 1-38: redefining inherited default argument value (need to evaluate)
  o Myers 1-29: returning handle to internal data
  o member omitted by Display
  o using statement not in standard order (sort alphabetically)
  o overridden function not in standard order (sort alphabetically)
  o class documentation that does not appear just above the class declaration
    --search on "\{[\n]//"
    --there should be no comment after the { that begins the class declaration
  o double rule (//==) not used between functions in different classes
  o single rule (//--) not used between functions in the same class
o create a configuration file for
  --suppressing specific warnings
  --classes that are exempt from implementing Display
  --classes that are exempt from implementing Patch
  --functions that are exempt from invoking Debug::ft
o in the same way as >trim, allow some warnings to be fixed through CLI
................................................................................
PARSE BUGS & ENHANCEMENTS
o inline friend function not executed for template instance (the function does
  not belong to the template, so it is not picked up during instantiation: the
  solution might be similar to that for Singleton.Instance_, which should also
  be included for each specialization but is bypassed because it is not defined
  inside the class template)
o Singleton instances say that Instance_ is uninitialized: occurs because these
  statements are not executed
o support "= delete" and "= default" for constructor, destructor, assignment
  --convert private functions to "= delete" once "= delete" is supported
o Punt() causes swerr on arg overflow
o "SCOPE" and "clear" repeated in execution trace
o fix "assume template instance is visible" kludge in CodeFile.NameRefersToItem
o expand lexer.PreprocessSource to full tokenization (identifiers, operators,
  numerics, others)
o add class template instances to the correct scope instead of burying them in
  class templates (function template instances are added to the correct scope)
o StackArg should track constness and references (lvalues and rvalues), and
  FuncDecl.CanBeInvokedWith should consider them when selecting a function
o track file and line number for each init/read/write/call
o add option to include source code line numbers in execution trace
o enhance error logs for parse failures
  v output location where failure occurred, along with source code and pointer
  --Punt could provide a diagnostic; what about Retreat?
  --skip to next ';' on most failures, and output the section skipped
o integrate BlockCopied with WasWritten
  --copying of a second-level nested class is probably not handled correctly
  --a new function, WasPassed, should probably be invoked instead of WasWritten
    when an item is passed to an argument by non-const reference or pointer
  --may also want to invoke something on the argument (in case it block-copied
    a class), but it doesn't want to do ++writes_, which calls_ accounts for
o consider implementing virtual functions for LHS and RHS of assignment
  (written/copied), passing, and returning
  --WasWritten(thisArg& StackArg, thatArg& StackArg)
  --WasAssigned(thisArg& StackArg, thatArg& StackArg)
  --WasPassed(thisArg& StackArg, Argument& that)
  --WasReturned(thisArg& StackArg, Function& that)
v call Invoke on constructors up the class hierarchy: need to set base_ to
  the constructor invoked by the member initialization statement (could be
  the default constructor, which may or may not be expliticly defined)
x make local enums and typedefs true locals instead of temporary globals [no:
  these are rare in functions, so it would add little value]
x many examples of pointer arithmetic (e.g. LinkDiff) are no longer reported,
  because the pointers are first cast to intptr_t or something else [this is
  expected; they are now flagged as C-style casts instead]
................................................................................
OTHER ENHANCEMENTS
o documentation
o incremental build (clean and compile affected-by), rebuild (first clean all)
o serialization
o reduce memory usage
  --32-bit: idle=52MB, curr=230MB (before preprocessor support)
  --64-bit: idle=77MB, curr=333MB, time=255s (>show items=94MB)
o generate a global cross-reference, with types of references
  (declaration/definition/initialization/read/write/invocation...)
  --if users are known, then "item is unused" chains can possibly be followed
    (i.e. to avoid discovering that removing an unused item uncovers another
	unused item)
o make namespace view compilable by
  --using access control keywords correctly
  --using /*...*/ for inline comments (e.g. i=/r=/w= in for statement)
  --emitting items in their original order
o implement operators &= -= |= to support >assign a -= b for >assign a a - b
o implement tools to assist with decoupling
  --at the most granular level, dependencies include
    typedef, data, function declaration: underlying types
	class: base class and all member dependencies
	function definition: types, data, functions
  --operator that finds all of the declarations and definitions required by an
    item (e.g. the transitive closure of the types, data, and functions that a
    class or function uses)
  --if enums and typedefs in A were relocated, what would be decoupled?
  --look at Lakos's decoupling strategies
o implement command to create file containing all functions traced by Debug::ft
o enhance >format to
  --remove trailing blanks and tabs
  --insert separators and blank lines
  --remove extra blank lines
  --indent three spaces
  --convert tabs to spaces
  --add and remove #include directives
  --add and remove forward declarations
  --remove using statements
  --sort functions in standard order
  --insert single- and double-rule separators
o enhance >export to format code (e.g. 80-column formatting)
  --need to retain comments and insert line breaks
  --brace init lists will be tricky
  --would be used for large-scale reformatting
o integrate >parse, >check, and >trim
  --one issue is that a "warning" to add an #include or forward doesn't have
    a line number but does have an associated string
  --options would be
    fn: filename (mandatory)
    P: generate parse trace
    p: generate parse trace on failure (fn.parse.txt)
    d: generate definitions execution trace (fn.obj.txt)
    w: generate warning file (fn.warn.txt)
    l: generate library file (= "nfh" options) (fn.lib.txt)
    n: generate namespace view
    f: generate file view
    h: generate class hierarchy
o generating a PDF within C++: see open source library libHaru (aka Haru)
  --use this to graph dependencies
v remove double output of file contents in >export (see CodeFile.DisplayItems)
  --first view does not depend on ordering, whereas second one preserves it:
    both are useful, so make the view an option
................................................................................
CLOSED/NOTES
v invocations of GetExpression:
  Function          Delimited by  Force  Purpose
  GetArgDecl        ,;            Y      default argument value
  GetArgList        ,)            Y      argument value
  GetArraySpec      ]             Y      array size
  GetBraceInit      ,}            Y      field value
  GetCase           :             Y      case label
  GetCast           outer expr    -      expression to be cast
  GetClassData      ;=            Y      field width
  GetClassData      ;             Y      initialization value
  GetConditional    :             Y      value if true
  GetConditional    outer expr    -      value if false
  GetDelete         outer expr    -      pointer to delete
  GetEnumMember     ,}            Y      member value
  GetExpr           ;             -      assignment, function call, null statement
  GetFileData       ;             Y      initialization value
  GetFor            ;             Y      initial clause
  GetFor            ;             Y      conditional clause
  GetFuncData       ;             Y      initialization value
  GetParExpression  )             Y      parentheses
  GetReturn         ;             Y      return value
  GetSubscript      ]             -      index value
  GetThrow          outer expr    -      throw value
v when a unique_ptr is instantiated in a .cpp (but not in a .h), the nullptr
  default parameter for reset() is left on the stack, causing an #ERR! in clear
  --in a .h, no other code is being executed, so operator stack is empty when
    Context.Execute is invoked, which discards the argument on top of the stack
  --in a .cpp, other code is being executed, so operator stack is *not* empty
    when Context.Execute is invoked, which leaves that argument on the stack
  --fixed by unwinding argument stack when popping parser
v verify that operands are compatible (lhs and rhs in assignment, for example)
x template argument need not be inaccessible in scope where used [documented]
x templates can be instantiated because of code in headers: should only occur
  when compiling .cpps, which might make it easier to resolve some >trim bugs
  [no: a header should compile on its own, as if a .cpp using only the header
  #included it, which is what instantiating the template simulates]
v no usage for varSet_ found, but Library.Startup writes to it ["no usage"
  means no readers; this does not necessarily mean (as is the case here)
  that the item does nothing useful]
x instead of setting via_ to the direct predecessor of arg.item, leave it as the
  *original* value: no, this could cause new via_ to be flagged "could be const"
x shouldn't log FunctionUnused for main(): not worth fixing, and it's amusing
x shrink_to_fit does nothing: can only account for ~70MB out of ~180MB, even
  when using capacity() instead of size() to get string and vector sizes
x auto v2 = vector<T>(v1.begin(), v1.end()).swap(v1) is the idiomatic way
  to replace a vector with one of the desired size [not implemented because
  containers do not appear to have a lot of unused space]
x optimize an Expression that contains one item (e.g. a Literal or QualName)
  [no: memory savings would be modest]
x convert strings to char* (need option to recreate string) [no: memory
  savings be modest]
x "auto*" is displayed (even though the source code reads "auto") when the type
  is a pointer [it isn't actually wrong and occurs because the ptrs_ field can
  be modified, so it no longer contains the value that was parsed]
x if a class template returns T&, does it make sense to return arg*& when the
  argument is tagged with a pointer, or should the "&" be deleted? [no: keep it]
x pair<string*,bool> and pair<CxxNamed**,bool> are not instantiated (these are
  the return type from hash table insert functions, but are not used)
x capture #define as an identifier (e.g. Posix signal), but not the #define of
  #include guards, as they have no value (a value of EMPTY_STRING, literally)
  [changed Posix signals from #define to const signal_t SIGname = n]
x EnterBlock is invoked twice on DataDecl components (e.g. array spec) when
  UpdateDeclaration returns true [legitimate, because both .h and .cpp use it]
x subclass CxxToken (and other library items) from nothing [had a negligible
  effect on speed or memory usage]
================================================================================
PLATFORM BUGS
? for ctrl-C failure, see Output window: it can cause some other thread to exit
  --problem has recurred: system is dormant after ctrl-C
  --appears that no thread can acquire RTC lock
? first function in traceback isn't always the one that trapped, even when the
  one that trapped isn't trivial (could be caused by compiler optimizations)
? FileThread running locked too long, with double logging of THREAD YIELDED
? FileThread fails to release mutex (mutex=0x34, reason=0x120=not owner)

* when mode=counts, throughput is about 20% of normal (5x slowdown) and logs
  occur instead of detecting overload, probably because ingress queue length
  remains short and not enough messages are in use: probably need to consider
  CPU idle time for overload as well
* when object pool audit recovered a thread, an infinite trap loop ensued, with
  TrapHandler repeatedly trying to set priv_->trapped (was priv_ either corrupt
  or nullptr?)

o check if function trace output ignores functions executed in another thread
  when calculating times spent in a function (if such a function is at lesser
  depth, it may be truncating the time spent in the first function)
o convert to unique_ptr
  --any "= new T" or "delete p" expression is suspicious unless A derives from
    PooledObject
  --release() if unique_ptr will survive but underlying memory will be freed
  --reset() if unique_ptr will not survive but underlying memory will, unless
    it can be found again after the restart
  --unique_ptr in template classes?
    o implement Registry<T*> as Registry<unique_ptr<T>>
    o install a noop deleter_type if Registry.delete_ is false
    o implement Singleton<T> as Singleton<unique_ptr<T>>
o implement MutexRegistry so a thread can release any held mutexes when exiting
  --use std::map< SysMutex_t, SysMutex* > to map mutex handle to mutex object
  --mutex should not be held when blocked, including Pause()
  --deleting a held mutex produces a bizarre traceback in Debug.SwErr
  --have registry release mutexes allocated in memory that is freed en masse
o implement thread to analyze hung system and act as watchdog to restart threads
  --gather data on threads and mutexes: look at MutexRegistry
  --cause restart if critical work is not being performed: have a thread clear a
    vector, and have work threads set flags in the vector (perhaps by role, such
	as invoker, I/O, CLI, log, stats...)
================================================================================
NEXT UP
? optionality, to allow NodeBase to be open-sourced while removing
  capabilities that could be upsold (there may not be much to remove)
o "SMP considered harmful" for embedded systems
  --for multithreaded executable or memory shared between executables
  --creates artificial complexity (semaphores) 
  --recursive control is a better design (scalability, reuse)
  --case studies: MSC and XA-Core
o "SRI" query
  --phase 1: internal
  --phase 2: separate executable, looparound to well-known port
  --phase 3: distribution of DN data
  --phase 4: separate executable with allocated IP address
================================================================================
RESTARTS
? trap in InitThread on startup: unknown exception
  --is an access violation when invoking systhrd_->Start: SysThread.status_ is
    still nullptr
? StatisticsThread lost over warm restart
? some threads that plan to exit during warm restart don't exit until after
* under 2400 cpm with CIP/TCP, cold restart causes corruption of CPU register,
  although system survives if told to continue
o code/test reload restart (Shutdown and Startup, without memory protection)
o modify restart testcases to save symbols for size of each memory segment
  before and after restart, and pass/fail based on whether there was an increase
o use timed interrupt after notifying threads in ModuleRegistry.Shutdown?
o modify ObjectPool (MemProt), which can own MemPerm (threads): probably
  needs to be split into MemImm (prot) and MemPerm (unprot)
o implement CfgParm.RestartRequired functions for ObjectPool and others
i shutdown/startup for objects of a certain memory type: scan for "Mem<str>"
  and ": public <string>Object"
x scheduling timeout occurs when initialization is delayed by symbol loading:
  this should be a restart timeout (which is longer), not a scheduling timeout
  [no, the delay (after main) occurs in TcpIoThread, so behavior is correct]
x investigate rebuilding the data on which a thread depends if it traps too
  often (e.g. TcpIoThread.sockets) [no: a restart should do this, initiated by
  the not-yet-implemented leaky bucket counter that drains when the system is
  trapping too often)
x when traffic is running, numerous POTS swerrs occur after warm restart [this
  only occurred when function tracing was active, which significantly slows the
  system down]
v after launch, memory usage creeps up: tracing is still running; stopping it
  stops the creep--Windows task manager is actually tracking allocations in
  TraceBuffer, because the creep corresponds to what is shown by >query buffer
v after restart, audit recovers messages queued on log/cout/file threads:
  this is legitimate, because queue is reinitialized
v warm restart increases memory usage by ~10MB
  --caused by SysThreadStack when ElementException is thrown, capturing stack
  --occurs on the first throw, but not subsequent ones
v immediate trace on startup causes heap corruption, although it isn't fatal
  --occured in Registry.Extend, when ServiceSMPool registered a statistic
  --no longer occurs in VS 2015
  --see crt0dat.c for loop that initializes items before entering main()
--------------------------------------------------------------------------------
NETWORK LAYER
o allow CIP to bind both TCP and UDP
  --define a configuration parameter for protocol (UDP/TCP)
  --define configuration parameters for rx/tx buffer size, max conns/backlog
o implement CLI command to display IpServices and provision them using the above
o CreateText should use service name as either text_ or expl_; this would
  also apply to Factory and any others
o need a way to provision a peer port, probably in a table of known peers:
  POTS call should not imbed in POTS shelf, and vice versa
? evolve IpPortCfgParm into HostIpPortCfgParm and PeerIpPortCfgParm
o support CIP/TCP using a shared socket for each peer node
  --need to make SysTcpSocket virtual and add two subclasses
  --first subclass is per-session (current SysTcpSocket)
  --second subclass is the one that allows sharing
o shared SysTcpSocket
  --does not disconnect until all instances, including the one in TcpIoThread,
    are deleted (use shared_ptr?)
  --needs to be set in GlobalAddress by looking up the "route" (socket) to the
    destination node
  --socket to destination is created by first Connect or Accept
o analyze socket work items (//s), most of which involve recovering from
  socket errors
o find out how to create an IP address for each processor
  --without this, cannot use well-known ports: would have to assign low order
    nibble to processor number (i.e. well known port is 0xhhhP)
i discussion of host addresses:
  http://stackoverflow.com/questions/122208/get-the-ip-address-of-local-computer
x support automatic provisioning of multiple IP ports for a service: need to
  define IpService.GetPorts, possibly replacing IpService.GetPort [no: the
  use case is having one IP address for SMP, but this is undesirable because
  it precludes the use of well-known ports]
v running traffic with CIP using TCP
  --maximum capacity is about 1/3rd that for UDP
  --many RTC timeouts in TcpIoThread, even when pausing at 50% of timeslice
  --many more bytes transmitted than received
  --a lot of time spent setting up and tearing down TCP connections
v cache result of IpPortRegistry.HostAddress, probably on a cold restart, and
  assess capacity improvement
--------------------------------------------------------------------------------
DISTRIBUTION
o should remote operations be done using a protocol or a remote console?
  --if by console, text responses must be parsed (e.g. "OK."): this seems
    undesirable, but standardizing CLI return values might make it possible
  --if by protocol, it doesn't make sense if response doesn't need to be
    parsed (e.g. uploading traces, displaying data)
o CLI
  --I/O mechanisms are (a) MsgBuffer between threads (b) I/O thread between
    executables (c) PSM between executables (d) CinThread/CoutThread
  --use PSM pair between local and remote (support TCP), but how to handle
    intraprocessor case?
	CinThread        CliThread                   |    RinThread       CliThread
	CoutThread                       IoThread    |    RoutThread
o uploading logs to control node
o uploading statistics to control node
o uploading files to control node
? decouple CliThread from PotsAdmin commands (subscribe, activate) and others
o new POTS_NU_Message for outgoing message not on a PSM:
  --PotsCallFactory.AllocOgMsg (invoked from InjectCommand.ProcessCommand)
  --PotsCallFactory.SendRelease (reply to an incoming message)
  --ResetCommand.ProcessCommand (to reset interface)
o new POTS_UN_Message for outgoing message not on a PSM:
  --PotsMuxFactory.AllocOgMsg (invoked from InjectCommand.ProcessCommand)
  --PotsShelfFactory.AllocOgMsg (invoked from InjectCommand.ProcessCommand)
  --PotsCircuit.CreateMsg (invoked by PotsCircuit and PotsTrafficThread)
o table control framework
  --register roles as observers of table control changes
  --give each observer a status field in each tuple, so that it can track
    whether the tuple has been updated in its node (therefore need to keep
	a deleted tuple until all affected nodes have deleted it) 
  --register tables with framework
  --tables consist of tuples (records); each tuple has a key
  --methods include
    >table(name): access a table (should be locked)
    >pos(key): find a tuple
	>insert: add a tuple (specify key; field-by-field editing)
	>erase: delete current tuple
	>change: modify current tuple (field-by-field editing)
	>commit: commit edited tuple
	>up(n): go up N tuples
	>down(n): go down N tuples
	>prev: same as >up 1
	>next: same as >down 1
	>count: count number of tuples
	>top: go to first entry
	>bottom: go to last entry
o implement local maintenance using SSM with ePSM and iPSM (external/internal)
  --add invoker thread in maintenance faction
  --initialization code sends startup message to iPSM
  --ePSM communicates with operations node: need well-known port numbers for
    registration (operations node) and local node maintenance (all nodes)
  --iPSM provides local interface (startup; commands from console, if any)
o how to avoid going through node/role configuration again...
  --during a restart? (preserve configuration)
  --during a reboot? (journal file--must therefore be *per executable*)
  --local maintenance should also have a journal file to handle a total outage
  --local maintenance needs ability to restart/reboot and synch with Executables
--------------------------------------------------------------------------------
LAYERING
o shorten namespace names or create a single namespace (rsc::)
  --node, net, session, media, call, pots, code
v add #ifdef OS_WIN to all *.win.cpp files; rename ct32.txt and ct64.txt to
  win32.txt and win64.txt (look for best practices for targeting)
x rename Element to Node [no: element = computing platform, possibly SMP;
  node = two elements if in a warm standby or load sharing configuration]
x create Sys* layer, which actually uses little above it (Object::Display,
  Debug::ft, and a few others): may need a BasicObject superclass for Object,
  which only defines Display, Patch, and perhaps a few other functions [no:
  does not appear to have value; a standalone application requires more]
x investigate "extern" keyword: can it be used to decouple lower layers, so
  that CodeTools (for example) doesn't need all of NodeBase? [no: would need
  to use the equivalent of procvars]
--------------------------------------------------------------------------------
SYNCHRONIZATION
v determine which fields require atomicity or locking
  --those that are modified when not locked
  --anything modified by RootThread or InitThread needs protection if another
    thread could also access it: queueing a log, raising a signal
  --in other cases, threads should not be unlocked if modifying something that
    another thread could also access
v non-const functions that can be invoked on another thread:
  --Thread.ctor: cannot be found until added to ThreadRegistry
  --Thread.dtor: proscribed, so not thread safe
  * Thread.ChangeFaction
  * Thread.Claim: from ObjectPoolAudit
  * Thread.Cleanup: from ObjectPooolAudit
  --Thread.EnqMsg: protected by queue lock
  * Thread.Interrupt
  * Thread.Raise
  --Thread.Recreate: from InitThread
  --Thread.Restarting: from InitThread
  --Thread.RtcTimeout: from InitThread
  --Thread.SetSignal: from Thread.Raise
  --Thread.SetStatus: from CliThread
  --Thread.Shutdown: from InitThread
  --Thread.Startup: from InitThread
  --Thread.SetTrap: from Thread.Raise
  * Thread.Unblock
  --Thread.systhrd_: deleted by other thread
  --Thread.msgq_: message queued by other thread
  --Thread.faction_: ChangeFaction invoked by other thread
--------------------------------------------------------------------------------
OTHER ENHANCEMENTS
o hot patching: see article(s) on codeproject.com: "hotpatching"?
o proportional scheduling
  --add a "scheduling condition variable" to each faction
  --Faction will become a base class
    o rename faction_t to FactionId, but leave it and constants in NbTypes.h
	o rename Faction() function to GetFaction()
	o move strFaction into the class
  --thread waits on conditional variable instead of acquiring RTC lock
    o before waiting, mark self ready (not blocked) and increment faction's
	  count of ready threads
	o after waiting, reset flag associated with condition variable, decrement
	  faction's count of ready threads, and mark self running
  --scheduler (new thread) signals condition variable to let faction run
  --scheduler is similar to current InitThread under normal operation
  --scheduler decides which faction will run next; could use timewheel
  --when thread is about to pause or perform a blocking operation, it signals
    scheduler so that the next faction can be chosen
  --when a thread in payload faction or lower runs preemptably, its priority
    is reduced to LowPriority so that unpreemptable threads have priority
  --scheduler can give time to preemptable threads by not signalling the
    condition variable of any faction
  --apply the same design recursively, to an element manager that is supervising
    multiple executables, giving each a guaranteed percentage of the CPU
  --each executable should have its own IP address: *this* is probably the right
    design, as opposed to an IP address for each element
  --"spurious wakeup" problem means that, when awoken, thread must check that
    the underlying condition is actually true (see notes at cppreference.com)
  --implementing SetEvent and WaitEvent using condition variable (consider an
    atomic_count instead of a bool, to support multiple calls to Interrupt):
	http://stackoverflow.com/questions/8883512/pthread-condition-variables-vs-win32-events-linux-vs-windows-ce
o logs
  o >suppress command (requires log identifiers)
  o statistics by log class
  o >route command (to console, file, socket)
    --also for other outputs (statistics, reports)
  o priorities (queue by priority and spool accordingly: need timestamp
    for correlation, in case low priority log is delayed)
  o to test, underprovision MsgPorts and see what happens on seize failures
o add code sketch for memory protection
  --Protect() function and protected_ flag for heap
  --unprotect and reprotect at beginning/end of restart
o enhance memory trace tools to display object that occupies an allocated segment
  and track all allocated segments (unless heap supports iteration for this)
o investigate debug heap, which can look for memory leaks
o support diffs of trace output
  --add an argument to TraceRecord.Display to suppress variable information
  --add a command for removing timestamps and other variable information
    from trace output
o bind string for each software flag; consider using dynamic identifiers
o move class tests in NtIncrement.cpp to separate .test.cpp files, each of
  which binds a CliCommandSet to NtIncrement
  --consider doing the same for commands like >threads and >protocols
  --look for C++ best practices for where to place test code
o auto-engineer size of pools based on traffic rate
o prevent POTS circuit from sending Offhook in response to Release more than
  once: causes infinite messaging loop (Offhook-Release-Offhook-Release...)
o add fail paths:
  --ProtocolSM.Find: POTS
  --TlvMessage.FindType invocations
o adopt AddLibCommand's update of EXPL argument in other commands
o DisplayUsed, MessagesCommand, PsmsCommand, SsmsCommand, TimersCommand, and
  MepsCommand should prompt for whether to display more objects
i initializing static const member from config file or making it mutable:
  http://stackoverflow.com/questions/33572283/can-i-initialize-a-static-const-member-at-run-time-in-c
x remove most usages of word/uword
  --consider using intptr_t/uintptr_t when an int may be a pointer value
  --consider using size_t when an int is proportional to the memory size
x define a second version of Debug::ft that can be used for "trivial" functions,
  which are not captured unless a function trace option is enabled [no: marginal
  value]
x rename Singleton registry functions to align with Registry
  --Bind > Insert, Unbind > Erase, GetX > At [no; some registries contain two
    types of elements, so this devolves into InsertX, InsertY, which isn't a
	significant improvement]
x convert to STL containers:
  --Registry: map< Id, Base* > would have log(n) lookup time; could it be forced
    to use a vector?
  --Array could use vector and implement erase(i) as v[i] = v.pop_back()
  --general approach is to wrap STL container in a new class and forward to it
    as required (erase(), for example, can't be overridden)
--------------------------------------------------------------------------------
RELEASE BUILD PROBLEMS
o enter _NO_DEBUG_HEAP=1 under Configuration>Debugging>Environment
o "save funcs init" causes "Extra input ignored"
o stack overflow doesn't occur: Recurse is inlined, even with /Ob1 option
================================================================================
CODING STANDARD
o don't use a bare "//" when a block comment does not apply to what follows
  --especially when a local data declaration follows, because the comment is
    interpreted as documentation for the local
  --search on "//\r?\n[ \t]*auto" as regexpr
  --consider removing all bare "//" in source code (retain before class members)
    search on "[ ]+//(?=\r?$)" as regexpr
================================================================================
IF COMPILER DOES NOT SUPPORT C++11
o constexpr: #define constexpr static const
o final: #define final
o noexcept: #define noexcept
o nullptr: #define nullptr NULL
o override: #define override
o auto: implement tool to replace occurrences of "auto" with actual type
o <cstdint>: provide header
o atomic<T>, unique_ptr<T>, unique_ptr<T>[]: implement class templates
o unordered_map<T>, unordered_multimap<T>: convert to map and multimap