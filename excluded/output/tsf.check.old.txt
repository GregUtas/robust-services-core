LINE COUNTS
 source code   60476
       blank   34537
          //   12033
separator //    6730
   tagged //     203
     text //   17184
          /*       0
           {   11856
           }   10275
          };    1584
   Debug::ft    3834
     fn_name    3813
    ...split      94
    #include    5118
    #<other>     964
       using     718
       TOTAL  169419

WARNING COUNTS
  W006    75  C-style cast
  W007    52  Functional cast
  W008    84  reinterpret_cast
  W009   517  Cast down the inheritance hierarchy
  W010    37  Cast removes const qualification
  W011     3  Pointer arithmetic
  W015     3  #include not sorted in standard order
  W017   218  Using statement in header
  W019    28  Unused argument
  W020     9  Unused class
  W021    18  Unused data
  W022     1  Unused enum
  W023    20  Unused enumerator
  W026   128  Unused function
  W027     3  Unused typedef
  W030     5  No referent for friend declaration
  W032     9  Member hides inherited name
  W033     1  Class could be namespace
  W036   141  Member could be private
  W037    60  Member could be protected
  W038    10  Typedef of pointer type
  W041    27  Data is init-only
  W042     1  Data is write-only
  W044    24  Data is not private
  W047    76  Data could be const
  W048    15  Data could be const pointer
  W050    42  Default constructor invoked: POD members not initialized
  W051     3  Default constructor invoked
  W052    19  Default copy constructor invoked
  W053    15  Default assignment operator invoked
  W054    65  Base class constructor is public
  W055     1  Single-argument constructor is not explicit
  W056     1  Member not included in member initialization list
  W059    27  Base class virtual destructor is not public
  W069   355  Virtual function is public
  W071   100  Virtual function has no overrides
  W076    76  Adjacent arguments have the same type
  W077     4  Virtual function defines default argument
  W080    36  Argument could be const
  W082    72  Function could be const
  W084   143  Function could be free
  W091   282  Line contains adjacent spaces
  W094     1  Line length exceeds the standard maximum
  W095     3  Function not sorted in standard order
  W098   463  Function does not invoke Debug::ft
  W099    17  Function does not invoke Debug::ft as first statement
  W101    29  Override of Base.Display not found
  W102    26  Override of Object.Patch not found
========================================================================================================================
WARNINGS SORTED BY TYPE/FILE/LINE
W006 C-style cast
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(494):    Singleton< TrafficCallPool >::Instance()->Enq((TrafficCall*) addr);
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(1068):    timewheel_ = (Q1Way< TrafficCall >*) Memory::Alloc(size, MemDyn);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(2068):    info_ = (LineInfo*) Memory::Alloc(sizeof(LineInfo) * lines_, MemTemp);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(486):    LibrarySet* nbSet = (LibrarySet*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(518):    LibrarySet* nsSet = (LibrarySet*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(414):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(1010):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(331):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1194):    return (CxxToken*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1369):    return (CxxToken*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(146):    virtual CxxNamed* Referent() const override { return (CxxNamed*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(451):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(541):    virtual CxxToken* AutoType() const override { return (CxxNamed*) enum_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(942):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(1018):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(18):    return (void*) ((ptr_t) ptr2 - diff);
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(25):    return (void*) ((ptr_t) ptr1 + diff);
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(62):    return ((ptr_t) ptr1 - (ptr_t) ptr2);
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.cpp(205):    if(addr != nullptr) return (Object*) addr;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliPtrParm.cpp(83):          p = (void*) n;
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(371):          auto src = (ptr_t) this;
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(210):    auto seg = (Segment*) addr;
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(267):    auto segment = (Segment*) getptr1(addr, SegmentHeader::Size());
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(318):    auto source = (Segment*) getptr1(addr, SegmentHeader::Size());
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(369):    auto source = (Segment*) getptr1(addr, SegmentHeader::Size());
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(223):       blocks_[currSegments_] = (uword*) Memory::Alloc(size, type_, false);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(246):          auto b = (ObjectBlock*) &seg[j];
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(298):             auto b = (ObjectBlock*) &seg[j];
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(335):             auto curr = (Pooled*) getptr1(item, diff);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(699):       return (ObjectBlock*) &blocks_[0][0];
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(769):       return (ObjectBlock*) &blocks_[i][j];
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(794):             auto b = (ObjectBlock*) &seg[j];
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(826):    auto block = (ptr_t) ObjToBlock(obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(827):    auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(831):       auto b0 = (ptr_t) &blocks_[i][0];
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(874):    return (ObjectBlock*) getptr1(obj, BlockHeader::Size);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(904):          auto b = (ObjectBlock*) &seg[j];
  C:/Users/gregu/Documents/tsf/tsf/nb/Pooled.cpp(127):    auto obj = (Pooled*) addr;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.win.cpp(146):    aHeaps = (HANDLE*) HeapAlloc(DefaultProcessHeap, 0, BytesToAllocate);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(122):    return CreateThread(
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(329):    _set_se_translator((_se_translator_function) SE_Handler);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(147):    Symbols = (SYMBOL_INFO*) Memory::Alloc(size, MemPerm, false);
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(110):    buff_ = (uword*) Memory::Alloc(InitialSize << BYTES_PER_WORD_LOG2, MemPerm);
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(220):    auto addr = (TraceRecord*) &buff_[end_];
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(413):       next = (uword*) record + incr;
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(431):             record = (TraceRecord*) buff_;  // case (b)
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(435):          record = (TraceRecord*) next;
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(444):       next = (uword*) record + incr;
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(470):       auto record = (TraceRecord*) &buff_[start_];
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(577):    buff_ = (uword*) Memory::Alloc(size << BYTES_PER_WORD_LOG2, MemPerm, false);
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.cpp(43):    functionq_ = (Q2Way< FunctionStats >*) Memory::Alloc(size, MemTemp);
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.cpp(62):    buffer_ = (byte_t*) Memory::Alloc(SysSocket::MaxMsgSize, MemDyn);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.cpp(56):    buff_ = (byte_t*) Memory::Alloc(BuffSize(buffSize_), MemDyn);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.cpp(75):    buff_ = (byte_t*) Memory::Alloc(BuffSize(buffSize_), MemDyn);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.cpp(116):       auto buff = (byte_t*) Memory::Realloc(buff_, BuffSize(newSize));
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.win.cpp(42):          auto netaddr = (sockaddr_in*) info->ai_addr;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.win.cpp(97):    if(getnameinfo
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(71):    if(bind(socket_, (sockaddr*) &addr, sizeof(addr)) == SOCKET_ERROR)
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(189):    if(setsockopt(socket_, SOL_SOCKET, SO_RCVBUF,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(196):    if(getsockopt(socket_, SOL_SOCKET, SO_RCVBUF,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(206):    if(setsockopt(socket_, SOL_SOCKET, SO_SNDBUF,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(213):    if(getsockopt(socket_, SOL_SOCKET, SO_SNDBUF,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(27):    auto socket = accept(Socket(), (sockaddr*) &peer, &peersize);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(55):    if(connect(Socket(), (sockaddr*) &peer, sizeof(peer)) == SOCKET_ERROR)
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(100):    if(getsockname(Socket(), (sockaddr*) &host, &hostsize) != 0)
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(208):    if(getpeername(Socket(), (sockaddr*) &peer, &peersize) == SOCKET_ERROR)
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(30):       if(getsockopt(Socket(), SOL_SOCKET, SO_MAX_MSG_SIZE,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(59):    auto rcvd = recvfrom(Socket(), reinterpret_cast< char* >(buff),
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(97):    auto sent = sendto(Socket(), reinterpret_cast< const char* >(data),
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(737):    ((ProtocolSM*) p)->Kill();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(756):             else if(((AnalyzeSapEvent*) ogEvent)->CurrInitiator() != nullptr)
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(758):             else if(((AnalyzeSapEvent*) ogEvent)->CurrSsm() != nullptr)
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(161):    auto pptr = (TlvParmPtr) (layout->bytes + layout->header.length);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(270):    return (Fence*) fence;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(428):    pit.pptr = (TlvParmPtr) &pit.mptr->bytes[nextIndex];
W007 Functional cast
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfIpService.cpp(96): ipport_t PotsShelfIpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(260): ipport_t CipUdpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(363): ipport_t CipTcpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/cb/DigitString.cpp(124):       auto rc = AddDigit(Digit(ds.digits_[i]));
  C:/Users/gregu/Documents/tsf/tsf/cb/DigitString.cpp(156):    if(i < Size()) return Digit(digits_[i]);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(541):       stream << setw(12) << LineType(t)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(553):          stream << setw(6) << WarningCode(Warning(w))
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(571):       stream << WarningCode(w) << SPACE << Warning(w) << CRLF;
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(245):       if(Attrs[i].symbol.compare(sym) == 0) return Cxx::Operator(i);
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(297):          oper = Cxx::Operator(i);
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(355):       Attrs[ValidIntDigits[i]].intValue = int8_t(i);
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(361):       Attrs[ValidHexDigits[i]].hexValue = int8_t(h);
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(366):       Attrs[ValidOctDigits[i]].octValue = int8_t(i);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(1325):    if(count >= 0) return size_t(count);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(645):    if(arrays_ != nullptr) count += TagCount(arrays_->size());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1293):    if(arrays_ != nullptr) count += TagCount(arrays_->size());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(815):          stream << uint64_t(num_);
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(140):          type = LibTokenType(i);
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(823):          oper = Cxx::Operator(match->second);
  C:/Users/gregu/Documents/tsf/tsf/mb/Tones.h(50):    Id Tid() const { return Id(tid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCookie.cpp(110):       stream << int(index_[i]) << SPACE;
  C:/Users/gregu/Documents/tsf/tsf/nb/ModuleRegistry.cpp(91):          return RestartLevel(errval_);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(469):       rc = nbt->SelectFaction(Faction(id), TraceDefault);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(677):       rc = nbt->SelectFaction(Faction(id), TraceExcluded);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(1075):       rc = nbt->SelectFaction(Faction(id), TraceIncluded);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(2426):       auto heap = Memory::Heap(MemoryType(m));
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.cpp(192):             stream << Faction(f) << CRLF;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(82):    ObjectPoolId Pid() const { return ObjectPoolId(pid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(347):          Truncate(TimeField(int(field) + 1));
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(528):          return OutOfRange(TimeField(f));
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(143):    Id Tid() const { return Id(tid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.cpp(23):    size_(int16_t(size)),
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3018):    pool->time_[id1].Truncate(TimeField(field - 1));
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3049):    pool->time_[id1].Round(TimeField(field - 1), interval);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(48):    Id Fid() const { return Id(fid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(72):    Id Fid() const { return Id(fid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(55):    Faction GetFaction() const { return Faction(faction_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPoolRegistry.cpp(77):       auto p = reg->Pool(Faction(id));
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(64):    Id Pid() const { return Id(pid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(56):    Id Prid() const { return Id(prid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(686):       auto pool = reg->Pool(Faction(sc));
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.cpp(112):    if(msgs->AvailCount() <= size_t(NoIngressMessageCount_)) return true;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.cpp(114):    return (WorkQCurrLength(Message::Ingress) >= size_t(NoIngressQueueLength_));
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(128):          stream << strClass(reg->GetService(ServiceId(cid_)), false);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(133):          stream << strClass(reg->GetFactory(FactoryId(cid_)), false);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(447):    width -= col_t(label.size());
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(44):    Id Sid() const { return Id(sid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(60):    Id Sid() const { return Id(sid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/State.h(39):    Id Stid() const { return Id(stid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(212):       return MsgSize(Memory::Align(size, Log2Align));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallIpService.cpp(93): ipport_t PotsCallIpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(327):       if(rows_[row].size() > size_t(end))
W008 reinterpret_cast
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfHandler.cpp(55):    auto pptr = reinterpret_cast< TlvParmPtr >(sbuff->PayloadPtr());
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfHandler.cpp(56):    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(482):    auto fake = reinterpret_cast< const TrafficCall* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.cpp(82):    reinterpret_cast< const DigitString* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcCause.cpp(119):    reinterpret_cast< const CauseInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProgress.cpp(105):    reinterpret_cast< const ProgressInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(513):    reinterpret_cast< const RouteResult* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.cpp(46):    auto fake = reinterpret_cast< const CodeDir* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(754):    auto fake = reinterpret_cast< const CodeFile* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(257):    auto fake = reinterpret_cast< const LibrarySet* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.cpp(49):    auto fake = reinterpret_cast< const Circuit* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.cpp(103):    reinterpret_cast< const MediaInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.cpp(560):       auto cxi = reinterpret_cast< MediaInfo* >(pptr->bytes);
  C:/Users/gregu/Documents/tsf/tsf/mb/Tones.cpp(51):    auto fake = reinterpret_cast< const Tone* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.cpp(118):    auto obj = reinterpret_cast< ObjectStruct* >(this);
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.cpp(146):    auto obj = reinterpret_cast< const ObjectStruct* >(this);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.cpp(122):    auto fake = reinterpret_cast< const CfgParm* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.cpp(75):    auto fake = reinterpret_cast< const CfgTuple* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.cpp(60):    auto fake = reinterpret_cast< const Class* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.cpp(64):    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.cpp(144):    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.cpp(88):    auto fake = reinterpret_cast< const CliIncrement* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.cpp(81):    auto fake = reinterpret_cast< const CliParm* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Module.cpp(49):    auto fake = reinterpret_cast< const Module* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(573):    reinterpret_cast< const Base* >(p)->Output(*cli.obuf, 2, v);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(624):    strBytes(*cli.obuf, spaces(2), reinterpret_cast< const byte_t* >(p), n);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.cpp(126):    auto obj = reinterpret_cast< ObjectStruct* >(this);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(462):    auto fake = reinterpret_cast< const ObjectPool* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Pooled.cpp(101):    auto fake = reinterpret_cast< const Pooled* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(54):    auto fake = reinterpret_cast< const PosixSignal* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.cpp(74):    auto fake = reinterpret_cast< const Statistic* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.cpp(66):    auto fake = reinterpret_cast< const StatisticsGroup* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.cpp(85):    auto fake = reinterpret_cast< const Symbol* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.cpp(18):    auto bytes = reinterpret_cast< uint8_t* >(&value);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1155):    auto fake = reinterpret_cast< const Thread* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1519):    auto self = reinterpret_cast< Thread* >(arg);
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.cpp(52):    auto fake = reinterpret_cast< const Tool* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionStats.cpp(56):    auto fake = reinterpret_cast< const FunctionStats* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1164):    auto fake = reinterpret_cast< const Q1WayItem* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1684):    auto fake = reinterpret_cast< const Q2WayItem* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(2245):    auto fake = reinterpret_cast< const RegistryItem* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3479):    auto p = reinterpret_cast< char* >(BAD_POINTER);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(261):    auto fake = reinterpret_cast< const IpPort* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.cpp(54):    auto fake = reinterpret_cast< const IpService* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(190):    auto rcvd = recv(Socket(), reinterpret_cast< char* >(buff), max, 0);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(235):    auto sent = send(Socket(), reinterpret_cast< const char* >(data), len, 0);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(59):    auto rcvd = recvfrom(Socket(), reinterpret_cast< char* >(buff),
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(97):    auto sent = sendto(Socket(), reinterpret_cast< const char* >(data),
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.cpp(73):    auto fake = reinterpret_cast< const PotsFeature* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.cpp(82):    auto fake = reinterpret_cast< const PotsFeatureProfile* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.cpp(72):    auto fake = reinterpret_cast< const PotsProfile* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(563):    reinterpret_cast< const PotsFacilityInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(732):    reinterpret_cast< const PotsHeaderInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(853):    reinterpret_cast< const PotsRingInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(941):    reinterpret_cast< const PotsScanInfo* >(bytes)->Display(stream, prefix);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(558):    auto fake = reinterpret_cast< const Context* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(871):             auto toi = reinterpret_cast< TimeoutInfo* >(pptr->bytes);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(187):    auto fake = reinterpret_cast< const Factory* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.cpp(195):    auto fake = reinterpret_cast< const Initiator* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(210):    auto fake = reinterpret_cast< const InvokerPool* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.cpp(109):    auto fake = reinterpret_cast< const InvokerThread* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.cpp(87):    auto fake = reinterpret_cast< const Parameter* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(77):    auto fake = reinterpret_cast< const Protocol* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInputHandler.cpp(62):    auto header = reinterpret_cast< const MsgHeader* >(source);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIpBuffer.h(49):       { return reinterpret_cast< MsgHeader* >(HeaderPtr()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.cpp(268):    auto fake = reinterpret_cast< const Service* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.cpp(62):    auto fake = reinterpret_cast< const Signal* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/State.cpp(175):    auto fake = reinterpret_cast< const State* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/Timer.cpp(176):    auto fake = reinterpret_cast< const Timer* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerProtocol.cpp(104):    auto toi = reinterpret_cast< const TimeoutInfo* >(bytes);
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerRegistry.cpp(127):          auto psm = reinterpret_cast< const Base* >(t->Psm());
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerRegistry.cpp(139):          auto psm = reinterpret_cast< const Base* >(t->Psm());
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(51):    auto encap = reinterpret_cast< const TlvMsgLayout* >(parm.bytes);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(496):    auto encap = reinterpret_cast< TlvMsgLayout* >(pptr->bytes);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(253):       { return reinterpret_cast< TlvMsgLayout* >(Buffer()->HeaderPtr()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvProtocol.cpp(55):       auto pptr = reinterpret_cast< TlvParmPtr >(&bytes[index]);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallHandler.cpp(81):    auto pptr = reinterpret_cast< TlvParmPtr >(sbuff->PayloadPtr());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallHandler.cpp(82):    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1451):          auto ring = reinterpret_cast< PotsRingInfo* >(pptr->bytes);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.cpp(70):    auto fake = reinterpret_cast< const PotsTreatmentQueue* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.cpp(191):    auto fake = reinterpret_cast< const PotsTreatment* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.cpp(74):    auto fake = reinterpret_cast< const MscAddress* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/st/MscContext.cpp(85):    auto fake = reinterpret_cast< const MscContext* >(&local);
  C:/Users/gregu/Documents/tsf/tsf/st/MscContextPair.cpp(77):    auto fake = reinterpret_cast< const MscContextPair* >(&local);
W009 Cast down the inheritance hierarchy
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfFactory.cpp(124):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfFactory.cpp(136):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfFactory.cpp(157):    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfFactory.cpp(167):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfHandler.cpp(53):    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.cpp(99):    auto& tlvmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.cpp(150):    auto& tlvmsg = static_cast< const TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(36):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(38):    auto& bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(64):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(65):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(67):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(121):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(122):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(124):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(166):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(167):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(169):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(200):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(201):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(203):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(528):    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(558):    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(870):       if(m->GetSignal() == sid) return static_cast< CipMessage* >(m);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(904):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1034):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1433):    auto& tmsg = static_cast< const CipMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1438):    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSsm.cpp(390):    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSsm.cpp(905):       auto fac = static_cast< BcFactory* >(reg->GetFactory(route_.selector));
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(408):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(409):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(411):    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(448):    auto& ppe = static_cast< ProxyBcProgressEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(457):       auto& pssm = static_cast< ProxyBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(489):    auto& pssm = static_cast< ProxyBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(490):    auto ppsm = static_cast< ProxyBcPsm* >(Context::ContextPsm());
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(609):    auto pssm = static_cast< ProxyBcSsm* >(RootSsm());
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(767):          return static_cast< ProxyBcPsm* >(p);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(803):          ppsm = static_cast< ProxyBcPsm* >(psm);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(1029):    auto& tmsg = static_cast< const CipMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(1034):    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(744):    affecterIds_ = static_cast< CodeFileSet* >(asSet)->Set();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(2353):          auto base = static_cast< const Class* >(*b);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(2449):                auto type = static_cast< const Typedef* >(*item2);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(2472):          auto type = static_cast< const Typedef* >(*item1);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(2667):          auto& affecterIds = static_cast< CodeFileSet* >(affecterSet)->Set();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(62):    auto curr = static_cast< CodeFileSet* >(Users(true));
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(74):       curr = static_cast< CodeFileSet* >(prev->Users(true));
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(94):    auto curr = static_cast< CodeFileSet* >(UsedBy(true));
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(106):       curr = static_cast< CodeFileSet* >(prev->UsedBy(true));
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(352):    auto& dirSet = static_cast< const CodeDirSet* >(that)->Set();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(384):    auto abSet = static_cast< CodeFileSet* >(this->AffectedBy());
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(385):    auto asSet = static_cast< CodeFileSet* >(this->Affecters());
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(497):       currCount = static_cast< CodeFileSet* >(nbSet)->Set().size();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(529):       currCount = static_cast< CodeFileSet* >(nsSet)->Set().size();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(564):    auto order = static_cast< CodeFileSet* >(affects)->SortInBuildOrder();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeSet.cpp(49):    auto that = static_cast< CodeSet* >(rhs);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeSet.cpp(85):    auto that = static_cast< const CodeSet* >(rhs);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeSet.cpp(122):    auto that = static_cast< const CodeSet* >(rhs);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeSet.cpp(136):    auto that = static_cast< const CodeSet* >(rhs);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(194):       if((type == Cxx::Function) && (usingClass->GetTemplate() == this) &&
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(207):          auto args = static_cast< ClassInst* >(usingClass)->GetSpec()->Args();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1037):    auto area = static_cast< CxxArea* >(GetScope());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1040):    if(inst != nullptr) return static_cast< ClassInst* >(inst);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1057):          auto c = static_cast< Class* >(*s);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1828):       auto func = static_cast< const Function* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1854):       auto func = static_cast< const Function* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(766):       const { return static_cast< Namespace* >(GetScope()); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.cpp(831):       auto macro = static_cast< Macro* >(ref_);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.cpp(844):       auto macro = static_cast< Macro* >(ref_);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(1260):       auto thisClass = static_cast< Class* >(thisRoot);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(1268):             auto thatClass = static_cast< Class* >(thatRoot);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(1403):    if(AutoType_.SetAutoTypeOn(*static_cast< FuncData* >(item)))
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(1447):    auto ref = static_cast< CxxNamed* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(1571):          static_cast< Class* >(root)->BlockCopied(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(343):          space = static_cast< Namespace* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(358):          cls = static_cast< Class* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(403):          return static_cast< Enum* >(item)->FindEnumerator(name);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(411):             auto tdef = static_cast< Typedef* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(416):             item = static_cast< CxxScoped* >(root);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(427):             item = static_cast< CxxScoped* >(ref);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(705):    return static_cast< Class* >(root);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1000):          auto cls = static_cast< Class* >(ref);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1157):       auto cls = static_cast< Class* >(ref);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1990):          ref = static_cast< ClassInst* >(cls)->FindTemplateAnalog(ref);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2000):       ref = static_cast< Function* >(ref)->FindRootFunc();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1278):    auto cls = static_cast< Class* >(root);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1346):          auto op = static_cast< Operation* >(expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1651):       if(anon) StackArg::SetAutoTypeFor(static_cast< FuncData& >(*next_));
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1697):    auto data = static_cast< FuncData* >(next_.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(2477):       if(!static_cast< Function* >(item)->virtual_)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(2828):             static_cast< ClassData* >(data)->SetInit(m->get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3028):    return static_cast< Function* >((*cti)->FindInstanceAnalog(this));
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4330):       auto func = static_cast< ClassInst* >(cls)->FindTemplateAnalog(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4331):       if(func != nullptr) ++static_cast< Function* >(func)->calls_;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(64):          auto func = static_cast< Function* >(GetScope());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(256):    GetClass()->AddSubclass(static_cast< Class* >(Context::Scope()));
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(292):    return static_cast< Class* >(name_->GetReferent());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1357):          auto tf = (*t)->FindFriend(static_cast< const CxxScope* >(ref));
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1499):          space = static_cast< Namespace* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1511):          cls = static_cast< Class* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1549):             auto tdef = static_cast< Typedef* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1554):             item = static_cast< CxxScoped* >(root);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1827):       static_cast< CxxArea* >(scope)->AddFunc(func);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(368):    return static_cast< Macro* >(macros.front());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(407):       if((*s)->ScopedName(false) == name) return static_cast< CxxScope* >(*s);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(415):       if((*c)->ScopedName(false) == name) return static_cast< CxxScope* >(*c);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(423):       if(pos != string::npos) return static_cast< CxxScope* >(*s);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(429):       if(pos != string::npos) return static_cast< CxxScope* >(*c);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(393):    auto oper = static_cast< Operation* >(item.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(419):          auto ante = static_cast< Operation* >(prev.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(471):       auto oper = static_cast< Operation* >(item.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(504):    auto oper = static_cast< Operation* >(prev.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(533):       auto oper = static_cast< Operation* >(item.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(575):    auto oper = static_cast< Operation* >(item.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(598):       auto ante = static_cast< Operation* >(prev.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(702):    Context::PushOp(static_cast< Operation* >(StartOfExpr.get()));
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1066):       inClass = static_cast< Class* >(inRoot);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1071):       outClass = static_cast< Class* >(outRoot);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1096):    auto call = static_cast< Operation* >(args_.front().get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1483):       func = static_cast< Function* >(proc.item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1501):       cls = static_cast< Class* >(proc.item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1596):    auto dtor = static_cast< Class* >
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1645):       auto newCall = static_cast< Operation* >(args_.front().get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1665):    auto cls = static_cast< Class* >(spec.item->Root());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1686):       auto ctorCall = static_cast< Operation* >(args_[2].get());
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1710):       cls = static_cast< Class* >(root);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1894):       area = static_cast< Class* >(targ);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(1896):       static_cast< Class* >(targ)->Instantiate();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(2231):    auto cls = static_cast< Class* >(root);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(2270):       static_cast< QualName* >(arg2.item)->MemberAccessed(cls, mem);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(2293):          mem = static_cast< Function* >(mem)->InstantiateFunction(tmplt);
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(1498):          auto def = static_cast< Define* >(item);
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(1502):             auto code = const_cast< string* >(source_);
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.cpp(77):    sourcePathCfg_.reset
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(239):    auto op = static_cast< Operation* >(call.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(488):    auto brace = static_cast< BraceInit* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(562):    auto cast = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(601):    auto c = static_cast< Catch* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(698):    static_cast< ClassData* >(data.get())->SetMutable(mute);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(699):    static_cast< ClassData* >(data.get())->SetWidth(width);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(858):    auto cond = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1132):    auto cast = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1238):    auto op = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1261):    auto delOp = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1289):    auto d = static_cast< Do* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1483):    auto f = static_cast< For* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1583):       static_cast< FuncData* >(data.get())->SetExpression(expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1632):          curr = static_cast< FuncData* >(data.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1638):          curr = static_cast< FuncData* >(subseq.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1891):             static_cast< If* >(first)->SetElseIf();
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(1897):    auto i = static_cast< If* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2026):    auto inner = static_cast< Namespace* >(outer)->EnsureNamespace(name);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2068):    auto newOp = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2558):    static_cast< Return* >(statement.get())->AddExpr(expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2605):    auto op = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2752):    auto op = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2778):    auto s = static_cast< Switch* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2860):    auto op = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2896):    auto t = static_cast< Try* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(2954):    auto op = static_cast< Operation* >(token.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(3158):    auto w = static_cast< While* >(statement.get());
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(3536):          auto op = static_cast< Operation* >(token)->Op();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.cpp(238):    if(root->Sid() != TestServiceId) return static_cast< MediaSsm* >(root);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.cpp(79):       auto mpsm = static_cast< MediaPsm* >(psm);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.cpp(103):       auto mpsm = static_cast< MediaPsm* >(psm);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.cpp(64):    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.cpp(144):    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
  C:/Users/gregu/Documents/tsf/tsf/nb/CoutThread.cpp(69):       auto req = static_cast< StreamRequest* >(msg);
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.cpp(202):       auto req = static_cast< FileRequest* >(msg);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(76):       auto curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(110):       auto curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(174):                   auto last = static_cast< const FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(246):       auto curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(285):          curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(353):       curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(406):          auto curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp(471):          auto curr = static_cast< FunctionTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/LogThread.cpp(74):       auto req = static_cast< StreamRequest* >(msg);
  C:/Users/gregu/Documents/tsf/tsf/nb/MemoryTrace.cpp(51):       auto curr = static_cast< MemoryTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.cpp(46):    statsFileName_.reset
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.cpp(183):             auto ft = static_cast<FunctionTrace*>(rec);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtTestData.cpp(51):    return static_cast< NtTestData* >(data);
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.cpp(141):    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.cpp(160):    auto svc = static_cast< TcpIpService* >(ipPort_->GetService());
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.cpp(251):    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.cpp(397):    auto sock = static_cast< SysTcpSocket* >(socket);
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIpPort.cpp(90):    auto svc = static_cast< TcpIpService* >(GetService());
  C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.cpp(91):    auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
  C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.cpp(225):       auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsIncrement.cpp(426):       auto mep = static_cast< MediaEndpt* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(578):    auto&            pmsg = static_cast< PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(639):    auto&             pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(746):    auto&          pmsg = static_cast< PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(772):    auto&           pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(866):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(954):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(748):                inv = static_cast< InvokerThread* >(Thread::RunningThread());
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(866):          auto pptr = static_cast< TlvMessage* >
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(166):    cfgInvokers_.reset(static_cast< CfgIntParm* >(reg->FindParm(parmKey)));
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(518):       auto inv = static_cast< InvokerThread* >(Thread::RunningThread());
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgContext.cpp(67):    static_cast< MsgFactory* >(fac)->ProcessIcMsg(msg);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(65):    locAddr_.sbAddr_.fid = static_cast< ProtocolSM& >(upper).GetFactory();
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(139):    return static_cast< PsmFactory* >(fac)->AllocIcPsm(msg, *this);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(205):    auto port = static_cast< MsgPort* >(pool->BidToObj(locAddr.bid));
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(262):       static_cast< PsmFactory* >(fac)->PortAllocated(*this, msg);
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.cpp(419):       auto psm = static_cast< ProtocolSM* >(layer);
  C:/Users/gregu/Documents/tsf/tsf/sb/RootServiceSM.cpp(33):    ctx_ = static_cast< SsmContext* >(Context::RunningContext());
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.cpp(33):    auto pid = ssm.CalcPort(static_cast< const AnalyzeMsgEvent& >(currEvent));
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.cpp(109):    auto& fte = static_cast< ForceTransitionEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.cpp(123):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(804):       auto msg = static_cast< Message* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(891):       auto port = static_cast< MsgPort* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(1103):       auto psm = static_cast< ProtocolSM* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(1335):       auto ssm = static_cast< ServiceSM* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp(1548):       auto tmr = static_cast< Timer* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInputHandler.cpp(93):    auto sbbuff = SbIpBufferPtr(static_cast< SbIpBuffer* >(buff.release()));
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.cpp(43):    noIngressQueueLength_.reset
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.cpp(55):    noIngressMessageCount_.reset
  C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.cpp(208):       auto port = static_cast< MsgPort* >(obj);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.cpp(269):    auto psm = static_cast< ProtocolSM* >(NextUsed(psmToAudit_));
  C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.cpp(286):       psm = static_cast< ProtocolSM* >(NextUsed(psmToAudit_));
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(340):          bt = static_cast< BuffTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(842):       curr_ = static_cast< const AnalyzeSapEvent& >(sxp).CurrEvent()->Eid();
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(844):       curr_ = static_cast< const AnalyzeSnpEvent& >(sxp).CurrEvent()->Eid();
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(873):    mod_((static_cast< const InitiationReqEvent& >(sip)).GetModifier())
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(442):             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(446):          modifierSsm = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrSsm();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(447):          icEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(497):             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(503):          icEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(504):          modifierInit = static_cast< AnalyzeSapEvent* >
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(756):             else if(((AnalyzeSapEvent*) ogEvent)->CurrInitiator() != nullptr)
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(758):             else if(((AnalyzeSapEvent*) ogEvent)->CurrSsm() != nullptr)
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(862):          initEvent = static_cast< InitiationReqEvent* >(nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(866):             initEvent->SetSapEvent(static_cast< AnalyzeSapEvent& >(sapEvent));
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(928):             auto sibling = static_cast< InitiationReqEvent* >
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(969):    auto& initEvent = static_cast< InitiationReqEvent& >(icEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmContext.cpp(82):    return static_cast< SsmFactory* >(fac)->AllocRoot(msg, psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.cpp(58):    auto& tmsg = static_cast< const TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(45):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(48):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(85):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(101):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(103):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(123):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(138):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(139):    auto& ode = static_cast< BcOriginationDeniedEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(154):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(156):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(162):          auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(183):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(210):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(240):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(257):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(281):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(296):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(310):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(325):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(340):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(342):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(361):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(382):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(397):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(413):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(430):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(431):    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(448):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(462):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(464):    auto cmsg = static_cast< CipMessage* >(npsm->FirstRcvdMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(494):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(509):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(510):    auto& tde = static_cast< BcTerminationDeniedEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(525):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(526):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(547):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(566):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(581):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(583):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(608):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(637):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(652):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(668):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(684):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(686):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(707):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(722):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(738):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(740):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(757):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(783):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(802):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(817):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(836):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(851):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(867):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(869):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(878):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(905):    auto& ate = static_cast< BcApplyTreatmentEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(906):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(944):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(960):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(976):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(977):    auto& lre = static_cast< BcLocalReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(992):    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(993):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(1027):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp(1048):    auto& rue = static_cast< ProxyBcReleaseUserEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp(58):          auto& ppsm = static_cast< PotsCallPsm& >(psm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp(63):          auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp(71):       SetNPsm(static_cast< CipPsm& >(psm));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp(75):       SetUPsm(static_cast< MediaPsm& >(psm));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp(115):    auto pmsg = static_cast< PotsMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBicService.cpp(67):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBocService.cpp(67):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp(99):    auto& pmsg = static_cast< const Pots_UN_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp(180):       auto pmsg = static_cast< const PotsMessage* >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp(182):       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp(186):       auto ppsm = static_cast < const PotsCallPsm* >(port.Upper());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp(187):       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(ppsm->TsPort()));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp(250):    auto& icmsg = static_cast< const PotsMessage& >(msg1);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallHandler.cpp(79):    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallHandler.cpp(100):    auto prof = static_cast< PotsCircuit* >(cct)->Profile();
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallPsm.cpp(90):       return static_cast< PotsCallPsm* >(psm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallPsm.cpp(162):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallPsm.cpp(197):    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.cpp(188):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.cpp(248):       auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.cpp(271):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.cpp(287):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfbService.cpp(41):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfbService.cpp(43):    auto cfbp = static_cast< PotsCfbFeatureProfile* >(prof->FindFeature(CFB));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfnService.cpp(41):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfnService.cpp(43):    auto cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfuService.cpp(41):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfuService.cpp(43):    auto cfup = static_cast< PotsCfuFeatureProfile* >(prof->FindFeature(CFU));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(277):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(282):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(284):       auto& cssm = static_cast< PotsCfxSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(305):    auto& cssm = static_cast< PotsCfxSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(306):    auto& pssm = static_cast< PotsBcSsm& >(*cssm.Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(358):       auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(385):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(467):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(469):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(482):          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(504):          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(518):       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(524):       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFB));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(530):       cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(564):    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(567):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(622):       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(629):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(644):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(652):       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp(670):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(433):    PotsMuxSsm* Mux() const { return static_cast< PotsMuxSsm* >(Parent()); }
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1152):    auto hldNPsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1189):          auto bcUPsm = static_cast< PotsCallPsm* >(psm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1259):    auto msg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1286):    auto npsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1300):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1366):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1410):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1959):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1960):    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(1990):    auto& mux = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2005):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2007):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2014):          auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2111):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2113):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2114):    auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2115):    auto npsm = static_cast< PotsMuxPsm* >(pmsg->Psm());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2210):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2224):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2238):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2252):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2268):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2283):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2297):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2312):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2327):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2328):    auto& are = static_cast< PotsCwmActiveReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2343):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2344):    auto& ire = static_cast< PotsCwmInactiveReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2358):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(2380):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(275):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(602):    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(607):       auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(608):       auto ate = static_cast< BcApplyTreatmentEvent* >(sap.CurrEvent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(625):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(633):       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(671):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(701):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(796):    auto& init = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(798):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(893):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(915):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(946):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(948):    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(954):          auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(978):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1003):    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1004):    auto& pssm = static_cast< PotsBcSsm& >(*ssm.Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1024):    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1025):    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1029):       auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1048):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1050):    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1054):       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1094):    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1095):    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1097):    auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(1142):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsDiscService.cpp(118):    auto& pssm = static_cast< BcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsDiscService.cpp(120):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.cpp(68):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.cpp(158):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.cpp(164):       auto htlp = static_cast< PotsHtlFeatureProfile* >(prof->FindFeature(HTL));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(181):    auto& pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(232):    auto& pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(235):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(347):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(400):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(733):    auto& npsm = static_cast< PotsMuxPsm& >(psm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(736):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(809):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(877):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(984):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(985):    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(1007):    auto& mux = static_cast< PotsMuxSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(1038):    auto& mux = static_cast< PotsMuxSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(1039):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp(1062):    auto& mux = static_cast< PotsMuxSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(39):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(40):    auto msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(42):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(75):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(92):    auto msg = static_cast< CipMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(94):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(118):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(119):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(121):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(158):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(168):    auto upsm = static_cast< ProxyBcPsm* >(pssm.UPsm());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(192):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(210):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(229):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(230):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(232):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(279):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(297):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(298):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(300):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(342):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(343):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(345):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(395):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(413):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(431):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(449):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(467):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(500):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(501):    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(531):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(550):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(551):    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(581):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(601):    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(602):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSusService.cpp(66):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.cpp(240):    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.cpp(284):    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.cpp(314):    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(176):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(178):    auto wmlp = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(421):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(448):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(450):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(455):    wmlp_ = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(527):    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(530):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(590):       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(610):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(647):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(652):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(654):       auto& wssm = static_cast< PotsWmlSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(675):    auto& wssm = static_cast< PotsWmlSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp(676):    auto& pssm = static_cast< PotsBcSsm& >(*wssm.Parent());
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(136):          tt = static_cast< const TransTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(144):          auto mt = static_cast< const MsgTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(697):    auto rxnet = static_cast< const TransTrace* >(events_[index]);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(714):             trans = static_cast< const TransTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(726):             return static_cast< const MsgTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(743):    auto txmsg = static_cast< const MsgTrace* >(events_[index]);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(764):             trans = static_cast< const TransTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(771):             auto rxmsg = static_cast< const MsgTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(932):          tt = static_cast< const TransTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp(968):             mt = static_cast< const MsgTrace* >(rec);
  C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.cpp(124):    auto ctx = static_cast< Context* >(pool->FirstUsed(bid));
  C:/Users/gregu/Documents/tsf/tsf/st/StTestData.cpp(54):    return static_cast< StTestData* >(data);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(494):    auto tpsm = static_cast< TestPsm* >(Psm());
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(511):    auto tssm = static_cast< TestSsm* >(RootSsm());
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(565):       if(p->GetFactory() == TestFactoryId) return static_cast< TestPsm* >(p);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(843):       SetTestPsm(static_cast< TestPsm* >(&psm));
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(971):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(972):    auto tmsg = static_cast< TestMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(1010):    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(1019):    auto apsm = static_cast< SsmFactory* >(afac)->AllocOgPsm(*amsg);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(1030):    auto& tssm = static_cast< TestSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(1048):    auto& tssm = static_cast< TestSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(1067):    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(1068):    auto& tssm = static_cast< TestSsm& >(ssm);
W010 Cast removes const qualification
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(486):    LibrarySet* nbSet = (LibrarySet*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(518):    LibrarySet* nsSet = (LibrarySet*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1361):    return const_cast< Class* >(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1824):       return const_cast< ClassInst* >(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(128):       override { return const_cast< CxxArea* >(this); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(414):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(451):       override { return const_cast< Class* >(this); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(804):       override { return const_cast< Namespace* >(this); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(927):    return const_cast< DataSpec* >(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1335):    const_cast< DataSpec* >(this)->FindReferent();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2570):    return const_cast< TypeName* >(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(517):       override { return const_cast< QualName* >(this); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(1010):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(2119):    return FoundFunc(const_cast< Function* >(this), args, match);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(2992):    auto prev = const_cast< Function* >(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3385):    func->SetTemplate(const_cast< Function* >(this));
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(331):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1084):       const override { return const_cast< Function* >(this); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1194):    return (CxxToken*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1369):    return (CxxToken*) this;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1737):    const_cast< Friend* >(this)->FindReferent();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(146):    virtual CxxNamed* Referent() const override { return (CxxNamed*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(451):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(541):    virtual CxxToken* AutoType() const override { return (CxxNamed*) enum_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(942):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(1018):    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(282):    CxxToken* prev = const_cast< CxxToken* >(this);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(274):    virtual CxxToken* RootType() const { return const_cast< CxxToken* >(this); }
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(1502):             auto code = const_cast< string* >(source_);
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(18):    return (void*) ((ptr_t) ptr2 - diff);
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(25):    return (void*) ((ptr_t) ptr1 + diff);
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(62):    return ((ptr_t) ptr1 - (ptr_t) ptr2);
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.cpp(83):       objects[count++] = const_cast< Base* >(this);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(827):    auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(122):    return CreateThread(
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(341):    return const_cast< MsgPort* >(this);
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.cpp(683):    if(upper == nullptr) return const_cast< ProtocolSM* >(this);
W011 Pointer arithmetic
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp(18):    return (void*) ((ptr_t) ptr2 - diff);
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.cpp(190):       source += rcvd;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.cpp(246):    bytes += hdrSize_;
W015 #include not sorted in standard order
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(13): #include <dbghelp.h>
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(10): #include <windows.h>
  C:/Users/gregu/Documents/tsf/tsf/tsf/main.cpp(79): #include "AnModule.h"
W017 Using statement in header
  C:/Users/gregu/Documents/tsf/tsf/an/AnIncrement.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/an/AnModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelf.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelf.h(20): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelf.h(21): using namespace MediaBase;
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.h(20): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(20): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcCause.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcCause.h(17): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProgress.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProgress.h(17): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(34): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(35): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(36): using namespace MediaBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcRouting.h(16): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(38): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(39): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(40): using namespace MediaBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/CbModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(20): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/cb/ServiceCodeRegistry.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/cn/CnModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(31): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeIncrement.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CtModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(18): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(18): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxRoot.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(20): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(24): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(23): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.h(23): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(29): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibraryErrSet.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibraryItem.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibraryTypes.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(20): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.h(18): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MbModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MbPools.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(20): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaFailureEvent.h(18): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaFailureEvent.h(19): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.h(17): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(22): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(23): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/Switch.h(22): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/ToneRegistry.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/mb/Tones.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h(23): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionStats.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(18): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/nt/NtModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/nt/NtTestData.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/on/OnModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PbModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsBicFeature.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsBocFeature.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfbFeature.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfbFeature.h(16): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfnFeature.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfnFeature.h(17): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfuFeature.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfuFeature.h(16): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(25): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(26): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(27): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCliParms.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCwtFeature.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCxfFeature.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(23): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureRegistry.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatures.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatures.h(15): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsHtlFeature.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsHtlFeature.h(16): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsIncrement.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsIncrement.h(15): using namespace SessionTools;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.h(25): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.h(26): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.h(27): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfileRegistry.h(20): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfileRegistry.h(21): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(30): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(31): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(32): using namespace MediaBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(33): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsSusFeature.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsTwcFeature.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsWmlFeature.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsWmlFeature.h(17): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/rn/RnModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(28): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h(25): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(30): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/FactoryRegistry.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(29): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPoolRegistry.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.h(25): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/LocalAddress.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(30): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgContext.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(25): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(25): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolRegistry.h(20): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(22): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/PsmContext.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/RootServiceSM.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbCliParms.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbExtInputHandler.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInputHandler.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIpBuffer.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.h(20): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(22): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTracer.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTypes.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(20): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceRegistry.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(23): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmContext.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/State.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Timer.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerProtocol.h(18): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerRegistry.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerThread.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvIntParameter.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(22): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sb/Trigger.h(21): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.h(14): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBicService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBicService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBocService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBocService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.h(14): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfbService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfbService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfnService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfnService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfuService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfuService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.h(27): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.h(28): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.h(29): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.h(16): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(30): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(31): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(32): using namespace MediaBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(33): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.h(14): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxySessions.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxySessions.h(14): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(29): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(30): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(31): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsStatistics.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsStatistics.h(16): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSusService.h(15): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSusService.h(16): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.h(16): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.h(17): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(30): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(31): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(32): using namespace MediaBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(33): using namespace CallBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.h(15): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/SnIncrement.h(12): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/sn/SnModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.h(26): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.h(27): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.h(39): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.h(40): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscContext.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscContext.h(18): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/st/MscContextPair.h(19): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.h(14): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.h(15): using namespace NodeTools;
  C:/Users/gregu/Documents/tsf/tsf/st/StModule.h(13): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/StTestData.h(17): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/StTestData.h(18): using namespace SessionBase;
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h(28): using namespace NodeBase;
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h(29): using namespace SessionBase;
W019 Unused argument
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(66/1):    word AddForward(string& item, string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(67/1):    word RemoveForward(string& item, string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(68/1):    word RemoveUsing(string& item, string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(73/1):    word GetEpilog(string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(566/1):    static void Shutdown(RestartLevel level);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(570/1):    static void Startup(RestartLevel level) { }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(94/1):    virtual void ProcessIcMsg(Message& msg);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(36/2): void SE_Handler(uint32_t errval, void* ex)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.h(23/1):    void Startup(RestartLevel level);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(339/2):       (BlockingReason why, fn_name_arg func) { return true; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(347/1):    virtual void ScheduledIn(fn_name_arg func) { }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(72/1):       (PotsProfile& profile, CliThread& cli) const = 0;  //d
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(40/1):    virtual bool Deactivate(PotsProfile& profile);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(74/1):    virtual bool Unsubscribe(PotsProfile& profile);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(107/1):    static void Kill(fn_name_arg func, debug64_t errval, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(112/1):    virtual Message* AllocOgMsg(SignalId sid) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(158/1):    virtual ProtocolLayer* AllocLower(const Message* msg);
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(287/1):    virtual void MsgHandled(Message& msg) { }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(293/1):    virtual void RestoreIcMsg(Message& msg) { }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(299/1):    virtual void RefreshMsg(Message& msg) { }
  C:/Users/gregu/Documents/tsf/tsf/sb/RootServiceSM.h(37/1):    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(66/2):    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(174/2):       (Event& currEvent, Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(174/1):       (Event& currEvent, Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmFactory.h(32/1):    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.h(46/1):    explicit PotsCfxSsm(ServiceId sid);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(420/2):    EventHandler::Rc ReleaseInactive(Cause::Ind cause, Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(144/1):    PotsMuxSsm(const Message& msg, ProtocolSM& psm);
W020 Unused class
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(281): class CipUdpService : public UdpIpService
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(177): class ProxyBcDisconnecting : public BcDisconnecting
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaFailureEvent.h(27): class MediaFailureEvent : public Event
  C:/Users/gregu/Documents/tsf/tsf/nb/PooledClass.h(24): class PooledClass : public Class
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(39):    class SigAlrm : public PosixSignal
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(53):    class SigBus : public PosixSignal
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(81):    class SigQuit : public PosixSignal
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(95):    class SigSys : public PosixSignal
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(109):    class SigVtAlrm : public PosixSignal
W021 Unused data
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(48):    static const ServicePortId NextPortId = FirstPortId + 1;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(204):    static const Id NextId        = FirstId + 4;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(288):    static const Id NextId              = FirstId + 7;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(373):    static const Id NextId          = FirstId + 3;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1058): const string SingleRule(COMMENT_STR + string(78, '-'));
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.h(502): extern const Flags NoLF_Mask;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.h(503): extern const Flags Last_Mask;
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(138):    static const id_t LastNbIndex     = 3;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(67):    static const Bid MaxBid = MaxSegments << ObjectsPerSegmentLog2;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h(35): constexpr uword UWORD_MAX = (sizeof(word) == 8 ? UINT64_MAX : UINT32_MAX);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(66):    static const id_t LastNtIndex    = FuncTraceScope;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(90):    static const Id LastId    = NextId + 9;  // range constant
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(118):    static const Id LastId   = NextId + 7;  // range constant
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(210):    static const Ind MaxInd         = UINT8_MAX;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.h(129):    static const PooledObjectId MaxId = 0x40000;  // 2^18 = 256K
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.h(42):    static const id_t LastSbIndex    = LastNwIndex + 9;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.h(71):    static const id_t LastSbIndex   = LastNwIndex + 6;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.h(100):    static const id_t LastSbIndex   = LastNwIndex + 5;
W022 Unused enum
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(72):    enum Location
W023 Unused enumerator
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(137):       Multiple   // two statements or more
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(29):    DispOption_N  // number of reasons; can be used to extend this enum
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(59):    IdleFaction,         // idle thread (not used)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(43):       LowPriority,       // preemptable threads
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h(132):    DebugLog,    // only useful to software designers
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(74):       NotQueued,     // being built by a factory
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(75):       ContextQ,      // has arrived at a context
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(76):       PsmIncomingQ,  // has arrived at a PSM
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(77):       PsmOutgoingQ,  // has been sent by a PSM
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(78):       PsmPendingQ    // being built by a PSM
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(88):       IllegalSignal,   // illegal signal found              0000  sid
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(89):       IllegalParm,     // illegal parameter found          index  pid
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(90):       IncompleteParm,  // parameter too short              index  pid
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(91):       MissingParm,     // mandatory parameter missing       0000  pid
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(92):       Overflow,        // last parameter extends past end  index  pid
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(93):       Trampled         // last parameter trampled fence    index  pid
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(100):       StreamContainsIllegalParm,
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(82):       SignalUnknown,     // signal not recognized
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(84):       ParameterUnknown,  // parameter not recognized
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(85):       ParameterInvalid,  // parameter not valid for this signal
W026 Unused function
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelf.h(51):    virtual CliText* CreateText() const override;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(199):    Digit GetDigit(DigitCount i) const;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(165):    MediaInfo* AddMedia(const MediaInfo& media);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(232):    virtual void InjectFinalMsg() override;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(303):    virtual CliText* CreateText() const override;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(356):    virtual CliText* CreateText() const override;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(180):    explicit ProxyBcDisconnecting(ServiceId sid);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(419):    bool operator!=(const WarningLog& that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.h(408):    Numeric(NumericType type, size_t width, bool sign)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(111):    size_t Arrays() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(246):    bool operator!=(const StackArg& that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.h(44):    std::string& Prefix(std::string&& scope);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(172):    size_t GetCurr() const { return lexer_.Curr(); }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(43):    StateId GetState() const { return state_; }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(47):    virtual void SetState(StateId stid);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(57):    ProtocolSM* MgwPsm() const;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(63):    virtual void Deallocate();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(72):    static void* operator new(size_t size);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(77):    explicit MediaEndpt(MediaPsm& psm);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaFailureEvent.h(33):    MediaFailureEvent(ServiceSM& owner, MediaEndpt& mep);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaFailureEvent.h(41):    MediaEndpt* Mep() const { return mep_; }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(105):    MediaEndpt* Mep() const { return mep_; }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.h(33):    virtual bool SetMgwPsm(ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/mb/Tones.h(50):    Id Tid() const { return Id(tid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h(42):    word GetCurrValue() const { return *curr_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParmRegistry.h(75):    const std::vector< stringPtr >& GetMainArgs() const { return *mainArgs_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(42):    virtual void Initialize();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(47):    virtual Object* Create();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(55):    virtual void FreeQuasiSingleton(Object* obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(104):    bool SetVptr(Object& obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(111):    bool SetTemplate(Object& obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(118):    bool SetQuasiSingleton(Object& obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(152):    bool GetCharParm(char& c, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h(98):    word Result() const { return result_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Clock.h(57):    ticks_t TicksPerSec();
  C:/Users/gregu/Documents/tsf/tsf/nb/Clock.h(106):    ticks_t UsecsToTicks(usecs_t usecs);
  C:/Users/gregu/Documents/tsf/tsf/nb/Clock.h(110):    const SysTime& TimeZero();
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(81):    static void noop();
  C:/Users/gregu/Documents/tsf/tsf/nb/Dynamic.h(41):    static void* operator new[](size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/Exception.h(45):    Exception(const Exception& that);
  C:/Users/gregu/Documents/tsf/tsf/nb/Exception.h(46):    Exception(Exception&& that);
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.cpp(39):    FileRequest(const FileRequest& that);
  C:/Users/gregu/Documents/tsf/tsf/nb/Formatters.h(51):    std::string strHex(uint16_t n, int width = -1, bool prefix = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionName.h(24):    size_t find(fn_name_arg func, const char* str);
  C:/Users/gregu/Documents/tsf/tsf/nb/Immutable.h(40):    static void* operator new[](size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(41):    static void Set(void* dest, byte_t value, size_t nBytes);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(64):    static bool Verify(MemoryType type, void* addr);
  C:/Users/gregu/Documents/tsf/tsf/nb/Module.h(88):    ModuleId Mid() const { return mid_.GetId(); }
  C:/Users/gregu/Documents/tsf/tsf/nb/Module.h(96):    virtual ModuleId* Dependencies(size_t& count) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(80):    ClassId GetClassId() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(92):    ObjectId GetObjectId() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(98):    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(106):    static void* operator new(size_t size, MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(107):    static void* operator new[](size_t size, MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(109):    static void operator delete[](void* addr);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(110):    static void operator delete(void* addr, MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(111):    static void operator delete[](void* addr, MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(120):    void MorphTo(Class& target);
  C:/Users/gregu/Documents/tsf/tsf/nb/Permanent.h(42):    static void* operator new[](size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/PooledClass.h(38):    PooledClass(ClassId cid, size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/PooledClass.h(54):    bool SetPool(ObjectPool& pool);
  C:/Users/gregu/Documents/tsf/tsf/nb/Protected.h(41):    static void* operator new[](size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Link.h(42):    bool IsQueued() const { return next != nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Link.h(42):    bool IsQueued() const { return next != nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.h(86):    static void* operator new[](size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.h(91):    static void operator delete[](void* addr);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.h(56):    bool TickTimingAvailable() const { return available_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h(61):    int16_t Get(TimeField field) const { return time_[field]; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Temporary.h(40):    static void* operator new[](size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(107):    static std::atomic_uint32_t* Vector();
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(155):    bool ChangeFaction(Faction faction);
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.h(154):    const SysTime& StartTimeFull() const { return startTime_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(81):    static void operator delete(void* addr, void* where) { }
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(62):    virtual CliText* CreateText() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpServiceRegistry.h(33):    IpService* GetService(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(95):    bool operator!=(const SysIpL3Addr& that) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.h(114):    bool LocAddr(SysIpL3Addr& locAddr);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(77):    bool IsRinging() const { return ringing_; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(81):    bool CanFlash() const { return flash_; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(86):    Cause::Ind GetCause() const { return cause_; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(277):    MediaInfo* AddMedia(const MediaInfo& media);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(431):    virtual void InjectFinalMsg() override;
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(102):    virtual void NextPort(MsgPort*& port) const { port = nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(112):    static void Dump(fn_name_arg func, debug64_t errval, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(257):    size_t MsgCount(bool priority, bool standard) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(204):    void SetFaction(Faction faction) { faction_ = faction; }
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.h(38):    GlobalAddress(const SysIpL3Addr& l3Addr, FactoryId fid);
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.h(66):    bool operator!=(const GlobalAddress& that) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/LocalAddress.h(38):    bool operator!=(const LocalAddress& that) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(181):    Message* FindSignal(SignalId sid) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(68):    ProtocolId Prid() const { return prid_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(65):    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(59):    bool IsLowermost() const { return lower_ == nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(123):    Message* FirstSentMsg() const { return sentMsgq_.First(); }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(181):    virtual bool DropPeer(const GlobalAddress& peerPrevRemAddr) override;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(311):    virtual void InjectFinalMsg();
  C:/Users/gregu/Documents/tsf/tsf/sb/PsmContext.h(71):    virtual void NextPort(MsgPort*& port) const override { portq_.Next(port); }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(78):    StateId CurrState() const { return currState_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(91):    Message* SavedMsg() const { return savedMsg_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(200):    StateId CurrState() const { return currState_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(204):    StateId NextState() const { return nextState_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(345):    bool IsInitiation() const { return initiation_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h(356):    Message* GetMessage() const { return message_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/SbIpBuffer.h(70):    static void operator delete(void* addr, SbPoolUser user);
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(110):    bool Disable();
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(114):    bool Enable();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(119):    bool HasTriggered(TriggerId tid) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(64):    ProtocolId Prid() const { return prid_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/State.h(43):    ServiceId Sid() const { return sid_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(45):    explicit TextTlvMessage(SbIpBufferPtr& text);
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(49):    TextTlvMessage(ProtocolSM* psm, MsgSize size);
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(55):    bool Receive();
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(49):    TlvMessage(const TlvParmLayout& parm, ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(54):    TlvMessage(const Message& msg, ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(63):    virtual TlvParmPtr Wrap(const TlvMessage& msg, ParameterId pid);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(154):    size_t AllParms(TlvParmArray ptab, size_t size) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(160):    size_t FindParms(ParameterId pid, TlvParmArray ptab, size_t size) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(174):    TlvParmPtr AddBytes(const byte_t* src, MsgSize size, ParameterId pid);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(180):    TlvParmPtr CopyParm(const TlvParmLayout& src, ParameterId pid = NIL_ID);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(184):    virtual TlvParmPtr ExpandParm(TlvParmLayout& parm, MsgSize plen);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(236):    byte_t* FindBytes(MsgSize& size, ParameterId pid) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(243):    virtual bool MatchParm(TlvParmPtr pptr, ParmIterator& pit, bool& last) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(258):    int ParmOffset(ParmIterator& pit) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.h(57):    static Id ExtractPid(const TlvParmLayout& parm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvProtocol.h(24):    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const override;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(63):    PotsMuxPsm(ProtocolLayer& adj, bool upper, Switch::PortId port);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(61):    virtual CliText* CreateText() const override;
  C:/Users/gregu/Documents/tsf/tsf/tsf/main.cpp(116): main_t main(int argc, char* argv[])
W027 Unused typedef
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(160): typedef std::basic_string<char, CharTraits, ImmAllocator<char>>  ImmString;
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(161): typedef std::basic_string<char, CharTraits, PermAllocator<char>> PermString;
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(162): typedef std::basic_string<char, CharTraits, ProtAllocator<char>> ProtString;
W030 No referent for friend declaration
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(41):       friend class Singleton< SigAlrm >;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(55):       friend class Singleton< SigBus >;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(83):       friend class Singleton< SigQuit >;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(97):       friend class Singleton< SigSys >;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(111):       friend class Singleton< SigVtAlrm >;
W032 Member hides inherited name
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(301):    static const Id NextId = FirstId + 50;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(868):    static const Id NextId                 = FirstUn + 7;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(48):    static const ServicePortId NextPortId = FirstPortId + 1;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(198):    static const Id FirstId = BcEvent::NextId;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(204):    static const Id NextId        = FirstId + 4;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(288):    static const Id NextId              = FirstId + 7;
  C:/Users/gregu/Documents/tsf/tsf/mb/Tones.h(54):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(152):    static ptrdiff_t LinkDiff();
  C:/Users/gregu/Documents/tsf/tsf/sb/Timer.h(39):    static ptrdiff_t LinkDiff();
W033 Class could be namespace
  C:/Users/gregu/Documents/tsf/tsf/nb/Log.h(19): class Log
W036 Member could be private
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(131):    typedef uint8_t DigitCount;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(161):    static bool IsValidDigit(Digit d)
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(168):    Rc AddDigit(Digit d);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(187):    DigitCount Size() const;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(211):    bool operator==(const DigitString& that) const;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(219):    virtual void EnsureMediaMsg() override;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(223):    virtual IncomingRc ProcessIcMsg(Message& msg, Event*& event) override;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(404):    virtual Message* AllocIcMsg(SbIpBufferPtr& buff) const override;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1000):    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1001):    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1002):    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1048):    virtual EventHandler::Rc RequestService(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1137):    CipPsm* AllocNPsm();
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(480):    ProxyBcPsm* FirstBroadcast() const;
  C:/Users/gregu/Documents/tsf/tsf/cb/ServiceCodeRegistry.h(30):    void SetService(Address::SC sc, ServiceId sid);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(97):    bool IsTemplateHeader() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(102):    Typedef* FindType(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(144):    Enum* FindEnum(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(148):    Enumerator* FindEnumerator(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(334):    Function* FindFuncByRole(FunctionRole role, bool base) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(338):    FunctionDefinition GetFuncDefinition(const Function* func) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(765):    Namespace* OuterSpace()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(771):    Namespace* FindNamespace(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(227):    virtual CxxToken* GetValue() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(267):    virtual CxxToken* RootType() const override { return GetValue(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(245):    bool operator==(const StackArg& that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(527):    static size_t GetPos() { return Frame_->GetPos(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(452):    TypeName* Names_back() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(962):    size_t MinArgs() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(967):    size_t MaxArgs() const { return args_.size(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1029):    bool IsInvokedInBase() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.h(97):    std::string NextOperator() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.h(214):    bool ThisCharIs(char c);
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(54):    CodeDir* FindDir(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(75):    LibrarySet* FindVar(const std::string& name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(46):    bool IsReadOnly() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(147):    static ptrdiff_t LinkDiff();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(89):    virtual void EndOfTransaction();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.h(38):    bool operator==(const MediaInfo& that) const;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(117):    Tone::Id GetOgTone() const { return ogTone_; }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(155):    void SetOgPort(Switch::PortId ogport);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(174):    virtual Event* ReceiveMsg(Message& msg) override;
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(178):    virtual void PrepareOgMsgq() override;
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(94):    virtual void Claim() { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(137):    virtual MemoryType MemType() const { return MemPerm; }
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.h(51):    virtual bool SetNext(const std::string& input) override;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBoolParm.h(52):    virtual bool SetNextValue(bool value) override;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgFlagParm.h(50):    virtual bool SetNextValue(bool value) override;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h(66):    virtual bool SetNext(const std::string& input) override;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(45):    const char* Key() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(60):    static ptrdiff_t LinkDiff();
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.h(86):    virtual bool SetNext(const std::string& input) override;
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(51):    virtual Object* GetQuasiSingleton();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(98):    virtual Object* New(size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h(46):    const char* HelpText() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(1878):    static void SendAckToOutputFile(const CliThread& cli);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.h(62):    static bool ThreadsEmpty();
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(55):    typedef uint32_t InstanceId;  // identifies an object within a Class
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(56):    typedef uint32_t ObjectId;    // ClassId (12 bits) + InstanceId (20 bits)
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(86):    virtual InstanceId GetInstanceId() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(176):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPoolRegistry.h(41):    static bool NullifyObjectData() { return NullifyObjectData_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(51):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.h(42):    id_t Gid() const { return gid_.GetId(); }
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.h(46):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.h(62):    StatisticsGroup* GetGroup(id_t gid) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.h(66):    void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.h(70):    static std::string StatsFileName() { return StatsFileName_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h(65):    int16_t DayOfWeek() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h(116):    const char* strMonth() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(111):    static bool TestFlag(FlagId fid);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(115):    static void ResetFlag(FlagId fid);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(147):    SysThreadId NativeThreadId() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(224):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.h(163):    typedef std::map< fn_name_arg, size_t > InvocationsTable;
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(72):    static void operator delete(void* addr) { }
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(76):    static void* operator new(size_t size, void* where);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3263):    typedef id_t Test;
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(148):    virtual void ConcludeTest(CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(79):    virtual bool ExitOnRestart(RestartLevel level) const override;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(100):    virtual MsgSize PayloadSize() const;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(80):    IpPort* Provision(ipport_t port);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwTracer.h(39):    bool PeersEmpty() const;
  C:/Users/gregu/Documents/tsf/tsf/nw/NwTracer.h(43):    bool PortsEmpty() const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(91):    bool operator==(const SysIpL3Addr& that) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(77):    bool IsValid() const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(175):    void Close();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.h(69):    word Connect(const SysIpL3Addr& remAddr);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.h(109):    word Send(const byte_t* data, size_t len);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.h(53):    word SendTo(const byte_t* data, size_t len, const SysIpL3Addr& remAddr);
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.h(56):    virtual void Unblock() override;
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIpService.h(55):    virtual IpPort* CreatePort(ipport_t pid) override;
  C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.h(40):    virtual void Unblock() override;
  C:/Users/gregu/Documents/tsf/tsf/nw/UdpIpService.h(39):    virtual IpPort* CreatePort(ipport_t pid) override;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(118):    void ResetCircuit();
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(48):    Id Fid() const { return Id(fid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(56):    const char* FullName() const { return name_; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(60):    bool CanBeDeactivated() const { return deactivation_; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(76):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(44):    PotsFeature::Id Fid() const { return fid_; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(48):    static ptrdiff_t LinkDiff();
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(99):    virtual bool SaveContext();
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(110):    virtual Event* RestoreContext(EventHandler::Rc& rc);
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(116):    virtual void FreeContext(bool freeMsg);
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(144):    virtual bool Save();
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(148):    virtual Event* Restore(EventHandler::Rc& rc);
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(152):    virtual void Free();
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(77):    static ptrdiff_t CellDiff();
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.h(48):    static word RtcYieldPercent() { return RtcYieldPercent_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.h(56):    static ptrdiff_t CellDiff2();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(333):    virtual void Handled(bool retain);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(337):    virtual bool SendFailure(debug64_t errval, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgFactory.h(43):    static void CaptureMsg(Context& ctx, const Message& msg, TransTrace* tt);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(38):    uint8_t           spare    : 6;   // reserved for future use
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(56):    Id Prid() const { return Id(prid_.GetId()); }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(103):    virtual ProtocolLayer* JoinPeer
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(110):    virtual bool DropPeer(const GlobalAddress& peerPrevRemAddr) = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(54):    typedef uint8_t Priority;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(237):    virtual bool SendMsg(Message& msg) override;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(520):    const StateId stid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(58):    static bool IsValidPortId(PortId pid)
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(100):    bool IsModifiable() const { return modifiable_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(104):    bool IsModifier() const { return modifier_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(82):    StateId NextState() const { return nextState_; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Timer.h(39):    static ptrdiff_t LinkDiff();
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(143):    TlvParmPtr FirstParm(ParmIterator& pit) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(148):    TlvParmPtr NextParm(ParmIterator& pit) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(169):    virtual TlvParmPtr AddParm(ParameterId pid, MsgSize plen);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(230):    typedef uint16_t Fence;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(248):    virtual void AddFence();
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(252):    TlvMsgLayout* TlvLayout() const
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(263):    Fence* FencePtr() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(267):    void CheckFence() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Trigger.h(59):    static bool IsValidId(Id tid)
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(237):    void StartTimer(TimerId tid, secs_t duration);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h(146):    void SetProfile(PotsProfile* prof) { prof_ = prof; }
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(406):    ProtocolSM* TimerPsm(TimerId tid) const;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsStatistics.h(30):    typedef uint8_t Id;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.h(42):    void SetCauseToTreatmentQ(Cause::Ind cause, PotsTreatmentQueue::QId qid);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h(250):    void UpdateTestPsm();
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h(326):    TestPsm* GetTestPsm() const { return testPsm_; }
W037 Member could be protected
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(110):    static Address::DN IndexToDN(uint32_t i) { return i + FirstDN - 1; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1014):    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1019):    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1084):    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeIncrement.cpp(96):    static LibrarySet* Evaluate(CliThread& cli);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(62):    const ClassPtrVector* Classes() const { return &classes_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(70):    const EnumPtrVector* Enums() const { return &enums_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(74):    const ForwardPtrVector* Forws() const { return &forws_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(720):    const std::string& GetText() const { return text_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(106):    bool IsInternal() const { return decl_.internal; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(246):    void Accessed() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(256):    void DisplayReferent(std::ostream& stream, bool fq) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(260):    std::string strLocation() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(265):    void strName(std::ostream& stream, bool fq, const QualName* name) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(751):    Cxx::ItemType GetLocale() const { return locale_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(755):    TemplateRole GetTemplateRole() const { return role_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(289):    bool IsExtern() const { return extern_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(293):    bool IsConstexpr() const { return constexpr_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(297):    bool WasInited() const { return inited_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(38):    CodeFile* GetImplFile() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(57):    virtual bool GetScopedName(std::string& name, size_t n) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(79):    CxxScoped* FindInheritedName() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(84):    void DisplayFiles(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(97):    FileRole GetFileRole(const CodeFile* file) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(105):    virtual bool IsUnused() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(125):    virtual LibrarySet* Create(const std::string& name, SetOfIds* set) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(63):    virtual void Display(std::ostream& stream,
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(87):    void LogSubtended(std::ostream& stream,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCharParm.h(24):    CliCharParm(const char* help, const char* chars,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(142):    bool GetBoolParm(bool& b, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(162):    bool GetPtrParm(void*& p, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(188):    bool GetTextParm(id_t& i, std::string& s, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(210):    bool GetFileName(std::string& s, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(222):    bool GetIdentifier(std::string& s, CliThread& cli,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(233):    const char* Help() const { return help_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(237):    bool IsOptional() const { return opt_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/CliPtrParm.h(23):    explicit CliPtrParm(const char* help,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h(50):    const Registry< CliParm >& Parms() const { return parms_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(33):    typedef uint8_t sel_t;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(42):    virtual void Patch(sel_t selector, void* arguments) { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(54):    typedef id_t ClassId;         // identifies a Class
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(47):    virtual void DisplayStat(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/StreamRequest.h(42):    StreamRequest(const StreamRequest& that);
  C:/Users/gregu/Documents/tsf/tsf/nb/TimedRecord.h(33):    ticks_t GetTicks() const { return ticks_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/TimedRecord.h(37):    void SetTicks(const ticks_t& ticks) { ticks_ = ticks; }
  C:/Users/gregu/Documents/tsf/tsf/nb/TimedRecord.h(41):    SysThreadId Nid() const { return nid_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(55):    void Nullify() { owner_ = NIL_ID; }
  C:/Users/gregu/Documents/tsf/tsf/nw/InputHandler.h(47):    IpPort* Port() const { return port_; }
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(52):    IoThread* GetThread() const { return thread_; }
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(82):    bool IsOpen() const;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(253):    explicit PotsMessage(SbIpBufferPtr& buff);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(132):    virtual InspectRc InspectMsg(debug32_t& errval) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(241):    MsgDirection Dir() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(55):    bool IsUppermost() const { return upper_ == nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(80):    virtual FactoryId GetFactory() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(62):    enum IncomingRc
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(71):    enum OutgoingRc
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(117):    Message* FirstOgMsg() const { return ogMsgq_.First(); }
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(48):    typedef ServicePortId PortId;
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(66):    virtual const char* PortName(PortId pid) const;
W038 Typedef of pointer type
  C:/Users/gregu/Documents/tsf/tsf/nb/SysDecls.h(31): typedef void* SysHeap_t;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysDecls.h(32): typedef void* SysThread_t;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysDecls.h(34): typedef void* SysMutex_t;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysDecls.h(35): typedef void* SysSentry_t;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h(71): typedef char* ptr_t;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h(87): typedef const char* const fixed_string;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h(92): typedef const char* const fn_name;      // for defining a function name
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h(93): typedef const char* const fn_name_arg;  // when fn_name is an argument
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.h(44): typedef TlvParmLayout* TlvParmPtr;  // pointer to a parameter
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.h(45): typedef TlvParmPtr* TlvParmArray;   // array of pointers to parameters
W041 Data is init-only
  C:/Users/gregu/Documents/tsf/tsf/an/AnModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/cb/CbModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/cn/CnModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/ct/CtModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.h(391):    static bool Initialized;
  C:/Users/gregu/Documents/tsf/tsf/mb/MbModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/nb/CinThread.cpp(134):    FunctionGuard guard(FunctionGuard::MakeUnpreemptable);
  C:/Users/gregu/Documents/tsf/tsf/nb/CoutThread.cpp(118):    FunctionGuard
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.cpp(272):    FunctionGuard
  C:/Users/gregu/Documents/tsf/tsf/nb/InitThread.cpp(292):    FunctionGuard guard(FunctionGuard::MakeUnpreemptable);
  C:/Users/gregu/Documents/tsf/tsf/nb/LogThread.cpp(141):    FunctionGuard
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(1682):    FunctionGuard guard(FunctionGuard::MakePreemptable, yield);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbModule.h(49):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/nb/Singleton.h(115):    static T* Instance_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(467):    MutexGuard guard(&lock_);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(661):    MutexGuard guard(&lock_);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(696):    MutexGuard guard(&lock_);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(243):    FunctionGuard guard(FunctionGuard::MakePreemptable, yield);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/nw/NwModule.h(49):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/on/OnModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/pb/PbModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/rn/RnModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbModule.h(51):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/sn/SnModule.h(47):    static bool Registered;
  C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.cpp(439):    FunctionGuard guard(FunctionGuard::MakePreemptable, yield);
  C:/Users/gregu/Documents/tsf/tsf/st/StModule.h(47):    static bool Registered;
W042 Data is write-only
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(211):    LibraryVarSet* varSet_;
W044 Data is not private
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(292):    size_t refs_ : 16;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(254):    CxxToken* item;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h(164):    std::unique_ptr< CliBuffer > ibuf;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h(168):    ostringstreamPtr obuf;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(74):    std::atomic_uint32_t curr_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(78):    std::atomic_uint32_t prev_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(82):    std::atomic_uint64_t total_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(86):    uint32_t divisor_;
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(118):    Id rid_ : 8;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(83):    const ipport_t port_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(88):    IpPort* ipPort_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(92):    size_t rxSize_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(96):    size_t txSize_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(100):    SysIpL2Addr host_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(104):    size_t recvs_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(108):    SysIpL3Addr txAddr_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(112):    SysIpL3Addr rxAddr_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(116):    ticks_t ticks0_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(120):    byte_t* buffer_;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(477):    ServiceId owner_;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(481):    const EventId eid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(516):    const ServiceId sid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(520):    const StateId stid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(524):    const EventHandler::Rc rc_;
W047 Data could be const
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(156):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(325):    Progress::Ind progress_;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(341):    Cause::Ind cause_;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.h(77):    RegCell did_;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(81):    stringVector intIncls_;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(348):    RegCell fid_;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.h(508): extern uint8_t Indent_Size;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(278):    CxxToken* via_;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(58):    bool const_ : 1;       // type is const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(59):    bool constptr_ : 1;    // pointer is const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(62):    TagCount refs_ : 8;    // number of references
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(195):    Q2Link link_;
  C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.h(75):    RegCell port_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgFlagParm.h(62):    FlagId fid_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h(78):    word min_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h(82):    word max_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(140):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.h(102):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliAppData.h(78):    Id id_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(90):    RegCell iid_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIntParm.h(64):    word min_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIntParm.h(68):    word max_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIntParm.h(72):    bool hex_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(125):    uintptr_t patchArea_;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(99):    signal_t value_;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(111):    uint8_t severity_;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(115):    Flags attrs_;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(119):    RegCell sid_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(103):    RegCell sid_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(107):    DynString expl_;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.h(85):    RegCell gid_;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.h(89):    DynString expl_;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsThread.h(38):    static secs_t LongIntervalSecs;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsThread.h(43):    static secs_t ShortIntervalSecs;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsThread.h(50):    static size_t WakeupsBetweenReports;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsThread.h(55):    static ticks_t PrevToCurrTicks;
  C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.h(81):    DynString name_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.h(93):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h(90):    char abbr_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h(94):    bool safe_;
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h(90):    size_t size_;
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionStats.h(63):    Q2Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1028):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1540):    Q2Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(164):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(168):    ipport_t port_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(132):    RegCell sid_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(78):    PotsFeature::Id fid_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(82):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsHtlFeature.h(44):    Address::DN dn_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(297):    Q2Link link_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(321):    Faction faction_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(199):    Id eid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(252):    ProtocolId prid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(105):    ServiceId sid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(109):    ServiceId aid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(113):    TriggerId tid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(121):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.h(119):    RegCell iid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.h(145):    static word RtcYieldPercent_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(172):    ProtocolId prid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(358):    FactoryId fid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(103):    ProtocolId prid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/State.h(102):    ServiceId sid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Timer.h(121):    TimerId tid_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Timer.h(133):    Q2Link link_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Trigger.h(103):    Id tid_;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(171):    Cause::Ind cause_;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(132):    Facility::Ind ind_;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(146):    PotsTreatmentQueue::QId qid_;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(150):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(179):    Tone::Id tone_;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(183):    secs_t duration_;
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.h(113):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/st/MscContext.h(129):    Q1Link link_;
  C:/Users/gregu/Documents/tsf/tsf/st/MscContextPair.h(70):    Q1Link link_;
W048 Data could be const pointer
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(128):    const char* default_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(132):    const char* expl_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCharParm.h(54):    const char* chars_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(94):    const char* name_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(98):    const char* help_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(316):    const char* help_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(324):    const char* tag_;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h(95):    const char* text_;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(103):    const char* name_;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(107):    const char* expl_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(172):    IpService* service_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(206):    PotsProfile* profile_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(118):    const char* abbr_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(122):    const char* name_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(256):    const char* name_;
W050 Default constructor invoked: POD members not initialized
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.win.cpp(39):    _finddata_t fileAttrs;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1950):       WarningLog log;
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp(800):    FileLevel item;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1038):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1340):    DataInitAttrs attrs;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1577):    SymbolView local;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.cpp(826):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(827):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2138):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1284):       SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(270):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(2302):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(601):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(2476):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(650):       IntLiteral::Tags tags;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(697):       FloatLiteral::Tags tags;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(761):    IntLiteral::Tags tags;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp(1481):    SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp(983):             SymbolView view;
  C:/Users/gregu/Documents/tsf/tsf/nb/Singletons.cpp(77):    SingletonTuple entry;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.win.cpp(28):    LARGE_INTEGER frequency;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.win.cpp(59):       LARGE_INTEGER now;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.win.cpp(65):       _timeb now;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.win.cpp(26):    _timeb timebuff;
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.win.cpp(27):    tm timeofday;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.win.cpp(36):    in_addr result;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.win.cpp(32):    addrinfo hints;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.win.cpp(89):    sockaddr_in addr;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(36):    sockaddr_in addr;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp(245):    WSAData wsaData;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(24):    sockaddr_in peer;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(49):    sockaddr_in peer;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(97):    sockaddr_in host;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(205):    sockaddr_in peer;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(50):    sockaddr_in peer;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp(82):    sockaddr_in peer;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h(218):    SignalEntry trace_[TraceSize];
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(345):    MessageEntry trace_[TraceSize];
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(178):    ParmIterator pit;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(301):    ParmIterator pit;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(321):    ParmIterator pit;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp(382):    ParmIterator locpit;
W051 Default constructor invoked
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(2249):    CxxUsageSets symbols;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3163):    CxxUsageSets usages;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp(131):    auto list = std::unique_ptr< pollfd[] >(new pollfd[count]);
W052 Default copy constructor invoked
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(144):    arg_(arg)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1906):    attrs_(Numeric::Nil)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(340):       : num_(num), tags_(tags) { CxxStats::Incr(CxxStats::INT_LITERAL); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(376):       : num_(num), tags_(tags) { CxxStats::Incr(CxxStats::FLOAT_LITERAL); }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.cpp(39):    objAddr_(NilLocalAddress)
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.cpp(26): GlobalAddress::GlobalAddress() : sbAddr_(NilLocalAddress)
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.cpp(37):    sbAddr_(NilLocalAddress)
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.cpp(51):    sbAddr_(NilLocalAddress)
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.cpp(65):    sbAddr_(sbAddr)
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.cpp(28):    txAddr(NilLocalAddress),
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.cpp(29):    rxAddr(NilLocalAddress),
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(41):    locAddr_(msg.GetReceiver()),
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(42):    remAddr_(msg.GetSender()),
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(56):    locAddr_(GlobalAddress::NilAddr),
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(57):    remAddr_(GlobalAddress::NilAddr),
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(582):    locAddr_(NilLocalAddress),
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp(583):    remAddr_(NilLocalAddress),
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.cpp(26):    locAddr_(mt.LocAddr()),
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.cpp(27):    remAddr_(NilLocalAddress),
W053 Default assignment operator invoked
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsMessages.cpp(132):       addr = GlobalAddress(peer, PotsCallIpPort, PotsCallFactoryId);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsMessages.cpp(187):       addr = GlobalAddress(peer, PotsShelfIpPort, PotsShelfFactoryId);
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.cpp(20): const GlobalAddress GlobalAddress::NilAddr = GlobalAddress();
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(189):    peerPort->remAddr_ = peerPrevRemAddr;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(190):    remAddr_ = GlobalAddress::NilAddr;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(302):    peerPrevRemAddr = peerPort->remAddr_;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(303):    locAddr_ = GlobalAddress(peerPort->locAddr_, locAddr_.sbAddr_);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(304):    remAddr_ = peerPort->locAddr_;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(305):    peerPort->remAddr_ = locAddr_;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(362):       remAddr_ = msg.GetSender();
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(367):          locAddr_ = GlobalAddress(msg.RxIpAddr(), locAddr_.sbAddr_);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(406):       locAddr_ = GlobalAddress(txaddr, locAddr_.sbAddr_);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(407):       remAddr_ = msg.GetReceiver();
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp(466):       peer->remAddr_ = locAddr_;
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp(404):       addr = GlobalAddress(addr, dest->EnsurePort()->LocAddr().SbAddr());
W054 Base class constructor is public
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(220):    Class(QualNamePtr& name, Cxx::ClassTag tag);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBoolParm.h(23):    CfgBoolParm(const char* key, const char* def, bool* field, const char* expl);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h(24):    CfgIntParm(const char* key, const char* def, word* field,
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.h(24):    CfgStrParm(const char* key, const char* def,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliBoolParm.h(24):    explicit CliBoolParm(const char* help,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCharParm.h(24):    CliCharParm(const char* help, const char* chars,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIntParm.h(34):    CliIntParm(const char* help, word min, word max,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliPtrParm.h(23):    explicit CliPtrParm(const char* help,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h(33):    CliText(const char* help, const char* text,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliTextParm.h(34):    explicit CliTextParm(const char* help, bool opt = false,
  C:/Users/gregu/Documents/tsf/tsf/nb/MsgBuffer.h(28):    MsgBuffer();
  C:/Users/gregu/Documents/tsf/tsf/nb/MsgBuffer.h(32):    MsgBuffer(const MsgBuffer& that);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(26):    StatusCommand();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(40):    SetWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(53):    explicit SetCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(69):    IncludeWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(83):    explicit IncludeCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(99):    ExcludeWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(112):    explicit ExcludeCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(142):    explicit QueryCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(158):    SaveWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(170):    explicit SaveCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(186):    ClearWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(204):    explicit ClearCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/SoftwareException.h(26):    SoftwareException
  C:/Users/gregu/Documents/tsf/tsf/nb/SoftwareException.h(28):    SoftwareException
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(119):    explicit Counter(const std::string& expl, uint32_t divisor = 1);
  C:/Users/gregu/Documents/tsf/tsf/nb/StreamRequest.h(37):    StreamRequest();
  C:/Users/gregu/Documents/tsf/tsf/nb/StreamRequest.h(42):    StreamRequest(const StreamRequest& that);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(30):    CorruptWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(42):    explicit CorruptCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(84):    NtSaveWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(96):    explicit NtSaveCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(110):    SizesCommand();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(125):    TestcaseAction();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(144):    explicit TestcaseCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(34):    IpBuffer(MsgDirection dir, MsgSize header, MsgSize payload);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(38):    IpBuffer(const IpBuffer& that);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(24):    NwClearWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(39):    explicit NwClearCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(52):    NwExcludeWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(65):    explicit NwExcludeCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(78):    NwIncludeWhatParm();
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(91):    explicit NwIncludeCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(106):    explicit NwQueryCommand(bool bind = true);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(119):    NwStatusCommand() { }
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(25):    SysIpL2Addr();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(29):    explicit SysIpL2Addr(ipv4addr_t v4Addr);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(34):    explicit SysIpL2Addr(const std::string& text);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(38):    SysIpL2Addr(const SysIpL2Addr& that);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(25):    SysIpL3Addr();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(30):    SysIpL3Addr(ipv4addr_t v4Addr, ipport_t port,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(36):    SysIpL3Addr(const SysIpL2Addr& l2Addr, ipport_t port,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(44):    SysIpL3Addr
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(49):    SysIpL3Addr(const SysIpL3Addr& that);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsIncrement.h(26):    PbSizesCommand() { }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(253):    explicit PotsMessage(SbIpBufferPtr& buff);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h(257):    PotsMessage(ProtocolSM* psm, MsgSize size);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(453):    EventTrace(Id rid, const Event& evt);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(498):    HandlerTrace(ServiceId sid, const State& state, const Event& evt,
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(37):    explicit TlvMessage(SbIpBufferPtr& buff);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(41):    TlvMessage(ProtocolSM* psm, MsgSize size);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(49):    TlvMessage(const TlvParmLayout& parm, ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(54):    TlvMessage(const Message& msg, ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.h(26):    StSizesCommand() { }
W055 Single-argument constructor is not explicit
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(153):    DigitString(Address::DN dn);
W056 Member not included in member initialization list
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(587):       TypeNamePtrVector* names_;  // the names in a qualified name
W059 Base class virtual destructor is not public
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(163):    virtual ~LibrarySet();
  C:/Users/gregu/Documents/tsf/tsf/mb/Tones.h(67):    virtual ~Tone();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(92):    virtual ~Class();
  C:/Users/gregu/Documents/tsf/tsf/nb/CliAppData.h(70):    virtual ~CliAppData();
  C:/Users/gregu/Documents/tsf/tsf/nb/Exception.h(50):    virtual ~Exception() noexcept;
  C:/Users/gregu/Documents/tsf/tsf/nb/Module.h(131):    virtual ~Module();
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(203):    virtual ~ObjectPool();
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(90):    virtual ~PosixSignal();
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(266):    virtual ~Thread();
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h(77):    virtual ~Tool();
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(114):    virtual ~IpService();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(161):    virtual ~SysSocket();
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(93):    virtual ~PotsFeature();
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(61):    virtual ~PotsFeatureProfile();
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(174):    virtual ~Context();
  C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h(111):    virtual ~EventHandler();
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(188):    virtual ~Factory();
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(78):    virtual ~Initiator();
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(102):    virtual ~InvokerPool();
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(158):    virtual ~Parameter();
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(121):    virtual ~Protocol();
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(134):    virtual ~ProtocolLayer();
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(164):    virtual ~Service();
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(154):    virtual ~ServiceSM();
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(94):    virtual ~Signal();
  C:/Users/gregu/Documents/tsf/tsf/sb/State.h(76):    virtual ~State();
  C:/Users/gregu/Documents/tsf/tsf/sb/Trigger.h(84):    virtual ~Trigger();
W069 Virtual function is public
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(995):    virtual EventHandler::Rc RaiseAuthorizeOrigination(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(996):    virtual EventHandler::Rc RaiseCollectInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(997):    virtual EventHandler::Rc RaiseLocalInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(998):    virtual EventHandler::Rc RaiseCollectionTimeout(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(999):    virtual EventHandler::Rc RaiseAnalyzeInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1000):    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1001):    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1002):    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1003):    virtual EventHandler::Rc RaiseSendCall(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1004):    virtual EventHandler::Rc RaiseRemoteBusy(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1005):    virtual EventHandler::Rc RaiseRemoteProgress
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1007):    virtual EventHandler::Rc RaiseRemoteAlerting(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1008):    virtual EventHandler::Rc RaiseRemoteNoAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1009):    virtual EventHandler::Rc RaiseRemoteAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1010):    virtual EventHandler::Rc RaiseAuthorizeTermination(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1011):    virtual EventHandler::Rc RaiseSelectFacility(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1012):    virtual EventHandler::Rc RaisePresentCall(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1013):    virtual EventHandler::Rc RaiseLocalBusy(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1014):    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1015):    virtual EventHandler::Rc RaiseLocalProgress
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1017):    virtual EventHandler::Rc RaiseLocalAlerting(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1018):    virtual EventHandler::Rc RaiseLocalAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1019):    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1020):    virtual EventHandler::Rc RaiseLocalSuspend(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1021):    virtual EventHandler::Rc RaiseLocalResume(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1022):    virtual EventHandler::Rc RaiseRemoteSuspend(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1023):    virtual EventHandler::Rc RaiseRemoteResume(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1030):    virtual EventHandler::Rc RaiseLocalRelease
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1032):    virtual EventHandler::Rc RaiseRemoteRelease
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1034):    virtual EventHandler::Rc RaiseReleaseCall
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1036):    virtual EventHandler::Rc RaiseApplyTreatment
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1043):    virtual EventHandler::Rc AnalyzeInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1048):    virtual EventHandler::Rc RequestService(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1055):    virtual EventHandler::Rc SelectRoute(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1061):    virtual EventHandler::Rc AnalyzeNPsmTimeout
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1068):    virtual EventHandler::Rc HandleLocalAlerting();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1073):    virtual EventHandler::Rc HandleLocalAnswer();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1077):    virtual EventHandler::Rc HandleRemoteRelease(Event& currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1084):    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1090):    virtual CipMessage* BuildCipIam();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1096):    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1198):    virtual Cause::Ind VerifyRoute(RouteResult::Id rid) const;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(457):    virtual EventHandler::Rc RaiseReleaseUser
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(459):    virtual EventHandler::Rc RaiseProxyProgress
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(461):    virtual EventHandler::Rc RaiseProxyAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(462):    virtual EventHandler::Rc RaiseProxyRelease
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(497):    virtual void SetUPsm(MediaPsm& psm) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(111):    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(119):    virtual Function* MatchFunc(const Function* curr, bool base) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(249):    virtual ClassInst* EnsureInstance(const TypeName* type);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(257):    virtual Class* BaseClass()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(262):    virtual BaseDecl* GetBaseDecl() const { return base_.get(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(290):    virtual bool DerivesFrom(const Class* cls) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(405):    virtual bool AddAnonymousUnion(ClassPtr& cls) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(422):    virtual void CheckIfUsed(Warning warning) const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(430):    virtual Class* DirectClass() const override { return GetClass(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(791):    virtual CxxScoped* FindItem(const std::string& name) const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(227):    virtual CxxToken* GetValue() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(232):    virtual bool IsDefined() const { return true; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(238):    virtual void SetExpr(ExprPtr& rhs);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(267):    virtual CxxToken* RootType() const override { return GetValue(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(402):    virtual bool AddElif(Elif* e) { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(406):    virtual bool AddElse(const Else* e) { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(415):    virtual bool HasCompiledCode() const { return compile_; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h(456):    virtual void AddCondition(ExprPtr& c) override { condition_ = std::move(c); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(48):    virtual bool Display(std::ostream& stream) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(60):    virtual bool Display(std::ostream& stream) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(76):    virtual bool Display(std::ostream& stream) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(92):    virtual bool Display(std::ostream& stream) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(112):    virtual bool Display(std::ostream& stream) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(97):    virtual void SetDecl(CodeFile* file, size_t pos) { decl_.SetLoc(file, pos); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(111):    virtual bool IsDeclaredInFunction() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(119):    virtual bool IsStatic() const { return true; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(124):    virtual CxxScope* GetScope() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(130):    virtual void SetScope(CxxScope* scope) const { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(134):    virtual void SetAccess(Cxx::Access access) { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(139):    virtual void SetTemplateParms(TemplateParmsPtr& parms);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(145):    virtual const TemplateParms* GetTemplateParms() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(153):    virtual Class* GetTemplate() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(159):    virtual std::string QualifiedName(bool scopes, bool templates)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(165):    virtual std::string ScopedName(bool templates) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(170):    virtual CxxArea* GetArea() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(175):    virtual Function* GetFunction() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(179):    virtual Cxx::Access GetAccess() const { return Cxx::Public; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(183):    virtual id_t GetDeclFid() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(200):    virtual bool EnterScope() { return true; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(210):    virtual bool IsImplemented() const { return true; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(215):    virtual bool FindReferent();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(219):    virtual void SetAsReferent(const CxxNamed* user) { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(224):    virtual bool Instantiate() { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(228):    virtual bool IsInTemplateInstance() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(235):    virtual StackArg NameToArg(Cxx::Operator op);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(241):    virtual StackArg MemberToArg(StackArg& via, Cxx::Operator op);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(508):    virtual CxxNamed* DirectType() const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(553):    virtual bool ResolveTypedef(Typedef* type) const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(557):    virtual bool ResolveTemplate
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(570):    virtual void SubclassAccess(Class* cls) const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(747):    virtual void SetLocale(Cxx::ItemType locale);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(759):    virtual Function* GetFuncSpec() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(770):    virtual TypeSpec* Clone() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(774):    virtual void AddArray(ArraySpecPtr& array) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(778):    virtual void SetConst(bool readonly) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(782):    virtual void SetConstPtr(bool constptr) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(786):    virtual void SetPtrs(TagCount ptrs) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(790):    virtual void SetRefs(TagCount refs) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(794):    virtual void SetArrayPos(int8_t pos) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(798):    virtual void SetPtrDetached(bool on) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(802):    virtual void SetRefDetached(bool on) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(807):    virtual void SetReferent(CxxNamed* ref, UsingMode mode) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(813):    virtual TagCount Ptrs(bool arrays) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(819):    virtual TagCount Refs() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(824):    virtual TagCount Arrays() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(828):    virtual bool HasArrayDefn() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(832):    virtual void EnteringScope(const CxxScope* scope) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(836):    virtual void EnterArrays() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(840):    virtual TypeTags GetTags() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(845):    virtual std::string TypeTagsString(const TypeTags& tags) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(850):    virtual void DisplayTags(std::ostream& stream) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(854):    virtual void DisplayArrays(std::ostream& stream) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(860):    virtual void AdjustPtrs(TagCount count) = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(865):    virtual void RemoveRefs() = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(870):    virtual TagCount PtrCount(bool arrays) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(874):    virtual TagCount RefCount() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(878):    virtual TagCount ArrayCount() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(883):    virtual bool MatchesExactly(const TypeSpec* that) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(887):    virtual StackArg ResultType() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(891):    virtual void SetTemplateRole(TemplateRole role) const { role_ = role; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(902):    virtual TypeMatch MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(908):    virtual TypeMatch MatchTemplateArg(const TypeSpec* that) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(913):    virtual std::string AlignTemplateArg(const TypeSpec* thatArg) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(919):    virtual void Instantiating() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(66):    virtual Cxx::Access GetCurrAccess() const { return Cxx::Private; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(71):    virtual bool HasUsingFor(const std::string& name, size_t prefix)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(79):    virtual void AccessibilityOf
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(321):    virtual void Promote
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(389):    virtual void SetDefn(CodeFile* file, size_t pos) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1054):    virtual void CheckAccessControl() const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1058):    virtual void CheckIfHiding() const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1143):    virtual void SetDefn(CodeFile* file, size_t pos) override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1160):    virtual void WasCalled() override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(57):    virtual bool GetScopedName(std::string& name, size_t n) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(61):    virtual void AccessibilityTo(const CxxScope* scope, SymbolView* view) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(70):    virtual void RecordAccess(Cxx::Access access) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(89):    virtual CodeFile* GetDefnFile() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(93):    virtual size_t GetDefnPos() const { return std::string::npos; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(101):    virtual void AddFiles(SetOfIds& imSet) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(105):    virtual bool IsUnused() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(460):    virtual void CheckAccessControl() const override;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(823):    virtual bool ResolveTemplate
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h(1182):    virtual bool ResolveTypedef(Typedef* type) const override { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(64):    virtual Cxx::ItemType Type() const { return Cxx::Undefined; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(70):    virtual const std::string* Name() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(74):    virtual QualName* GetQualName() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(79):    virtual std::string TypeString(bool arg) const { return ERROR_STR; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(83):    virtual TypeSpec* GetTypeSpec() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(87):    virtual bool IsConst() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(91):    virtual bool IsConstPtr() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(96):    virtual bool IsAuto() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(101):    virtual bool IsIndirect() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(105):    virtual bool IsInitializing() const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(114):    virtual CxxToken* AutoType() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(119):    virtual Namespace* GetSpace() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(124):    virtual Class* GetClass() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(129):    virtual Class* Declarer() const { return GetClass(); }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(135):    virtual TypeName* GetTemplateArgs() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(140):    virtual Numeric GetNumeric() const { return Numeric::Nil; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(144):    virtual void GetConvertibleTypes(StackArgVector& types) { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(149):    virtual CxxNamed* Referent() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(155):    virtual void EnterBlock();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(160):    virtual void ExitBlock() { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(166):    virtual bool AppendUnary() { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(170):    virtual CxxToken* Back() { return this; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(175):    virtual bool WasRead() { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(187):    virtual bool WasWritten(const StackArg* arg, bool passed);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(192):    virtual bool SetNonConst() { return true; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(197):    virtual void WasMutated(const StackArg* arg) { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(203):    virtual void RecordUsage() const { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(208):    virtual void GetUsages(const CodeFile& file, CxxUsageSets& symbols) const { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(212):    virtual void Check() const { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(216):    virtual std::string Trace() const { return EMPTY_STR; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(220):    virtual bool InLine() const { return true; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(225):    virtual void Print(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(230):    virtual void Shrink() { }
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(54):    virtual LibSetType GetType() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(60):    virtual word Check(std::ostream& stream, std::string& expl) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(66):    virtual word Count(std::string& result) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(72):    virtual word Countlines(std::string& result) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(77):    virtual word Format(std::string& expl) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(83):    virtual word List(std::ostream& stream, std::string& expl) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(91):    virtual word Parse(std::string& expl, const std::string& opts) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(97):    virtual word Scan(std::ostream& stream,
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(104):    virtual word Show(std::string& result) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(110):    virtual word Sort(std::ostream& stream, std::string& expl) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(116):    virtual word Trim(std::ostream& stream, std::string& expl) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(125):    virtual LibrarySet* Create(const std::string& name, SetOfIds* set) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(126):    virtual LibrarySet* Assign(LibrarySet* rhs);
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(127):    virtual LibrarySet* Intersection(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(128):    virtual LibrarySet* Difference(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(129):    virtual LibrarySet* Union(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(130):    virtual LibrarySet* Directories() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(131):    virtual LibrarySet* Files() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(132):    virtual LibrarySet* FileName(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(133):    virtual LibrarySet* FileType(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(134):    virtual LibrarySet* MatchString(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(135):    virtual LibrarySet* FoundIn(const LibrarySet* that) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(136):    virtual LibrarySet* Implements() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(137):    virtual LibrarySet* UsedBy(bool self) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(138):    virtual LibrarySet* Users(bool self) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(139):    virtual LibrarySet* AffectedBy() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(140):    virtual LibrarySet* Affecters() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(141):    virtual LibrarySet* CommonAffecters() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(142):    virtual LibrarySet* NeededBy() const;
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(143):    virtual LibrarySet* Needers() const;
  C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.h(49):    virtual std::string Name() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.h(53):    virtual bool Supports(ProtocolId prid) const { return false; }
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(47):    virtual void SetState(StateId stid);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(63):    virtual void Deallocate();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(53):    virtual void SetOgPsm(MediaPsm* ogPsm);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(58):    virtual void SetOgTone(Tone::Id ogTone);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(63):    virtual void SetIcTone(Tone::Id icTone);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.h(33):    virtual bool SetMgwPsm(ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(63):    virtual void Display(std::ostream& stream,
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(82):    virtual void GetSubtended(Base* objects[], size_t& count) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(94):    virtual void Claim() { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(99):    virtual void ClaimBlocks();
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(117):    virtual void Cleanup() { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(125):    virtual void Startup(RestartLevel level) { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(133):    virtual void Shutdown(RestartLevel level) { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(137):    virtual MemoryType MemType() const { return MemPerm; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(141):    virtual const char* ClassName() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(49):    virtual void Explain(std::string& expl) const { expl = expl_; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(42):    virtual void Initialize();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(47):    virtual Object* Create();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(51):    virtual Object* GetQuasiSingleton();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(55):    virtual void FreeQuasiSingleton(Object* obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliAppData.h(51):    virtual void EventOccurred(Event evt);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommand.h(56):    virtual Rc GetTextParmRc
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(50):    virtual void Enter();
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(55):    virtual void Exit();
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(119):    virtual CliParm* AccessParm(CliCookie& cookie, size_t depth) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(127):    virtual void Explain(std::ostream& stream, col_t indent) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(137):    virtual Rc GetIntParmRc(word& i, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(147):    virtual Rc GetBoolParmRc(bool& b, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(157):    virtual Rc GetCharParmRc(char& c, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(167):    virtual Rc GetPtrParmRc(void*& p, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(195):    virtual Rc GetTextParmRc(id_t& i, std::string& s, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(205):    virtual Rc GetStringRc(std::string& s, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(215):    virtual Rc GetFileNameRc(std::string& s, CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(228):    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h(54):    virtual bool BindParm(CliParm& parm);
  C:/Users/gregu/Documents/tsf/tsf/nb/Exception.h(30):    virtual void Display(std::ostream& stream, const std::string& prefix) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Module.h(96):    virtual ModuleId* Dependencies(size_t& count) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/MsgBuffer.h(49):    virtual TraceStatus GetStatus() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(42):    virtual void Patch(sel_t selector, void* arguments) { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(67):    virtual Class* GetClass() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(75):    virtual void PostInitialize() { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(86):    virtual InstanceId GetInstanceId() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(93):    virtual Pooled* DeqBlock(size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(98):    virtual void EnqBlock(Pooled* obj, bool deleted);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(162):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(43):    virtual uint64_t Overall() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h(47):    virtual void DisplayStat(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.h(54):    virtual void DisplayStats(std::ostream& stream, id_t id) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(172):    virtual TraceStatus CalcStatus(bool dynamic) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(196):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h(41):    virtual const char* Name() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h(45):    virtual const char* Expl() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h(51):    virtual std::string Status() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(62):    virtual bool Display(std::ostream& stream);
  C:/Users/gregu/Documents/tsf/tsf/nw/InputHandler.h(76):    virtual IpBuffer* AllocBuff
  C:/Users/gregu/Documents/tsf/tsf/nw/InputHandler.h(92):    virtual void ReceiveBuff
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(44):    virtual bool InsertSocket(SysSocket* socket);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(100):    virtual MsgSize PayloadSize() const;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(119):    virtual bool AddBytes(const byte_t* source, MsgSize size, bool& moved);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(73):    virtual SysSocket* CreateAppSocket(size_t rxSize, size_t txSize);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(108):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(36):    virtual const char* Name() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(40):    virtual IpProtocol Protocol() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(45):    virtual ipport_t Port() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(49):    virtual Faction GetFaction() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(53):    virtual size_t RxSize() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(57):    virtual size_t TxSize() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(62):    virtual CliText* CreateText() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(68):    virtual SysSocket* CreateAppSocket() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(76):    virtual void GetAppSocketSizes(size_t& rxSize, size_t& txSize) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(62):    virtual std::string to_str() const;
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(61):    virtual IpProtocol Protocol() const { return IpAny; }
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(65):    virtual void Acquire() { }
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(69):    virtual void Release() { }
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(99):    virtual SendRc SendBuff(IpBuffer& buff) = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIpService.h(24):    virtual size_t MaxConns() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIpService.h(29):    virtual size_t MaxBacklog() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(71):    virtual PotsFeatureProfile* Subscribe
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(35):    virtual bool Activate(PotsProfile& profile, CliThread& cli);  //d
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(40):    virtual bool Deactivate(PotsProfile& profile);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(86):    virtual ContextType Type() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(90):    virtual RootServiceSM* RootSsm() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(94):    virtual ProtocolSM* FirstPsm() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(98):    virtual void NextPsm(ProtocolSM*& psm) const { psm = nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(102):    virtual void NextPort(MsgPort*& port) const { port = nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(99):    virtual bool SaveContext();
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(110):    virtual Event* RestoreContext(EventHandler::Rc& rc);
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(116):    virtual void FreeContext(bool freeMsg);
  C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h(102):    virtual Rc ProcessEvent
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(106):    virtual CliText* CreateText() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(112):    virtual Message* AllocOgMsg(SignalId sid) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(119):    virtual bool InjectMsg(Message& msg) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(125):    virtual Message* ReallocOgMsg(SbIpBufferPtr& buff) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(135):    virtual bool ScreenIcMsgs(Q1Way< Message >& msgq);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(157):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(73):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(132):    virtual InspectRc InspectMsg(debug32_t& errval) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(152):    virtual void Save();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(157):    virtual void Unsave();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(165):    virtual bool Retrieve(ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(172):    virtual bool Relay(ProtocolSM& ogPsm);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(176):    virtual bool SendToSelf();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(233):    virtual void SetReceiver(const GlobalAddress& receiver);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(237):    virtual void SetSender(const GlobalAddress& sender);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(262):    virtual bool Send(Route route);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(266):    virtual bool Restore();
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(78):    virtual void DisplayMsg(std::ostream& stream,
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(87):    virtual CliParm* CreateCliParm(Usage use) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(116):    virtual TestRc InjectMsg
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(129):    virtual TestRc VerifyMsg
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(65):    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h(97):    virtual void DisplayMsg(std::ostream& stream,
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(43):    virtual MsgPort* Port() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(47):    virtual ProtocolSM* UppermostPsm() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(80):    virtual FactoryId GetFactory() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(84):    virtual Message::Route Route() const = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(93):    virtual SysSocket* CreateAppSocket();
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(103):    virtual ProtocolLayer* JoinPeer
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h(110):    virtual bool DropPeer(const GlobalAddress& peerPrevRemAddr) = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/RootServiceSM.h(37):    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.h(29):    virtual bool RejectIngressWork() const override;
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(66):    virtual const char* PortName(PortId pid) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(96):    virtual ServiceSM* AllocModifier() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(54):    virtual ServicePortId CalcPort(const AnalyzeMsgEvent& ame) = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(60):    virtual EventHandler::Rc ProcessSap(Event& currEvent, Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(66):    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(87):    virtual void SetNextState(StateId stid);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(94):    virtual void PsmDeleted(ProtocolSM& exPsm);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(108):    virtual void SetNextSap(TriggerId sap);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(114):    virtual void SetNextSnp(TriggerId snp);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(126):    virtual void MorphToService(ServiceId sid);
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(71):    virtual CliText* CreateText() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmFactory.h(26):    virtual RootServiceSM* AllocRoot(const Message& msg, ProtocolSM& psm) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmFactory.h(32):    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(63):    virtual TlvParmPtr Wrap(const TlvMessage& msg, ParameterId pid);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(169):    virtual TlvParmPtr AddParm(ParameterId pid, MsgSize plen);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(184):    virtual TlvParmPtr ExpandParm(TlvParmLayout& parm, MsgSize plen);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(188):    virtual void DeleteParm(TlvParmLayout& parm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp(242):    virtual void Cancel() override;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h(122):    virtual EventHandler::Rc ApplyTreatment
W071 Virtual function has no overrides
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(995):    virtual EventHandler::Rc RaiseAuthorizeOrigination(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(996):    virtual EventHandler::Rc RaiseCollectInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(997):    virtual EventHandler::Rc RaiseLocalInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(998):    virtual EventHandler::Rc RaiseCollectionTimeout(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(999):    virtual EventHandler::Rc RaiseAnalyzeInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1000):    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1001):    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1002):    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1003):    virtual EventHandler::Rc RaiseSendCall(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1004):    virtual EventHandler::Rc RaiseRemoteBusy(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1005):    virtual EventHandler::Rc RaiseRemoteProgress
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1007):    virtual EventHandler::Rc RaiseRemoteAlerting(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1008):    virtual EventHandler::Rc RaiseRemoteNoAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1009):    virtual EventHandler::Rc RaiseRemoteAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1010):    virtual EventHandler::Rc RaiseAuthorizeTermination(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1011):    virtual EventHandler::Rc RaiseSelectFacility(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1012):    virtual EventHandler::Rc RaisePresentCall(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1013):    virtual EventHandler::Rc RaiseLocalBusy(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1014):    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1015):    virtual EventHandler::Rc RaiseLocalProgress
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1017):    virtual EventHandler::Rc RaiseLocalAlerting(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1018):    virtual EventHandler::Rc RaiseLocalAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1019):    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1020):    virtual EventHandler::Rc RaiseLocalSuspend(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1021):    virtual EventHandler::Rc RaiseLocalResume(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1022):    virtual EventHandler::Rc RaiseRemoteSuspend(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1023):    virtual EventHandler::Rc RaiseRemoteResume(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1030):    virtual EventHandler::Rc RaiseLocalRelease
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1032):    virtual EventHandler::Rc RaiseRemoteRelease
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1034):    virtual EventHandler::Rc RaiseReleaseCall
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1036):    virtual EventHandler::Rc RaiseApplyTreatment
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1043):    virtual EventHandler::Rc AnalyzeInformation(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1048):    virtual EventHandler::Rc RequestService(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1055):    virtual EventHandler::Rc SelectRoute(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1068):    virtual EventHandler::Rc HandleLocalAlerting();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1073):    virtual EventHandler::Rc HandleLocalAnswer();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1077):    virtual EventHandler::Rc HandleRemoteRelease(Event& currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1090):    virtual CipMessage* BuildCipIam();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1096):    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(457):    virtual EventHandler::Rc RaiseReleaseUser
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(459):    virtual EventHandler::Rc RaiseProxyProgress
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(461):    virtual EventHandler::Rc RaiseProxyAnswer(Event*& nextEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h(462):    virtual EventHandler::Rc RaiseProxyRelease
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(47):    virtual void SetState(StateId stid);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(63):    virtual void Deallocate();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(89):    virtual void EndOfTransaction();
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h(94):    virtual void ProcessIcMsg(Message& msg);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(53):    virtual void SetOgPsm(MediaPsm* ogPsm);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(58):    virtual void SetOgTone(Tone::Id ogTone);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h(63):    virtual void SetIcTone(Tone::Id icTone);
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.h(33):    virtual bool SetMgwPsm(ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.h(141):    virtual const char* ClassName() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(42):    virtual void Initialize();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(47):    virtual Object* Create();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(51):    virtual Object* GetQuasiSingleton();
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(55):    virtual void FreeQuasiSingleton(Object* obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(55):    virtual void Exit();
  C:/Users/gregu/Documents/tsf/tsf/nb/Module.h(96):    virtual ModuleId* Dependencies(size_t& count) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(67):    virtual Class* GetClass() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(75):    virtual void PostInitialize() { }
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(86):    virtual InstanceId GetInstanceId() const;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(93):    virtual Pooled* DeqBlock(size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(98):    virtual void EnqBlock(Pooled* obj, bool deleted);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(196):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(278):    virtual bool EnqMsg(MsgBuffer& msg);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(284):    virtual MsgBuffer* DeqMsg(msecs_t timeout);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h(148):    virtual void ConcludeTest(CliThread& cli) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(75):    virtual bool ConditionalPause(word percent);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(119):    virtual bool AddBytes(const byte_t* source, MsgSize size, bool& moved);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(108):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h(68):    virtual SysSocket* CreateAppSocket() const { return nullptr; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h(74):    virtual bool Unsubscribe(PotsProfile& profile);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(157):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(73):    virtual void DisplayStats(std::ostream& stream) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(152):    virtual void Save();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(157):    virtual void Unsave();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(165):    virtual bool Retrieve(ProtocolSM* psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(172):    virtual bool Relay(ProtocolSM& ogPsm);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(176):    virtual bool SendToSelf();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(233):    virtual void SetReceiver(const GlobalAddress& receiver);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(237):    virtual void SetSender(const GlobalAddress& sender);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(266):    virtual bool Restore();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(320):    virtual void Refresh();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(333):    virtual void Handled(bool retain);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(337):    virtual bool SendFailure(debug64_t errval, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(345):    virtual void ClearContext() const;
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(227):    virtual void SetState(StateId stid);
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(282):    virtual Priority GetPriority() const { return NormalPriority; }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(287):    virtual void MsgHandled(Message& msg) { }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(293):    virtual void RestoreIcMsg(Message& msg) { }
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(299):    virtual void RefreshMsg(Message& msg) { }
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(126):    virtual void MorphToService(ServiceId sid);
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(64):    virtual SbIpBufferPtr Parse() = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(71):    virtual SbIpBufferPtr Build() = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(63):    virtual TlvParmPtr Wrap(const TlvMessage& msg, ParameterId pid);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(169):    virtual TlvParmPtr AddParm(ParameterId pid, MsgSize plen);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(184):    virtual TlvParmPtr ExpandParm(TlvParmLayout& parm, MsgSize plen);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(188):    virtual void DeleteParm(TlvParmLayout& parm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(243):    virtual bool MatchParm(TlvParmPtr pptr, ParmIterator& pit, bool& last) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(248):    virtual void AddFence();
W076 Adjacent arguments have the same type
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1202):    BcFactory(Id fid, ProtocolId prid, const char* name);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(234):    word Modify(Modification act, std::string& item, std::string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(217):    TypeMatch CalcMatchWith(const StackArg& that, const std::string& thisType,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(263):    TypeMatch MatchWith(const StackArg& that, const std::string& thisType,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(499):    TypeMatch MatchTemplate(const QualName* that,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(687):    TypeMatch MatchTemplate(const TypeName* that,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(902):    virtual TypeMatch MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(321):    virtual void Promote
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1236):    static TypeMatch MatchTemplate
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.cpp(25): size_t FindTemplateBegin(const string& name, size_t pos, size_t depth);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.cpp(42): size_t RfindScopeOperator(const string& name, size_t begin, size_t end);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.h(101):    size_t Replace(std::string& code,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(587):    Function* FindNewOrDelete(const StackArg& arg, bool del, bool& pod) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.h(110):    size_t FindClosing(char lhc, char rhc, size_t pos = std::string::npos) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(49):    word Import
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(91):    word Assign(const std::string& name,
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(384):    static bool SetCompoundType
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(428):    bool GetParExpr(ExprPtr& expr, bool omit, bool opt = false);
  C:/Users/gregu/Documents/tsf/tsf/ct/SetOperations.h(18):    void SetDifference
  C:/Users/gregu/Documents/tsf/tsf/ct/SetOperations.h(27):    void SetIntersection
  C:/Users/gregu/Documents/tsf/tsf/ct/SetOperations.h(36):    void SetUnion
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.h(35):    uint64_t pack3(uint16_t a, uint16_t b, uint16_t c);
  C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.h(39):    uint64_t pack4(uint16_t a, uint16_t b, uint16_t c, uint16_t d);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.h(33):    CfgBitParm(const char* key, const char* def, const char* expl);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBoolParm.h(23):    CfgBoolParm(const char* key, const char* def, bool* field, const char* expl);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgFlagParm.h(24):    CfgFlagParm(const char* key, const char* def,
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h(24):    CfgIntParm(const char* key, const char* def, word* field,
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h(75):    CfgParm(const char* key, const char* def, const char* expl);
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.h(24):    CfgStrParm(const char* key, const char* def,
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.h(77):    CfgFileTimeParm(const char* key, const char* def,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCharParm.h(24):    CliCharParm(const char* help, const char* chars,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommand.h(85):    CliCommand(const char* comm, const char* help, size_t size = 32);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.h(43):    CliCommandSet(const char* comm, const char* help, size_t size = 32);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h(77):    CliIncrement(const char* name, const char* help, size_t size = 32);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliIntParm.h(34):    CliIntParm(const char* help, word min, word max,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(222):    bool GetIdentifier(std::string& s, CliThread& cli,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(228):    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h(33):    CliText(const char* help, const char* text,
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h(76):    char CharPrompt(const std::string& prompt,
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(57):    static void SwErr
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(77):    static void Progress(const std::string& s, bool eol, bool force = false);
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.h(42):    static void Spool(const std::string& name,
  C:/Users/gregu/Documents/tsf/tsf/nb/Formatters.h(61):    std::string strIndex(int n, int width = 0, bool colon = true);
  C:/Users/gregu/Documents/tsf/tsf/nb/Formatters.h(81):    std::string strCenter(const std::string& s, int breadth, int blanks);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbCliParms.h(105): CliParm::Rc GetCBV(const CliCommand& comm, CliThread& cli, bool& c, bool& v);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(223):    bool BidToIndices(Bid bid, size_t& i, size_t& j) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(228):    bool IndicesToBid(size_t i, size_t j, Bid& bid) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h(84):    PosixSignal(signal_t value, const char* name,
  C:/Users/gregu/Documents/tsf/tsf/nb/SymbolRegistry.h(38):    bool BindSymbol
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(56):    static const char* GetFileLoc(DWORD64 frame, DWORD& line, DWORD& disp);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h(56):    SysTime(int16_t year, int16_t month, int16_t day,
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(546):    void DisplaySummary
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h(68):    static void CheckHigh(FunctionStats*& high, FunctionStats* curr,
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(60):    IoThread(Faction faction, ipport_t port, size_t rxSize, size_t txSize);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(34):    IpBuffer(MsgDirection dir, MsgSize header, MsgSize payload);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPortCfgParm.h(31):    IpPortCfgParm(const char* key, const char* def,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h(44):    SysIpL3Addr
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(150):    SysSocket(ipport_t port, IpProtocol proto,
  C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.h(54):    SysTcpSocket(ipport_t port, size_t rxSize, size_t txSize, AllocRc& rc);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.h(36):    SysUdpSocket(ipport_t port, size_t rxSize, size_t txSize, AllocRc& rc);
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.h(34):    TcpIoThread(Faction faction, ipport_t port,
  C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.h(28):    UdpIoThread(Faction faction, ipport_t port, size_t rxSize, size_t txSize);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h(88):    PotsFeature(PotsFeature::Id fid, bool deactivation,
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(118):    void TraceMsg(ProtocolId prid, SignalId sid, MsgDirection dir);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(142):    void RecordMsg(bool incoming, bool inter, size_t size) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.h(42):    GlobalAddress(const SysIpL2Addr& l2Addr, ipport_t port, FactoryId fid);
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(73):    Initiator(ServiceId sid, ServiceId aid, TriggerId tid, Priority prio);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(154):    static BuffTrace* NextIcMsg
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(469):    static void DisplayEvent(std::ostream& stream, ServiceId sid, EventId eid);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTracer.h(114):    TraceRc SelectSignal(ProtocolId prid, SignalId sid, TraceStatus status);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTracer.h(166):       SignalFilter(ProtocolId p, SignalId s, TraceStatus ts);
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(159):    explicit Service(Id sid, bool modifiable = false, bool modifier = false);
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmFactory.h(40):    SsmFactory(Id fid, ProtocolId prid, const char* name);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(100):    template< typename T > T* CopyType
  C:/Users/gregu/Documents/tsf/tsf/st/StTestData.h(55):    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h(332):    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
W077 Virtual function defines default argument
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1036):    virtual EventHandler::Rc RaiseApplyTreatment
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(111):    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(444):    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(785):    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
W080 Argument could be const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(162/1):    virtual bool AddAnonymousUnion(ClassPtr& cls) { return false; }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(258/1):    bool SetAutoTypeOn(FuncData& data) const;
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(236/1):    bool GetStatements(BlockPtr& block, bool braced);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(334/1):    bool GetCtorInit(FunctionPtr& func);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(353/1):    bool GetArguments(FunctionPtr& func);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(385/1):       (QualNamePtr& name, Cxx::Type type, int size, int sign);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(443/1):    bool GetNum(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(444/1):    bool GetChar(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(445/1):    bool GetStr(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(455/1):    bool GetCast(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(456/1):    bool GetPrecedence(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(463/1):    bool HandleTilde(ExprPtr& expr, size_t start);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(467/1):    bool GetSubscript(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(476/1):    bool GetCxxCast(ExprPtr& expr, Cxx::Operator op);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(477/1):    bool GetConditional(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(478/1):    bool GetDefined(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(479/1):    bool GetDelete(ExprPtr& expr, Cxx::Operator op);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(480/1):    bool GetNew(ExprPtr& expr, Cxx::Operator op);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(481/1):    bool GetSizeOf(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(482/1):    bool GetThrow(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(483/1):    bool GetTypeId(ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(551/1):    bool Punt(ExprPtr& expr, size_t end);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliBuffer.h(87/1):       (CliThread& cli, const std::string& expl, std::streamsize p = -1) const;
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(64/1):    bool Enq(T& elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(85/1):    bool Henq(T& elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(107/1):    bool Insert(T* prev, T& elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(142/1):    bool Exq(T& elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(306/1):    void Corrupt(T* elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(120/1):    bool Exq(T& elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(251/1):    bool Erase(T& item)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(91/4):       const Thread* client, size_t size, SysThreadId& nid);
  C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h(70/1):    void InvokeHandler(IpPort& port, const byte_t* source, MsgSize size) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(276/1):    bool ProcessMsg(Q1Way< Message >& msgq, const InvokerThread* inv);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(135/1):    virtual bool ScreenIcMsgs(Q1Way< Message >& msgq);
  C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h(92/2):       (const ServiceSM& parentSsm, Event& icEvent, Event*& ogEvent) const;
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(188/1):    virtual void DeleteParm(TlvParmLayout& parm);
W082 Function could be const
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(65):    msecs_t Originate();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1096):    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h(1153):    CipMessage* BuildCipRel(Cause::Ind cause);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(212):    word Format(std::string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(234):    word Modify(Modification act, std::string& item, std::string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h(428):    void Append(const std::string& name, bool space = false);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(109):    void InsertClass(Class* cls);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(110):    void InsertData(Data* data);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(111):    void InsertEtor(Enumerator* etor);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(112):    void InsertEnum(Enum* item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(113):    void InsertForw(Forward* forw);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(114):    void InsertFriend(Friend* frnd);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(115):    void InsertFunc(Function* func);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(116):    void InsertMacro(Macro* macro);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(117):    void InsertSpace(Namespace* space);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(118):    void InsertTerm(Terminal* term);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(119):    void InsertType(Typedef* type);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(124):    void EraseClass(const Class* cls);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(125):    void EraseData(const Data* data);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(126):    void EraseEtor(const Enumerator* etor);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(127):    void EraseEnum(const Enum* item);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(128):    void EraseForw(const Forward* forw);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(129):    void EraseFriend(const Friend* frnd);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(130):    void EraseFunc(const Function* func);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(131):    void EraseMacro(const Macro* macro);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(132):    void EraseSpace(const Namespace* space);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(133):    void EraseTerm(const Terminal* term);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(134):    void EraseType(const Typedef* type);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(135):    void EraseLocal(const CxxScoped* name);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(139):    void EraseLocals();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(160):    virtual void ExitBlock() { }
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(59):    CodeFile* EnsureFile(const std::string& file, CodeDir* dir = nullptr);
  C:/Users/gregu/Documents/tsf/tsf/ct/Library.h(91):    word Assign(const std::string& name,
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParmRegistry.h(79):    void AddMainArg(const std::string& arg);
  C:/Users/gregu/Documents/tsf/tsf/nb/Class.h(98):    virtual Object* New(size_t size);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h(57):    word Report(word rc, const std::string& expl, col_t indent = 2);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h(181):    const CliCommand* ParseCommand();
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(120):    bool Exq(T& elem)
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.h(100):    void StartInterval(bool first);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.h(40):    bool Validate(const void* addr);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(126):    DelayRc Delay(msecs_t msecs);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(132):    bool Interrupt();
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(103):    bool Interrupt(const Flags& mask = Flags());
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(494):    void SetTrap(bool on);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(502):    void StackCheck();
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(514):    void SetSignal(signal_t sig);
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadRegistry.h(97):    void AssociateIds(const Thread& thread);
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h(98):    virtual void ClaimBlocks() { }
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h(62):    FunctionStats* EnsureRecord(fn_name_arg func, size_t count);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h(145):    virtual IoThread* CreateIoThread();
  C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.h(60):    void ReleaseResources();
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureRegistry.h(42):    void Audit();
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(144):    bool StopTimer(const Base& owner, TimerId tid);
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h(135):    virtual bool ScreenIcMsgs(Q1Way< Message >& msgq);
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(133):    void KickThread();
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(137):    Context* FindWork();
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(161):    void Requeue(Context& ctx);
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(169):    void ScheduledOut();
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(110):    void SetSignal(SignalId sid);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(114):    void SetJoin(bool join);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(225):    void SetProtocol(ProtocolId prid);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(229):    void SetPriority(Priority prio);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(233):    virtual void SetReceiver(const GlobalAddress& receiver);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(237):    virtual void SetSender(const GlobalAddress& sender);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(362):    void SetRxAddr(const LocalAddress& rxaddr);
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h(104):    void StopTimer(const Base& owner, TimerId tid);
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(173):    virtual EventHandler::Rc ProcessInitNack
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(223):    EventHandler::Rc ProcessSsmqSap
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h(234):    void ProcessSsmqSnp(ServiceSM* modifier, Event& snpEvent);
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(64):    virtual SbIpBufferPtr Parse() = 0;
  C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h(71):    virtual SbIpBufferPtr Build() = 0;
  C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h(250):    void UpdateTestPsm();
W084 Function could be free
  C:/Users/gregu/Documents/tsf/tsf/an/AnModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(152):    static const char* strState(State state);
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.h(72):    static void DisplayStateCounts
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(86):    static bool IsValidDN(DN dn) { return ((dn >= FirstDN) && (dn <= LastDN)); }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(102):    static bool IsValidSC(SC sc) { return ((sc >= FirstSC) && (sc <= LastSC)); }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(106):    static uint32_t DNToIndex(Address::DN dn) { return dn - FirstDN + 1; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(110):    static Address::DN IndexToDN(uint32_t i) { return i + FirstDN - 1; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h(161):    static bool IsValidDigit(Digit d)
  C:/Users/gregu/Documents/tsf/tsf/cb/CbModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/cn/CnModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.h(73):    static bool IsCodeFile(const std::string& name);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(66):    word AddForward(string& item, string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(67):    word RemoveForward(string& item, string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(68):    word RemoveUsing(string& item, string& expl);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(74):    static void InsertInclude(const string& include, stringVector& list);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(75):    static bool EraseInclude(const string& include, stringVector& list);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(453):    static word FindWarning(const WarningLog& log);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(465):    static std::string WarningCode(Warning warning);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(469):    static bool IsSortedByFile
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(474):    static bool IsSortedByWarning
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h(243):    static void GenerateReport(std::ostream& stream, const SetOfIds& set);
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeIncrement.cpp(96):    static LibrarySet* Evaluate(CliThread& cli);
  C:/Users/gregu/Documents/tsf/tsf/ct/CtModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(166):    static Function* FoundFunc
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h(551):    static size_t CreateCodeError(const std::string& name, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(274):    static void ContextFunctionIsNonConst();
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h(570):    static void Startup(RestartLevel level) { }
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1236):    static TypeMatch MatchTemplate
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h(1249):    static Function* InstantiateError
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(263):    static void ShrinkExpression(const ExprPtr& expr);
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h(576):    static void PushType(const std::string& name);
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(36):    static const OperatorInfo* GetAttrs(LibTokenType type);
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.h(49):    static bool IsOperator(const std::string& s);
  C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.h(47):    static bool IsValidIdentifier(const std::string& id);
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(167):    static word Counted(std::string& result, const size_t* count);
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h(172):    static word Shown(std::string& result);
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(384):    static bool SetCompoundType
  C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h(571):    static std::string Indent();
  C:/Users/gregu/Documents/tsf/tsf/mb/MbModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/mb/Switch.h(50):    static bool IsValidPort(PortId pid)
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.h(61):    static fixed_string ValidTrueChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.h(66):    static fixed_string ValidFalseChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.h(62):    static const std::string& ValidNameChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.h(67):    static const std::string& ValidValueChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.h(72):    static const std::string& ValidBlankChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommand.h(117):    static Rc Exhausted(CliThread& cli, const std::string& type);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.h(48):    static void DescendTo(CliCookie& cookie, size_t index);
  C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h(307):    static Rc Mismatch(CliThread& cli, const std::string& type);
  C:/Users/gregu/Documents/tsf/tsf/nb/CoutThread.h(32):    static void Spool(const char* s, bool eol = false);
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(66):    static void Assert(bool condition, debug32_t errval = 0)
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(77):    static void Progress(const std::string& s, bool eol, bool force = false);
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(81):    static void noop();
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h(125):    static void GenerateSwLog(fn_name_arg func, const std::string& errstr,
  C:/Users/gregu/Documents/tsf/tsf/nb/Element.h(31):    static std::string strTimePlace();
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.h(29):    static ostringstreamPtr CreateStream();
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.h(42):    static void Spool(const std::string& name,
  C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.h(47):    static void Truncate(const std::string& name);
  C:/Users/gregu/Documents/tsf/tsf/nb/Log.h(25):    static ostringstreamPtr Create(fixed_string title);
  C:/Users/gregu/Documents/tsf/tsf/nb/Log.h(30):    static void Spool(ostringstreamPtr& log);
  C:/Users/gregu/Documents/tsf/tsf/nb/Log.h(34):    static std::string FileName();
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(136):    static size_t Size();
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(29):    static size_t Align(size_t size, size_t log2align = BYTES_PER_WORD_LOG2);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(33):    static size_t Words(size_t nBytes);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(37):    static void Copy(void* dest, const void* source, size_t nBytes);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(41):    static void Set(void* dest, byte_t value, size_t nBytes);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(59):    static void* Realloc(void* addr, size_t nBytes);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(68):    static MemoryType Type(const void* addr);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(76):    static void Shutdown(RestartLevel level);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(84):    static SysHeap* EnsureHeap(MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h(88):    static SysHeap* AccessHeap(MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/MemoryTrace.h(42):    static const char* TypeString(MemoryType type);
  C:/Users/gregu/Documents/tsf/tsf/nb/ModuleRegistry.h(72):    static RestartLevel NextLevel();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(742):    static word DisplayHelpFile(CliThread& cli, const string& name);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp(1878):    static void SendAckToOutputFile(const CliThread& cli);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbModule.h(45):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.h(58):    static TraceRc SelectThread(ThreadId tid, TraceStatus status);
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.h(62):    static bool ThreadsEmpty();
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.h(98):    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid);
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h(242):    static ObjectBlock* ObjToBlock(const Pooled* obj);
  C:/Users/gregu/Documents/tsf/tsf/nb/PermanentHeap.h(26):    static PermanentHeap* Instance();
  C:/Users/gregu/Documents/tsf/tsf/nb/Restart.h(65):    static void Initiate(reinit_t reason, debug32_t errval);
  C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.h(37):    static const std::string& ValidNameChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.h(42):    static const std::string& InvalidInitialChars();
  C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.h(72):    static void DisplayHeaps(std::ostream& stream);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h(22):    static void CreateNativeSignals();
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(37):    static SysThreadId RunningThreadId();
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(97):    static SysThread_t Wrap();
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(101):    static void Delete(SysThread_t& thread);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(106):    static SysSentry_t CreateSentry();
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h(110):    static void DeleteSentry(SysSentry_t& sentry);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h(73):    static bool IsLeapYear(int16_t year);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h(138):    static const int16_t* DaysPerMonth(int16_t year);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(73):    static void CaptureEvent(fn_name_arg func, Id rid, word info = 0);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(91):    static void PauseOver(word limit);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(205):    static double PercentIdle();
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(209):    static TraceRc LogContextSwitches(bool on);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(213):    static void DisplayContextSwitches(std::ostream& stream);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h(424):    static SysThread::Priority FactionToPriority(Faction& faction);
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(75):    static int WarpFactor();
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h(68):    static void CheckHigh(FunctionStats*& high, FunctionStats* curr,
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3285):    static void UseBadPointer();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3286):    static void LoopForever();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/nt/NtTestData.h(30):    static NtTestData* Access(CliThread& cli);
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h(149):    static size_t BuffSize(size_t nBytes);
  C:/Users/gregu/Documents/tsf/tsf/nw/NwModule.h(45):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(50):    static SysIpL2Addr LoopbackAddr();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h(66):    static bool HostName(std::string& name);
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(113):    static bool StartLayer();
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h(117):    static void StopLayer();
  C:/Users/gregu/Documents/tsf/tsf/on/OnModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/pb/PbModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/rn/RnModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(107):    static void Kill(fn_name_arg func, debug64_t errval, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.h(112):    static void Dump(fn_name_arg func, debug64_t errval, debug32_t offset);
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(41):    static bool IsValidId(Id eid)
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.h(57):    static bool AppCanHandle(Id eid)
  C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h(71):    static bool AppCanRegister(Id ehid)
  C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h(79):    static bool AppCanUse(Id ehid)
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(173):    static bool GenerateLog(Factory::Rc rc);
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h(185):    static TransTrace* TraceRxNet(Message& msg, const Factory& fac);
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.h(274):    static const char* strPriority(Priority p);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgFactory.h(43):    static void CaptureMsg(Context& ctx, const Message& msg, TransTrace* tt);
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.h(172):    static MsgPort* FindPeer(const GlobalAddress& remAddr);
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h(134):    static const char* ExplainRc(TestRc rc);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbModule.h(47):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(228):    static std::string OutputId(const std::string& label, id_t id);
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h(469):    static void DisplayEvent(std::ostream& stream, ServiceId sid, EventId eid);
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.h(58):    static bool IsValidPortId(PortId pid)
  C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h(45):    static bool IsValidId(Id sid)
  C:/Users/gregu/Documents/tsf/tsf/sb/SsmContext.h(73):    static RootServiceSM* AllocRoot(const Message& msg, ProtocolSM& psm);
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(210):    static MsgSize Pad(MsgSize size)
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(287):    inline static fn_name TlvMessage_FindType()
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(289):    inline static fn_name TlvMessage_AddType()
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(291):    inline static fn_name TlvMessage_CopyType()
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h(293):    inline static fn_name TlvMessage_VerifyParm()
  C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.h(57):    static Id ExtractPid(const TlvParmLayout& parm);
  C:/Users/gregu/Documents/tsf/tsf/sb/Trigger.h(59):    static bool IsValidId(Id tid)
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp(440):    static EventHandler::Rc SendFacilityNack
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(122):    static void SendRelease(const Message& msg1);
  C:/Users/gregu/Documents/tsf/tsf/sn/SnModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/st/StModule.h(43):    static bool Register();
  C:/Users/gregu/Documents/tsf/tsf/st/StTestData.h(32):    static StTestData* Access(CliThread& cli);
W091 Line contains adjacent spaces
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(64):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(65):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(66):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(67):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(69):    CauseInfo*    cci;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(121):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(122):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(123):    auto       sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(124):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(166):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(167):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(168):    auto       sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(169):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(200):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(201):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(202):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(203):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp(205):    CauseInfo*    cci;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(525):    id_t        idx;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(526):    word        fid, rid;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(528):    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(557):    TestRc       rc;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(558):    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(560):    id_t         idx;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(561):    word         fid, rid;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(903):    auto          state = GetState();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(904):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(905):    auto          sig = tmsg.GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(906):    TimeoutInfo*  toi = nullptr;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(908):    auto          err = true;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(909):    debug64_t     error;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1033):    auto          state = GetState();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1034):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1035):    auto          sig = msg.GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1037):    auto          err = true;
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(1038):    debug64_t     error;
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(408):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(409):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(410):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(411):    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp(413):    CauseInfo*    cci;
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(83):    CxxWord("-",   "-",    "D",  F),  // AUTO
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(84):    CxxWord("-",   "-",    "b",  T),  // BREAK
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(85):    CxxWord("-",   "-",    "c",  T),  // CASE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(86):    CxxWord("C",   "C",    "-",  T),  // CLASS
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(87):    CxxWord("DP",  "DP",   "D",  F),  // CONST
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(88):    CxxWord("DP",  "DP",   "D",  F),  // CONSTEXPR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(89):    CxxWord("-",   "-",    "n",  T),  // CONTINUE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(90):    CxxWord("-",   "-",    "o",  T),  // DEFAULT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(91):    CxxWord("-",   "-",    "d",  T),  // DO
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(92):    CxxWord("E",   "E",    "E",  T),  // ENUM
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(93):    CxxWord("-",   "P",    "-",  F),  // EXPLICIT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(94):    CxxWord("DP",  "-",    "-",  T),  // EXTERN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(95):    CxxWord("-",   "-",    "f",  T),  // FOR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(96):    CxxWord("-",   "F",    "-",  T),  // FRIEND
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(97):    CxxWord("H",   "H",    "H",  F),  // HASH
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(98):    CxxWord("-",   "-",    "i",  T),  // IF
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(99):    CxxWord("P",   "P",    "-",  T),  // INLINE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(100):    CxxWord("-",   "D",    "-",  F),  // MUTABLE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(101):    CxxWord("N",   "-",    "-",  T),  // NAMESPACE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(102):    CxxWord("-",   "P",    "-",  F),  // OPERATOR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(103):    CxxWord("-",   "A",    "-",  T),  // PRIVATE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(104):    CxxWord("-",   "A",    "-",  T),  // PROTECTED
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(105):    CxxWord("-",   "A",    "-",  T),  // PUBLIC
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(106):    CxxWord("-",   "-",    "r",  T),  // RETURN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(107):    CxxWord("D",   "DP",   "D",  F),  // STATIC
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(108):    CxxWord("C",   "C",    "-",  T),  // STRUCT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(109):    CxxWord("-",   "-",    "s",  T),  // SWITCH
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(110):    CxxWord("DCP", "DCFP", "-",  F),  // TEMPLATE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(111):    CxxWord("-",   "-",    "t",  T),  // TRY
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(112):    CxxWord("T",   "T",    "T",  T),  // TYPEDEF
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(113):    CxxWord("C",   "C",    "-",  T),  // UNION
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(114):    CxxWord("U",   "U",    "U",  T),  // USING
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(115):    CxxWord("-",   "P",    "-",  F),  // VIRTUAL
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(116):    CxxWord("-",   "-",    "w",  T),  // WHILE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(117):    CxxWord("-",   "P",    "-",  F),  // NVDTOR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(118):    CxxWord("DP",  "DP",   "xD", F)   // NIL_KEYWORD
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(140):    CxxOp(           SCOPE_STR, 2, 18, F, F, F),  // SCOPE_RESOLUTION
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(141):    CxxOp(                 ".", 2, 17, F, F, F),  // REFERENCE_SELECT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(142):    CxxOp(                "->", 2, 17, T, F, F),  // POINTER_SELECT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(143):    CxxOp(                 "[", 2, 17, T, F, F),  // ARRAY_SUBSCRIPT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(144):    CxxOp(                 "(", 0, 17, F, F, F),  // FUNCTION_CALL
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(145):    CxxOp(                "++", 1, 17, T, F, F),  // POSTFIX_INCREMENT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(146):    CxxOp(                "--", 1, 17, T, F, F),  // POSTFIX_DECREMENT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(147):    CxxOp(         DEFINED_STR, 1, 17, F, F, F),  // DEFINED
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(148):    CxxOp(          TYPEID_STR, 1, 17, F, F, F),  // TYPE_NAME
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(149):    CxxOp(      CONST_CAST_STR, 2, 17, F, F, F),  // CONST_CAST
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(150):    CxxOp(    DYNAMIC_CAST_STR, 2, 17, F, F, F),  // DYNAMIC_CAST
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(152):    CxxOp(     STATIC_CAST_STR, 2, 17, F, F, F),  // STATIC_CAST
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(153):    CxxOp(          SIZEOF_STR, 1, 16, F, T, F),  // SIZEOF_TYPE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(154):    CxxOp(                "++", 1, 16, T, T, F),  // PREFIX_INCREMENT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(155):    CxxOp(                "--", 1, 16, T, T, F),  // PREFIX_DECREMENT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(156):    CxxOp(                 "~", 1, 16, T, T, F),  // ONES_COMPLEMENT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(157):    CxxOp(                 "!", 1, 16, T, T, F),  // LOGICAL_NOT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(158):    CxxOp(                 "+", 1, 16, T, T, F),  // UNARY_PLUS
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(159):    CxxOp(                 "-", 1, 16, T, T, F),  // UNARY_MINUS
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(160):    CxxOp(                 "&", 1, 16, T, T, F),  // ADDRESS_OF
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(161):    CxxOp(                 "*", 1, 16, T, T, F),  // INDIRECTION
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(162):    CxxOp(             NEW_STR, 0, 16, T, T, F),  // OBJECT_CREATE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(163):    CxxOp(       NEW_ARRAY_STR, 0, 16, T, T, F),  // OBJECT_CREATE_ARRAY
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(164):    CxxOp(          DELETE_STR, 1, 16, T, T, F),  // OBJECT_DELETE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(165):    CxxOp(    DELETE_ARRAY_STR, 1, 16, T, T, F),  // OBJECT_DELETE_ARRAY
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(166):    CxxOp(                 "(", 2, 16, T, T, F),  // CAST
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(167):    CxxOp(                ".*", 2, 15, F, F, F),  // REFERENCE_SELECT_MEMBER
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(168):    CxxOp(               "->*", 2, 15, T, F, F),  // POINTER_SELECT_MEMBER
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(169):    CxxOp(                 "*", 2, 14, T, F, T),  // MULTIPLY
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(170):    CxxOp(                 "/", 2, 14, T, F, F),  // DIVIDE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(171):    CxxOp(                 "%", 2, 14, T, F, F),  // MODULO
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(172):    CxxOp(                 "+", 2, 13, T, F, T),  // ADD
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(173):    CxxOp(                 "-", 2, 13, T, F, F),  // SUBTRACT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(174):    CxxOp(                "<<", 2, 12, T, F, F),  // LEFT_SHIFT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(175):    CxxOp(                ">>", 2, 12, T, F, F),  // RIGHT_SHIFT
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(176):    CxxOp(                 "<", 2, 11, T, F, T),  // LESS
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(177):    CxxOp(                "<=", 2, 11, T, F, T),  // LESS_OR_EQUAL
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(178):    CxxOp(                 ">", 2, 11, T, F, T),  // GREATER
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(179):    CxxOp(                ">=", 2, 11, T, F, T),  // GREATER_OR_EQUAL
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(180):    CxxOp(                "==", 2, 10, T, F, T),  // EQUALITY
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(181):    CxxOp(                "!=", 2, 10, T, F, T),  // INEQUALITY
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(182):    CxxOp(                 "&", 2,  9, T, F, T),  // BITWISE_AND
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(183):    CxxOp(                 "^", 2,  8, T, F, T),  // BITWISE_XOR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(184):    CxxOp(                 "|", 2,  7, T, F, T),  // BITWISE_OR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(185):    CxxOp(                "&&", 2,  6, T, F, T),  // LOGICAL_AND
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(186):    CxxOp(                "||", 2,  5, T, F, T),  // LOGICAL_OR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(187):    CxxOp(                 "?", 3,  4, F, F, F),  // CONDITIONAL
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(188):    CxxOp(                 "=", 2,  3, T, T, F),  // ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(189):    CxxOp(                "*=", 2,  3, T, T, F),  // MULTIPLY_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(190):    CxxOp(                "/=", 2,  3, T, T, F),  // DIVIDE_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(191):    CxxOp(                "%=", 2,  3, T, T, F),  // MODULO_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(192):    CxxOp(                "+=", 2,  3, T, T, F),  // ADD_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(193):    CxxOp(                "-=", 2,  3, T, T, F),  // SUBTRACT_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(194):    CxxOp(               "<<=", 2,  3, T, T, F),  // LEFT_SHIFT_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(195):    CxxOp(               ">>=", 2,  3, T, T, F),  // RIGHT_SHIFT_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(196):    CxxOp(                "&=", 2,  3, T, T, F),  // BITWISE_AND_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(197):    CxxOp(                "^=", 2,  3, T, T, F),  // BITWISE_XOR_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(198):    CxxOp(                "|=", 2,  3, T, T, F),  // BITWISE_OR_ASSIGN
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(199):    CxxOp(           THROW_STR, 0,  2, F, T, F),  // THROW
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(200):    CxxOp(                 ",", 2,  1, F, F, F),  // STATEMENT_SEPARATOR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(201):    CxxOp(                 "$", 0,  0, F, F, F),  // START_OF_EXPRESSION
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(202):    CxxOp(           ERROR_STR, 0,  0, F, F, F),  // FALSE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(203):    CxxOp(           ERROR_STR, 0,  0, F, F, F),  // TRUE
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(204):    CxxOp(           ERROR_STR, 0,  0, F, F, F),  // NULLPTR
  C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp(205):    CxxOp(           ERROR_STR, 0,  0, F, F, F)   // NIL_OPERATOR
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(78):    OperatorInfo(" ",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpNil
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(79):    OperatorInfo("(",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpLeftPar
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(80):    OperatorInfo(")",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpRightPar
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(81):    OperatorInfo("&",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpIntersection
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(82):    OperatorInfo("-",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpDifference
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(83):    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpUnion
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(84):    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpAutoUnion
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(85):    OperatorInfo("d",  1, DIR_SET,  FILE_SET, ERR_SET),   // OpDirectories
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp(86):    OperatorInfo("f",  1, FILE_SET, DIR_SET,  ERR_SET),   // OpFiles
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(238):    inline static fn_name Array_ctor()     { return "Array.ctor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(239):    inline static fn_name Array_dtor()     { return "Array.dtor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(240):    inline static fn_name Array_Init()     { return "Array.Init"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(241):    inline static fn_name Array_Reserve()  { return "Array.Reserve"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(243):    inline static fn_name Array_Erase()    { return "Array.Erase"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(244):    inline static fn_name Array_Replace()  { return "Array.Replace"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Array.h(245):    inline static fn_name Array_Extend()   { return "Array.Extend"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(159): typedef std::basic_string<char, CharTraits, DynAllocator<char>>  DynString;
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h(160): typedef std::basic_string<char, CharTraits, ImmAllocator<char>>  ImmString;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(80):    CounterPtr      allocCount_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(81):    CounterPtr      freeCount_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(82):    CounterPtr      failCount_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(83):    CounterPtr      auditCount_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(372):    inline static fn_name Q1Way_ctor()   { return "Q1Way.ctor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(373):    inline static fn_name Q1Way_dtor()   { return "Q1Way.dtor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(374):    inline static fn_name Q1Way_Init()   { return "Q1Way.Init"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(375):    inline static fn_name Q1Way_Enq()    { return "Q1Way.Enq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(376):    inline static fn_name Q1Way_Henq()   { return "Q1Way.Henq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(378):    inline static fn_name Q1Way_Deq()    { return "Q1Way.Deq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(379):    inline static fn_name Q1Way_Exq()    { return "Q1Way.Exq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(380):    inline static fn_name Q1Way_Next()   { return "Q1Way.Next"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(381):    inline static fn_name Q1Way_Count()  { return "Q1Way.Count"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(382):    inline static fn_name Q1Way_Purge()  { return "Q1Way.Purge"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h(383):    inline static fn_name Q1Way_Item()   { return "Q1Way.Item"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(345):    inline static fn_name Q2Way_ctor()  { return "Q2Way.ctor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(346):    inline static fn_name Q2Way_dtor()  { return "Q2Way.dtor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(347):    inline static fn_name Q2Way_Init()  { return "Q2Way.Init"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(348):    inline static fn_name Q2Way_Enq()   { return "Q2Way.Enq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(349):    inline static fn_name Q2Way_Henq()  { return "Q2Way.Henq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(350):    inline static fn_name Q2Way_Deq()   { return "Q2Way.Deq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(351):    inline static fn_name Q2Way_Exq()   { return "Q2Way.Exq"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(352):    inline static fn_name Q2Way_Next()  { return "Q2Way.Next"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(353):    inline static fn_name Q2Way_Prev()  { return "Q2Way.Prev"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h(356):    inline static fn_name Q2Way_Item()  { return "Q2Way.Item"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(610):    inline static fn_name Registry_ctor()   { return "Registry.ctor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(611):    inline static fn_name Registry_dtor()   { return "Registry.dtor"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(612):    inline static fn_name Registry_Init()   { return "Registry.Init"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(614):    inline static fn_name Registry_Erase()  { return "Registry.Erase"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(615):    inline static fn_name Registry_Next()   { return "Registry.Next"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(616):    inline static fn_name Registry_Prev()   { return "Registry.Prev"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(617):    inline static fn_name Registry_Size()   { return "Registry.Size"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(618):    inline static fn_name Registry_Empty()  { return "Registry.Empty"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(619):    inline static fn_name Registry_Purge()  { return "Registry.Purge"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h(620):    inline static fn_name Registry_Cell()   { return "Registry.Cell"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/Singleton.h(111):       Singleton_Destroy()  { return "Singleton.Destroy"; }
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.cpp(24): fixed_string StatisticsGroup::ReportHeader =   "      Curr      Prev         All";
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(249):    CounterPtr       traps_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(250):    CounterPtr       yields_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(251):    CounterPtr       exceeds_;
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(255):    AccumulatorPtr   totUsecs_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(161):    CfgIntParmPtr  initTimeoutMsecs_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(162):    CfgIntParmPtr  schedTimeoutMsecs_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(164):    CfgIntParmPtr  rtcTimeoutMsecs_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(166):    CfgIntParmPtr  rtcLimit_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(167):    CfgIntParmPtr  rtcInterval_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(169):    CfgIntParmPtr  trapLimit_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(170):    CfgIntParmPtr  trapInterval_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(172):    CfgIntParmPtr  stackUsageLimit_;
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h(173):    CfgIntParmPtr  stackCheckInterval_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(40):    CounterPtr       recvs_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(41):    AccumulatorPtr   bytesRcvd_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(44):    CounterPtr       discards_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(45):    CounterPtr       rejects_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(46):    CounterPtr       sends_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(47):    AccumulatorPtr   bytesSent_;
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(49):    CounterPtr       overflows_;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(575):    id_t             index;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(576):    word             sid, ind;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(578):    auto&            pmsg = static_cast< PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(638):    TestRc            rc;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(639):    auto&             pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(641):    id_t              index;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(642):    word              sid, ind;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(744):    word           port;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(746):    auto&          pmsg = static_cast< PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(771):    TestRc          rc;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(772):    auto&           pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(773):    word            port;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(865):    TestRc        rc;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(866):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(868):    bool          ring = false;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(869):    auto          exists = false;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(953):    TestRc        rc;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(954):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(956):    string        scan;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(957):    auto          digits = false;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(958):    auto          flash = false;
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(959):    auto          exists = false;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(34):    CounterPtr       icMsgsIntra_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(35):    CounterPtr       icMsgsInter_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(37):    CounterPtr       ogMsgsIntra_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(38):    CounterPtr       ogMsgsInter_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(40):    CounterPtr       contexts_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(41):    CounterPtr       msgsDeleted_;
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(42):    CounterPtr       ctxsDeleted_;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(49):    CounterPtr       requeues_;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(50):    CounterPtr       trojans_;
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(51):    CounterPtr       lockouts_;
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(29):    LocalAddress      txAddr;         // source address
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(30):    LocalAddress      rxAddr;         // destination address
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(32):    bool              initial  : 1;   // true for initial message
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(33):    bool              final    : 1;   // true for final message
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(34):    bool              join     : 1;   // true to create PSM and join root SSM
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(35):    bool              self     : 1;   // true for message to self
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(36):    bool              injected : 1;   // true if sent by InjectCommand
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(37):    bool              kill     : 1;   // true to kill context on arrival
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(38):    uint8_t           spare    : 6;   // reserved for future use
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(39):    Message::Route    route    : 2;   // the route that the message took
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(40):    ProtocolId        protocol : 16;  // message's protocol
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(41):    SignalId          signal   : 16;  // message's signal
  C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h(42):    MsgSize           length   : 16;  // total bytes in all parameters
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(118):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(119):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(120):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(121):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(123):    CauseInfo*    cci;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(229):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(230):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(231):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(232):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(234):    CauseInfo*    cci;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(297):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(298):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(299):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(300):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(302):    CauseInfo*    cci;
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(342):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(343):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(344):    auto          sid = msg->GetSignal();
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(345):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp(347):    CauseInfo*    cci;
W094 Line length exceeds the standard maximum
  C:/Users/gregu/Documents/tsf/tsf/cb/BcSsm.cpp(285):    for(auto s = BcState::AuthorizingOrigination; s <= BcState::OrigAlerting; ++s)
W095 Function not sorted in standard order
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.cpp(271): bool IsUnusedItemWarning(Warning warning)
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.cpp(61): char NodeBase::FactionChar(Faction faction)
  C:/Users/gregu/Documents/tsf/tsf/nb/ToolTypes.cpp(53): ostream& operator<<(std::ostream& stream, TraceStatus status)
W098 Function does not invoke Debug::ft
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfIpService.cpp(83): Faction PotsShelfIpService::GetFaction() const { return PayloadFaction; }
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfIpService.cpp(96): ipport_t PotsShelfIpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfIpService.cpp(100): size_t PotsShelfIpService::RxSize() const { return IoThread::MaxRxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfIpService.cpp(104): size_t PotsShelfIpService::TxSize() const { return IoThread::MaxTxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(1372): void PotsTrafficThread::RecordHoldingTime(secs_t secs)
  C:/Users/gregu/Documents/tsf/tsf/cb/BcCause.cpp(108): CliParm* CauseParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProgress.cpp(94): CliParm* ProgressParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(250): Faction CipUdpService::GetFaction() const { return PayloadFaction; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(260): ipport_t CipUdpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(264): size_t CipUdpService::RxSize() const { return IoThread::MaxRxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(268): size_t CipUdpService::TxSize() const { return IoThread::MaxTxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(345): Faction CipTcpService::GetFaction() const { return PayloadFaction; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(349): size_t CipTcpService::MaxBacklog() const { return 200; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(353): size_t CipTcpService::MaxConns() const { return TcpIoThread::MaxConns; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(363): ipport_t CipTcpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(367): size_t CipTcpService::RxSize() const { return IoThread::MaxRxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(371): size_t CipTcpService::TxSize() const { return IoThread::MaxTxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(417): CliText* CipIamSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(431): CliText* CipCpgSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(445): CliText* CipAnmSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(459): CliText* CipRelSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(503): CliParm* CipRouteParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(607): CliParm* CipCallingParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(631): CliParm* CipCalledParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(657): CliParm* CipOriginalCallingParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp(683): CliParm* CipOriginalCalledParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/cb/DigitString.cpp(154): Digit DigitString::GetDigit(DigitCount i) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.cpp(103): bool CodeDir::IsSubsDir() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(619): bool CodeInfo::IsSortedByFile(const WarningLog& log1, const WarningLog& log2)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(633): bool CodeInfo::IsSortedByWarning(const WarningLog& log1, const WarningLog& log2)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1681): size_t CodeFile::GetLineNum(size_t pos) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1705): LineType CodeFile::GetLineType(size_t n) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1713): bool CodeFile::GetNthLine(size_t n, string& s) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1813): void CodeFile::InsertClass(Class* cls)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1821): void CodeFile::InsertData(Data* data)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1829): bool CodeFile::InsertDirective(DirectivePtr& dir)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1838): void CodeFile::InsertEnum(Enum* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1846): void CodeFile::InsertForw(Forward* forw)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1854): void CodeFile::InsertFunc(Function* func)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1862): void CodeFile::InsertInclude(IncludePtr& incl)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1871): Include* CodeFile::InsertInclude(const string& fn)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1889): void CodeFile::InsertMacro(Macro* macro)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1897): void CodeFile::InsertType(Typedef* type)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp(1905): void CodeFile::InsertUsing(UsingPtr& use)
  C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.cpp(271): bool IsUnusedItemWarning(Warning warning)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(250): void Class::AccessibilityTo(const CxxScope* scope, SymbolView* view) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(359): void Class::AddItem(CxxNamed* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1358): Class* Class::GetTemplate() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1613): Class* Class::OuterClass() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(1620): bool Class::SetCurrAccess(Cxx::Access access)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(2290): Function* CxxArea::FoundFunc(Function* func, SymbolView* view, TypeMatch match)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp(2298): const FunctionPtrVector* CxxArea::FuncVector(const string& name) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.cpp(32): void AlignLeft(ostream& stream, const string& prefix)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.cpp(135): CxxToken* Define::AutoType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(237): bool Context::OptionIsOn(char opt)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(244): bool Context::ParsingTemplateInstance()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(384): void Context::Trace(CxxTrace::Action act)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(392): void Context::Trace(CxxTrace::Action act, const StackArg& arg)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(400): void Context::Trace(CxxTrace::Action act, word err, const string& expl)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(408): void Context::Trace(CxxTrace::Action act, const CodeFile& file)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(416): void Context::Trace(CxxTrace::Action act, const CxxToken* token)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(424): void Context::WasCalled(Function* func)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(591): OptionalCode* ParseFrame::Optional() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp(778): CxxScope* ParseFrame::Scope() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(133): CxxArea* CxxNamed::GetArea() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(142): Class* CxxNamed::GetClass() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(151): id_t CxxNamed::GetDeclFid() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(160): Namespace* CxxNamed::GetSpace() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(169): const TemplateParms* CxxNamed::GetTemplateParms() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(178): bool CxxNamed::IsInTemplateInstance() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(492): void CxxNamed::strName(ostream& stream, bool fq, const QualName* name) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(889): Numeric DataSpec::GetNumeric() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(909): CxxScope* DataSpec::GetScope() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(918): TypeTags DataSpec::GetTags() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(925): TypeSpec* DataSpec::GetTypeSpec() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1068): bool DataSpec::IsAutoDecl() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1871): CxxNamed* QualName::DirectType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(1926): CxxScoped* QualName::GetForward() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2063): TypeName* QualName::Names_at(size_t index) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2072): TypeName* QualName::Names_back() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2079): size_t QualName::Names_size() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2826): void TypeSpec::AddArray(ArraySpecPtr& array)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2833): void TypeSpec::AdjustPtrs(TagCount count)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2848): TagCount TypeSpec::ArrayCount() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2856): TagCount TypeSpec::Arrays() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2864): TypeSpec* TypeSpec::Clone() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2886): void TypeSpec::EnterArrays() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2893): void TypeSpec::EnteringScope(const CxxScope* scope)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2900): TypeTags TypeSpec::GetTags() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2910): bool TypeSpec::HasArrayDefn() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2918): void TypeSpec::Instantiating() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2925): bool TypeSpec::MatchesExactly(const TypeSpec* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2933): TypeMatch TypeSpec::MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2942): TypeMatch TypeSpec::MatchTemplateArg(const TypeSpec* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2973): TagCount TypeSpec::PtrCount(bool arrays) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2981): TagCount TypeSpec::Ptrs(bool arrays) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2989): TagCount TypeSpec::RefCount() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(2997): TagCount TypeSpec::Refs() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3005): void TypeSpec::RemoveRefs()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3012): StackArg TypeSpec::ResultType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3020): void TypeSpec::SetArrayPos(int8_t pos)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3027): void TypeSpec::SetConst(bool readonly)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3034): void TypeSpec::SetConstPtr(bool constptr)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3052): void TypeSpec::SetPtrDetached(bool on)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3059): void TypeSpec::SetPtrs(TagCount ptrs)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3066): void TypeSpec::SetRefDetached(bool on)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3073): void TypeSpec::SetReferent(CxxNamed* ref, UsingMode mode)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp(3080): void TypeSpec::SetRefs(TagCount refs)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(98): bool Block::CrlfOver(Form form) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(217): CxxToken* Block::FirstStatement() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(225): Function* Block::GetFunction() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(264): bool Block::InLine() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(778): id_t CxxScope::GetDistinctDeclFid() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1374): bool Data::IsConst() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1382): bool Data::IsConstPtr() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(1507): bool Data::WasRead()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3033): Function* Function::FoundFunc
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3062): FunctionRole Function::FuncRole() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3098): FunctionType Function::FuncType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3108): void Function::GetDefnRange(size_t& begin, size_t& end) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3116): CxxScope* Function::GetScope() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3615): bool Function::IsInTemplateInstance() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(3993): void Function::SetDefnRange(size_t begin, size_t end)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4352): void FuncSpec::AddArray(ArraySpecPtr& array)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4359): void FuncSpec::AdjustPtrs(TagCount count)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4373): TagCount FuncSpec::ArrayCount() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4380): TagCount FuncSpec::Arrays() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4387): void FuncSpec::Check() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4395): TypeSpec* FuncSpec::Clone() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4417): void FuncSpec::EnterArrays() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4436): bool FuncSpec::FindReferent()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4444): TypeTags FuncSpec::GetTags() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4451): TypeName* FuncSpec::GetTemplateArgs() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4458): TypeSpec* FuncSpec::GetTypeSpec() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4465): bool FuncSpec::HasArrayDefn() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4472): void FuncSpec::Instantiating() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4480): bool FuncSpec::IsConst() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4487): bool FuncSpec::IsConstPtr() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4494): bool FuncSpec::MatchesExactly(const TypeSpec* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4502): TypeMatch FuncSpec::MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4512): TypeMatch FuncSpec::MatchTemplateArg(const TypeSpec* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4534): TagCount FuncSpec::PtrCount(bool arrays) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4541): TagCount FuncSpec::Ptrs(bool arrays) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4548): TagCount FuncSpec::RefCount() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4555): TagCount FuncSpec::Refs() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4562): void FuncSpec::RemoveRefs()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4569): StackArg FuncSpec::ResultType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4576): void FuncSpec::SetArrayPos(int8_t pos)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4584): void FuncSpec::SetConst(bool readonly)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4592): void FuncSpec::SetConstPtr(bool constptr)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4600): void FuncSpec::SetPtrDetached(bool on)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4608): void FuncSpec::SetPtrs(TagCount ptrs)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4616): void FuncSpec::SetRefDetached(bool on)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4624): void FuncSpec::SetReferent(CxxNamed* ref, UsingMode mode)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp(4632): void FuncSpec::SetRefs(TagCount refs)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(290): Class* BaseDecl::GetClass() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(391): void CxxScoped::AddFiles(SetOfIds& imSet) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(545): CodeFile* CxxScoped::GetImplFile() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(554): bool CxxScoped::GetScopedName(string& name, size_t n) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(563): bool CxxScoped::IsAuto() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(572): bool CxxScoped::IsConst() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(581): bool CxxScoped::IsConstPtr() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(590): bool CxxScoped::IsDeclaredInFunction() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(598): bool CxxScoped::IsDefinedIn(const CxxArea* area) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(611): bool CxxScoped::IsIndirect() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1126): void Enumerator::RecordAccess(Cxx::Access access) const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1190): CxxToken* Forward::AutoType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1365): CxxToken* Friend::AutoType() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1620): Function* Friend::GetFunction() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1629): QualName* Friend::GetQualName() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp(1638): CxxNamed* Friend::GetReferent() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.cpp(255): void CxxStatement::EnterBlock()
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.cpp(324): bool Do::InLine() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.cpp(520): bool For::InLine() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.cpp(614): bool If::InLine() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.cpp(978): bool While::InLine() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(75): template< typename T > void Erase(const CxxScoped* item,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(173): template< typename T > void ListSymbols(const string& name,
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(210): void CxxSymbols::EraseClass(const Class* cls)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(217): void CxxSymbols::EraseData(const Data* data)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(224): void CxxSymbols::EraseEnum(const Enum* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(231): void CxxSymbols::EraseEtor(const Enumerator* etor)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(238): void CxxSymbols::EraseForw(const Forward* forw)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(245): void CxxSymbols::EraseFriend(const Friend* frnd)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(252): void CxxSymbols::EraseFunc(const Function* func)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(281): void CxxSymbols::EraseMacro(const Macro* macro)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(288): void CxxSymbols::EraseSpace(const Namespace* space)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(295): void CxxSymbols::EraseTerm(const Terminal* term)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(302): void CxxSymbols::EraseType(const Typedef* type)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(647): void CxxSymbols::InsertClass(Class* cls)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(654): void CxxSymbols::InsertData(Data* data)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(661): void CxxSymbols::InsertEnum(Enum* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(668): void CxxSymbols::InsertEtor(Enumerator* etor)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(675): void CxxSymbols::InsertForw(Forward* forw)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(682): void CxxSymbols::InsertFriend(Friend* frnd)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(689): void CxxSymbols::InsertFunc(Function* func)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(723): void CxxSymbols::InsertMacro(Macro* macro)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(730): void CxxSymbols::InsertSpace(Namespace* space)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(737): void CxxSymbols::InsertTerm(Terminal* term)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp(744): void CxxSymbols::InsertType(Typedef* type)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(327): void CxxUsageSets::AddBase(const CxxNamed* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(335): void CxxUsageSets::AddDirect(const CxxNamed* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(343): void CxxUsageSets::AddForward(const CxxNamed* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(354): void CxxUsageSets::AddIndirect(const CxxNamed* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(362): void CxxUsageSets::AddUsing(const CxxNamed* item)
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(716): Numeric FloatLiteral::GetNumeric() const
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp(777): Numeric IntLiteral::GetNumeric() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibraryErrSet.cpp(87): word LibraryErrSet::Error(string& expl) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(60): LibrarySet* LibrarySet::AffectedBy() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(67): LibrarySet* LibrarySet::Affecters() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(74): LibrarySet* LibrarySet::Assign(LibrarySet* rhs)
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(92): LibrarySet* LibrarySet::CommonAffecters() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(142): LibrarySet* LibrarySet::Create(const string& name, SetOfIds* set) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(149): LibrarySet* LibrarySet::Difference(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(156): LibrarySet* LibrarySet::Directories() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(175): LibrarySet* LibrarySet::FileName(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(182): LibrarySet* LibrarySet::Files() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(189): LibrarySet* LibrarySet::FileType(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(207): LibrarySet* LibrarySet::FoundIn(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(226): LibrarySet* LibrarySet::Implements() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(233): LibrarySet* LibrarySet::Intersection(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(240): bool LibrarySet::IsReadOnly() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(247): bool LibrarySet::IsTemporary() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(274): LibrarySet* LibrarySet::MatchString(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(281): LibrarySet* LibrarySet::NeededBy() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(288): LibrarySet* LibrarySet::Needers() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(297): word LibrarySet::NotImplemented(string& expl) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(323): LibrarySet* LibrarySet::OpError() const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(439): LibrarySet* LibrarySet::Union(const LibrarySet* that) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(446): LibrarySet* LibrarySet::UsedBy(bool self) const
  C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp(453): LibrarySet* LibrarySet::Users(bool self) const
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.cpp(92): CliParm* MediaParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.cpp(244): MediaPsm* MediaPsm::GetOgPsm() const
  C:/Users/gregu/Documents/tsf/tsf/mb/Switch.cpp(82): Circuit* Switch::GetCircuit(PortId pid) const
  C:/Users/gregu/Documents/tsf/tsf/mb/ToneRegistry.cpp(64): Tone* ToneRegistry::GetTone(Tone::Id tid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.cpp(113): void Base::Nullify(size_t n)
  C:/Users/gregu/Documents/tsf/tsf/nb/Base.cpp(142): Base::vptr_t Base::Vptr() const
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.cpp(37): void CfgBitParm::Explain(string& expl) const
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgFlagParm.cpp(55): bool CfgFlagParm::GetCurrValue() const
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.cpp(57): void CfgIntParm::Explain(string& expl) const
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgParmRegistry.cpp(259): void CfgParmRegistry::ListParms(ostream& stream, const string& prefix) const
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.cpp(53): void CfgStrParm::Explain(string& expl) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ClassRegistry.cpp(64): Class* ClassRegistry::Lookup(ClassId cid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/CliCookie.cpp(121): size_t CliCookie::Index(size_t depth) const
  C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.cpp(353): CliAppData* CliThread::GetAppData(CliAppData::Id aid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.cpp(120): void Debug::Reset()
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionName.cpp(25): int FunctionName::compare(fn_name_arg func, const char* str)
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionName.cpp(32): size_t FunctionName::find(fn_name_arg func, const char* str)
  C:/Users/gregu/Documents/tsf/tsf/nb/FunctionName.cpp(41): size_t FunctionName::rfind(fn_name_arg func, const char* str)
  C:/Users/gregu/Documents/tsf/tsf/nb/InitFlags.cpp(13): bool InitFlags::AllowBreak()
  C:/Users/gregu/Documents/tsf/tsf/nb/InitFlags.cpp(24): bool InitFlags::CauseTimeout()
  C:/Users/gregu/Documents/tsf/tsf/nb/InitFlags.cpp(33): bool InitFlags::ImmediateTrace()
  C:/Users/gregu/Documents/tsf/tsf/nb/InitFlags.cpp(42): bool InitFlags::TraceInit()
  C:/Users/gregu/Documents/tsf/tsf/nb/InitFlags.cpp(53): bool InitFlags::TraceWork()
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(139): size_t SegmentHeader::Size()
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(156): SysHeap* Memory::AccessHeap(MemoryType type)
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(174): size_t Memory::Align(size_t size, size_t log2align)
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(240): SysHeap* Memory::EnsureHeap(MemoryType type)
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(294): const SysHeap* Memory::Heap(MemoryType type)
  C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp(388): size_t Memory::Words(size_t nBytes)
  C:/Users/gregu/Documents/tsf/tsf/nb/ModuleRegistry.cpp(137): Module* ModuleRegistry::GetModule(ModuleId mid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/MsgBuffer.cpp(59): TraceStatus MsgBuffer::GetStatus() const
  C:/Users/gregu/Documents/tsf/tsf/nb/NbCliParms.cpp(99): word ExplainTraceRc(CliThread& cli, TraceRc rc)
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.cpp(157): TraceStatus NbTracer::FactionStatus(Faction faction) const
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.cpp(30): char NodeBase::BlockingReasonChar(BlockingReason reason)
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.cpp(61): char NodeBase::FactionChar(Faction faction)
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.cpp(56): Object::ClassId Object::GetClassId() const
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.cpp(67): bool Object::GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid)
  C:/Users/gregu/Documents/tsf/tsf/nb/Object.cpp(94): Object::ObjectId Object::GetObjectId() const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(262): size_t ObjectPool::AllocCount() const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(428): bool ObjectPool::BidToIndices(Bid bid, size_t& i, size_t& j) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(683): size_t ObjectPool::FailCount() const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(728): size_t ObjectPool::FreeCount() const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(735): bool ObjectPool::IndicesToBid(size_t i, size_t j, Bid& bid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(747): size_t ObjectPool::InUseCount() const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(754): size_t ObjectPool::LowAvailCount() const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(761): ObjectBlock* ObjectPool::Next(Bid& bid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(780): Pooled* ObjectPool::NextUsed(Bid& bid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(853): ObjectPoolId ObjectPool::ObjPid(const Pooled* obj)
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(862): PooledObjectSeqNo ObjectPool::ObjSeq(const Pooled* obj)
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(871): ObjectBlock* ObjectPool::ObjToBlock(const Pooled* obj)
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPoolRegistry.cpp(274): ObjectPool* ObjectPoolRegistry::Pool(ObjectPoolId pid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/PermanentHeap.cpp(33): PermanentHeap* PermanentHeap::Instance()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(109): Flags PS_Break()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(114): Flags PS_Delayed()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(119): Flags PS_Exit()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(124): Flags PS_Final()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(129): Flags PS_Interrupt()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(134): Flags PS_Native()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(139): Flags PS_NoError()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(144): Flags PS_NoLog()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp(149): Flags PS_NoRecover()
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignalRegistry.cpp(42): Flags PosixSignalRegistry::Attrs(signal_t value) const
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignalRegistry.cpp(75): PosixSignal* PosixSignalRegistry::Find(signal_t value) const
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignalRegistry.cpp(87): PosixSignal* PosixSignalRegistry::Find(const string& name) const
  C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignalRegistry.cpp(138): signal_t PosixSignalRegistry::Value(const string& name) const
  C:/Users/gregu/Documents/tsf/tsf/nb/Q2Link.cpp(24): Q2Link::~Q2Link()
  C:/Users/gregu/Documents/tsf/tsf/nb/RegCell.cpp(24): RegCell::~RegCell()
  C:/Users/gregu/Documents/tsf/tsf/nb/RegCell.cpp(36): void RegCell::SetId(id_t cid)
  C:/Users/gregu/Documents/tsf/tsf/nb/Singletons.cpp(110): Singletons* Singletons::Instance()
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.cpp(102): uint64_t Statistic::Overall() const
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.cpp(243): uint64_t HighWatermark::Overall() const
  C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.cpp(319): uint64_t LowWatermark::Overall() const
  C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.cpp(132): StatisticsGroup* StatisticsRegistry::GetGroup(id_t gid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysConsole.cpp(17): std::istream& SysConsole::In()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysConsole.cpp(24): ostream& SysConsole::Out()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysMutex.cpp(33): Thread* SysMutex::Owner() const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(253): void SysThread::RegisterForSignal(signal_t sig, sighandler_t handler)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(280): SysThreadId SysThread::RunningThreadId()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(105): DWORD64 StackInfo::GetFrame(fn_depth depth)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(121): fn_depth StackInfo::GetFrames()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(129): void StackInfo::Shutdown()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(138): DWORD StackInfo::Startup()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp(249): fn_depth SysThreadStack::FuncDepth()
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.win.cpp(55): ticks_t SysTickTimer::TicksNow() const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(166): int16_t SysTime::DayOfWeek() const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(176): int16_t SysTime::DayOfYear() const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(192): const int16_t* SysTime::DaysPerMonth(int16_t year)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(200): size_t SysTime::DaysSinceT0() const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(230): bool SysTime::IsLeapYear(int16_t year)
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp(250): int64_t SysTime::MsecsSinceT0() const
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.cpp(15): uintptr_t BadPointer()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(14): bool ThisThread::EnterBlockingOperation(BlockingReason why, fn_name_arg func)
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(21): void ThisThread::ExitBlockingOperation(fn_name_arg func)
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(28): void ThisThread::MakePreemptable()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(35): void ThisThread::MakeUnpreemptable()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(42): void ThisThread::MemProtect()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(49): void ThisThread::MemUnprotect()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(56): DelayRc ThisThread::Pause(msecs_t msecs)
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(63): void ThisThread::PauseOver(word limit)
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(70): word ThisThread::RtcPercentUsed()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(77): ThreadId ThisThread::RunningThreadId()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(84): TraceRc ThisThread::StartTracing(bool immediate, bool autostop)
  C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp(91): void ThisThread::StopTracing()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(423): ContextSwitch* ContextSwitches::AddSwitch()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1136): TraceStatus Thread::CalcStatus(bool dynamic) const
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1517): main_t Thread::EnterThread(void* arg)
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1721): void Thread::FunctionInvoked(fn_name_arg func)
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1818): bool Thread::HasExited() const
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1881): bool Thread::IsLocked() const
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1888): Thread* Thread::LockedThread()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1955): TraceRc Thread::LogContextSwitches(bool on)
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2080): SysThreadId Thread::NativeThreadId() const
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2108): DelayRc Thread::Pause(msecs_t msecs)
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2148): double Thread::PercentIdle()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2507): bool Thread::RunningLocked()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2658): void Thread::StackCheck()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2930): TraceRc Thread::StartTracing(bool immediate, bool autostop)
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2966): void Thread::StopTracing()
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(3029): void Thread::Trace
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(3046): bool Thread::TraceRunningThread(Thread*& thr)
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(3081): void Thread::TrapCheck()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.cpp(272): bool ThreadAdmin::BreakEnabled()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.cpp(370): void ThreadAdmin::Incr(Register r)
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.cpp(478): word ThreadAdmin::TrapCount()
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadRegistry.cpp(194): ThreadId ThreadRegistry::FindThreadId(SysThreadId nid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadRegistry.cpp(203): Thread* ThreadRegistry::GetThread(ThreadId tid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/ToolRegistry.cpp(102): Tool* ToolRegistry::GetTool(FlagId fid) const
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(96): TraceBuffer::TraceBuffer() :
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(124): TraceBuffer::~TraceBuffer()
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(138): void* TraceBuffer::AddRecord(size_t nBytes)
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(336): bool TraceBuffer::Empty() const
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(367): bool TraceBuffer::IsLocked()
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(376): void TraceBuffer::Lock()
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(396): void TraceBuffer::Next(TraceRecord*& record, const Flags& mask) const
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(457): void TraceBuffer::PurgeRecords(size_t end)
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(525): void TraceBuffer::RecordInvocation(fn_name_arg func) const
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp(728): void TraceBuffer::Unlock()
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.cpp(82): void FunctionProfiler::CheckHigh(FunctionStats*& high,
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionStats.cpp(45): void FunctionStats::IncrCalls(usecs_t net)
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1143): Q1WayItem::~Q1WayItem()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1177): Q1WayPool::Q1WayPool()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1206): void Q1WayPool::Reallocate()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1663): Q2WayItem::~Q2WayItem()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1697): Q2WayPool::Q2WayPool()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(1726): void Q2WayPool::Reallocate()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(2227): RegistryItem::~RegistryItem()
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(2258): RegistryPool::RegistryPool()
  C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.cpp(190): TraceStatus IpBuffer::GetStatus() const
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(190): size_t IpPort::Discards() const
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPortRegistry.cpp(268): IpPort* IpPortRegistry::GetPort(ipport_t port, IpProtocol protocol) const
  C:/Users/gregu/Documents/tsf/tsf/nw/IpServiceRegistry.cpp(63): IpService* IpServiceRegistry::GetService(const string& name) const
  C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.win.cpp(94): SysIpL2Addr SysIpL2Addr::LoopbackAddr()
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.cpp(134): bool SysSocket::SetTracing(bool tracing)
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.cpp(142): bool SysSocket::Trace(TraceStatus status)
  C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.cpp(153): bool SysSocket::TraceEnabled()
  C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.cpp(413): SysTcpSocket* TcpIoThread::Listener() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsBicFeature.cpp(82): CliText* PotsBicFeature::Attrs() const { return new PotsBicAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsBocFeature.cpp(67): CliText* PotsBocFeature::Attrs() const { return new PotsBocAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfbFeature.cpp(64): CliText* PotsCfbFeature::Attrs() const { return new PotsCfbAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfnFeature.cpp(82): CliText* PotsCfnFeature::Attrs() const { return new PotsCfnAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfuFeature.cpp(64): CliText* PotsCfuFeature::Attrs() const { return new PotsCfuAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.cpp(502): void PotsCircuit::Trace(const SignalEntry& entry)
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCwtFeature.cpp(61): CliText* PotsCwtFeature::Attrs() const { return new PotsCwtAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsCxfFeature.cpp(54): CliText* PotsCxfFeature::Attrs() const { return new PotsCxfAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureRegistry.cpp(133): PotsFeature* PotsFeatureRegistry::Feature(PotsFeature::Id fid) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsHtlFeature.cpp(69): CliText* PotsHtlFeature::Attrs() const { return new PotsHtlAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfileRegistry.cpp(98): PotsProfile* PotsProfileRegistry::Profile(Address::DN dn) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(341): CliText* PotsAlertingSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(355): CliText* PotsDigitsSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(369): CliText* PotsFacilitySignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(383): CliText* PotsFlashSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(397): CliText* PotsLockoutSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(411): CliText* PotsOffhookSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(425): CliText* PotsOnhookSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(439): CliText* PotsProgressSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(453): CliText* PotsReleaseSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(467): CliText* PotsSuperviseSignal::CreateText() const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(510): CliParm* PotsDigitsParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(552): CliParm* PotsFacilityParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(722): CliParm* PotsHeaderParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(843): CliParm* PotsRingParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp(931): CliParm* PotsScanParameter::CreateCliParm(Usage use) const
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsSusFeature.cpp(59): CliText* PotsSusFeature::Attrs() const { return new PotsSusAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsTwcFeature.cpp(70): CliText* PotsTwcFeature::Attrs() const { return new PotsTwcAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/pb/PotsWmlFeature.cpp(81): CliText* PotsWmlFeature::Attrs() const { return new PotsWmlAttrs; }
  C:/Users/gregu/Documents/tsf/tsf/sb/AnalyzeSapEvent.cpp(76): void AnalyzeSapEvent::Capture
  C:/Users/gregu/Documents/tsf/tsf/sb/AnalyzeSnpEvent.cpp(72): void AnalyzeSnpEvent::Capture
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(314): void Context::Dump() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(938): bool Context::TraceOn()
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(948): bool Context::TraceOn(TransTrace*& trans)
  C:/Users/gregu/Documents/tsf/tsf/sb/Event.cpp(123): void Event::Capture
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(204): size_t Factory::DiscardedContextCount() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(211): size_t Factory::DiscardedMessageCount() const
  C:/Users/gregu/Documents/tsf/tsf/sb/FactoryRegistry.cpp(136): Factory* FactoryRegistry::GetFactory(FactoryId fid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/InitiationReqEvent.cpp(74): void InitiationReqEvent::Capture
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(683): void InvokerPool::RecordDelay(Message::Priority prio, msecs_t delay) const
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(787): size_t InvokerPool::WorkQCurrLength(Message::Priority prio) const
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(795): msecs_t InvokerPool::WorkQMaxDelay(Message::Priority prio) const
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(803): size_t InvokerPool::WorkQMaxLength(Message::Priority prio) const
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPoolRegistry.cpp(163): InvokerPool* InvokerPoolRegistry::Pool(Faction faction) const
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.cpp(98): TraceStatus InvokerThread::CalcStatus(bool dynamic) const
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.cpp(229): MsgDirection Message::Dir() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.cpp(316): ProtocolId Message::GetProtocol() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.cpp(351): SignalId Message::GetSignal() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Message.cpp(407): MsgHeader* Message::Header() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.cpp(179): Parameter::Usage Parameter::GetUsage(SignalId sid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(120): Parameter* Protocol::FirstParm() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(133): Signal* Protocol::FirstSignal() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(146): Parameter* Protocol::GetParameter(ParameterId pid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(158): Signal* Protocol::GetSignal(SignalId sid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(170): void Protocol::NextParm(Parameter*& parm) const
  C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp(183): void Protocol::NextSignal(Signal*& sig) const
  C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolRegistry.cpp(64): Protocol* ProtocolRegistry::GetProtocol(ProtocolId prid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.cpp(391): void TimerPool::IncrTimeouts() const
  C:/Users/gregu/Documents/tsf/tsf/sb/Service.cpp(356): Trigger* Service::GetTrigger(TriggerId tid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceRegistry.cpp(64): Service* ServiceRegistry::GetService(ServiceId sid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp(297): Service* ServiceSM::GetService() const
  C:/Users/gregu/Documents/tsf/tsf/sb/State.cpp(110): bool State::BindEventHandler(EventHandlerId ehid, EventId eid)
  C:/Users/gregu/Documents/tsf/tsf/sb/State.cpp(142): bool State::BindMsgAnalyzer(EventHandlerId ehid, ServicePortId pid)
  C:/Users/gregu/Documents/tsf/tsf/sb/State.cpp(222): EventHandlerId State::GetHandler(EventId eid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/State.cpp(230): EventHandlerId State::MsgAnalyzer(ServicePortId pid) const
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerThread.cpp(45): TraceStatus TimerThread::CalcStatus(bool dynamic) const
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp(370): PotsProfile* PotsBcSsm::Profile() const
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallIpService.cpp(83): Faction PotsCallIpService::GetFaction() const { return PayloadFaction; }
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallIpService.cpp(93): ipport_t PotsCallIpService::Port() const { return ipport_t(port_); }
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallIpService.cpp(97): size_t PotsCallIpService::RxSize() const { return IoThread::MaxRxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallIpService.cpp(101): size_t PotsCallIpService::TxSize() const { return IoThread::MaxTxBuffSize; }
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.cpp(103): void PotsTreatmentRegistry::SetCauseToTreatmentQ
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.cpp(185): PotsTreatmentQueue* PotsTreatmentRegistry::TreatmentQ
  C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.cpp(62): bool MscAddress::ExternalFid(FactoryId& fid) const
  C:/Users/gregu/Documents/tsf/tsf/st/MscContext.cpp(74): bool MscContext::IsEqualTo(const void* rcvr, uint16_t cid) const
  C:/Users/gregu/Documents/tsf/tsf/st/MscContextPair.cpp(41): void MscContextPair::Contexts(MscContext*& ctx1, MscContext*& ctx2) const
W099 Function does not invoke Debug::ft as first statement
  C:/Users/gregu/Documents/tsf/tsf/nb/CinThread.cpp(91):       Debug::ft(CinThread_Enter);
  C:/Users/gregu/Documents/tsf/tsf/nb/CinThread.cpp(136):    Debug::ft(CinThread_GetLine);
  C:/Users/gregu/Documents/tsf/tsf/nb/Debug.cpp(49):    Debug::ft(Debug_GenerateSwLog);
  C:/Users/gregu/Documents/tsf/tsf/nb/Exception.cpp(30):    Debug::ft(Exception_ctor1);
  C:/Users/gregu/Documents/tsf/tsf/nb/MutexGuard.cpp(23):    Debug::ft(MutexGuard_ctor);
  C:/Users/gregu/Documents/tsf/tsf/nb/MutexGuard.cpp(36):       Debug::ft(MutexGuard_dtor);
  C:/Users/gregu/Documents/tsf/tsf/nb/Q1Link.cpp(34):    Debug::ft(Q1Link_dtor);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysMutex.win.cpp(90):    Debug::ft(SysMutex_Acquire);
  C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp(41):    Debug::ft(NodeBase_SE_Handler);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(1641):    Debug::ft(Thread_ExitIfSafe);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2452):    Debug::ft(Thread_ResumeLocked);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2630):    Debug::ft(Thread_SignalHandler);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(2702):          Debug::ft(Thread_Start);
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(3215):       Debug::ft(Thread_Unlock);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3359):       Debug::ft(RecoveryTestThread_Enter);
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(3441):       Debug::ft(RecoveryTestThread_LoopForever);
  C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp(680):    Debug::ft(Context_ProcessWork);
W101 Override of Base.Display not found
  C:/Users/gregu/Documents/tsf/tsf/an/PotsShelf.h(29): class PotsShelfIpService : public UdpIpService
  C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp(208): class TrafficCallPool : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(281): class CipUdpService : public UdpIpService
  C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h(322): class CipTcpService : public TcpIpService
  C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h(72): class CxxSymbols: public Temporary
  C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.h(31): class Interpreter : public Temporary
  C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.h(72): class CfgFileTimeParm : public CfgStrParm
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.h(48): class NbTracer : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(60): class ObjectPoolSizeCfg : public CfgIntParm
  C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp(73): class ObjectPoolStats : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.h(26): class SysTickTimer : public Immutable
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(243): class ThreadStats : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(336): class ContextSwitches : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(591): class Orphans : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.cpp(36): class ThreadsStats : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.h(48): class TraceBuffer : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h(34): class FunctionProfiler : public Temporary
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(890): class LbcPool : public Temporary
  C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp(2649): class SysTimePool : public Temporary
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp(34): class IpPortStats : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/nw/IpPortRegistry.cpp(32): class HostAddrCfg : public CfgStrParm
  C:/Users/gregu/Documents/tsf/tsf/nw/NwTracer.h(25): class NwTracer : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.h(21): class SysUdpSocket : public SysSocket
  C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp(28): class FactoryStats : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(42): class InvokerPoolStats : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp(56): class InvokerWork : public Dynamic
  C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.h(179): class TimerPool : public ObjectPool
  C:/Users/gregu/Documents/tsf/tsf/sb/SbTracer.h(100): class SbTracer : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h(39): class PotsCallIpService : public UdpIpService
W102 Override of Object.Patch not found
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(23): class StatusCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(44): class SetCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(73): class IncludeCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(103): class ExcludeCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(132): class QueryCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(162): class SaveCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h(190): class ClearCommand : public CliCommand
  C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.h(48): class NbTracer : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nb/PermanentHeap.h(21): class PermanentHeap : public SysHeap
  C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.h(26): class SysTickTimer : public Immutable
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(336): class ContextSwitches : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(591): class Orphans : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp(725): class ThreadPriv : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(28): class NwClearCommand : public ClearCommand
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(56): class NwExcludeCommand : public ExcludeCommand
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(82): class NwIncludeCommand : public IncludeCommand
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(101): class NwQueryCommand : public QueryCommand
  C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h(116): class NwStatusCommand : public StatusCommand
  C:/Users/gregu/Documents/tsf/tsf/nw/NwTracer.h(25): class NwTracer : public Permanent
  C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h(35): class EventHandler : public Protected
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h(27): class SbAnalyzeMessage : public EventHandler
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h(41): class SbAnalyzeSap : public EventHandler
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h(55): class SbAnalyzeSnp : public EventHandler
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h(69): class SbForceTransition : public EventHandler
  C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h(83): class SbInitiationReq : public EventHandler
  C:/Users/gregu/Documents/tsf/tsf/sb/TimerProtocol.h(75): class TimeoutParameter : public TlvParameter
========================================================================================================================
WARNINGS SORTED BY FILE/TYPE/LINE
C:/Users/gregu/Documents/tsf/tsf/an/AnIncrement.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/an/AnModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/an/PotsShelf.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
    line 20: using namespace SessionBase;
    line 21: using namespace MediaBase;
  W026 Unused function
    line 51:    virtual CliText* CreateText() const override;
  W101 Override of Base.Display not found
    line 29: class PotsShelfIpService : public UdpIpService
C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfFactory.cpp:
  W009 Cast down the inheritance hierarchy
    line 124:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    line 136:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
    line 157:    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
    line 167:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfHandler.cpp:
  W008 reinterpret_cast
    line 55:    auto pptr = reinterpret_cast< TlvParmPtr >(sbuff->PayloadPtr());
    line 56:    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  W009 Cast down the inheritance hierarchy
    line 53:    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
C:/Users/gregu/Documents/tsf/tsf/an/PotsShelfIpService.cpp:
  W007 Functional cast
    line 96: ipport_t PotsShelfIpService::Port() const { return ipport_t(port_); }
  W098 Function does not invoke Debug::ft
    line 83: Faction PotsShelfIpService::GetFaction() const { return PayloadFaction; }
    line 96: ipport_t PotsShelfIpService::Port() const { return ipport_t(port_); }
    line 100: size_t PotsShelfIpService::RxSize() const { return IoThread::MaxRxBuffSize; }
    line 104: size_t PotsShelfIpService::TxSize() const { return IoThread::MaxTxBuffSize; }
C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.cpp:
  W006 C-style cast
    line 494:    Singleton< TrafficCallPool >::Instance()->Enq((TrafficCall*) addr);
    line 1068:    timewheel_ = (Q1Way< TrafficCall >*) Memory::Alloc(size, MemDyn);
  W008 reinterpret_cast
    line 482:    auto fake = reinterpret_cast< const TrafficCall* >(&local);
  W047 Data could be const
    line 156:    Q1Link link_;
  W082 Function could be const
    line 65:    msecs_t Originate();
  W084 Function could be free
    line 152:    static const char* strState(State state);
  W098 Function does not invoke Debug::ft
    line 1372: void PotsTrafficThread::RecordHoldingTime(secs_t secs)
  W101 Override of Base.Display not found
    line 208: class TrafficCallPool : public Dynamic
C:/Users/gregu/Documents/tsf/tsf/an/PotsTrafficThread.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
    line 20: using namespace CallBase;
  W084 Function could be free
    line 72:    static void DisplayStateCounts
C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.cpp:
  W008 reinterpret_cast
    line 82:    reinterpret_cast< const DigitString* >(bytes)->Display(stream, prefix);
  W009 Cast down the inheritance hierarchy
    line 99:    auto& tlvmsg = static_cast< TlvMessage& >(msg);
    line 150:    auto& tlvmsg = static_cast< const TlvMessage& >(msg);
C:/Users/gregu/Documents/tsf/tsf/cb/BcAddress.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
    line 20: using namespace SessionBase;
  W026 Unused function
    line 199:    Digit GetDigit(DigitCount i) const;
  W036 Member could be private
    line 131:    typedef uint8_t DigitCount;
    line 161:    static bool IsValidDigit(Digit d)
    line 168:    Rc AddDigit(Digit d);
    line 187:    DigitCount Size() const;
    line 211:    bool operator==(const DigitString& that) const;
  W037 Member could be protected
    line 110:    static Address::DN IndexToDN(uint32_t i) { return i + FirstDN - 1; }
  W055 Single-argument constructor is not explicit
    line 153:    DigitString(Address::DN dn);
  W084 Function could be free
    line 86:    static bool IsValidDN(DN dn) { return ((dn >= FirstDN) && (dn <= LastDN)); }
    line 102:    static bool IsValidSC(SC sc) { return ((sc >= FirstSC) && (sc <= LastSC)); }
    line 106:    static uint32_t DNToIndex(Address::DN dn) { return dn - FirstDN + 1; }
    line 110:    static Address::DN IndexToDN(uint32_t i) { return i + FirstDN - 1; }
    line 161:    static bool IsValidDigit(Digit d)
C:/Users/gregu/Documents/tsf/tsf/cb/BcCause.cpp:
  W008 reinterpret_cast
    line 119:    reinterpret_cast< const CauseInfo* >(bytes)->Display(stream, prefix);
  W098 Function does not invoke Debug::ft
    line 108: CliParm* CauseParameter::CreateCliParm(Usage use) const
C:/Users/gregu/Documents/tsf/tsf/cb/BcCause.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
    line 17: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/cb/BcHandlers.cpp:
  W009 Cast down the inheritance hierarchy
    line 36:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 38:    auto& bcssm = static_cast< BcSsm& >(ssm);
    line 64:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 65:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 67:    auto&         bcssm = static_cast< BcSsm& >(ssm);
    line 121:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 122:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    line 124:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    line 166:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 167:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    line 169:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    line 200:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 201:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 203:    auto&         bcssm = static_cast< BcSsm& >(ssm);
  W091 Line contains adjacent spaces
    line 64:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 65:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 66:    auto          sid = msg->GetSignal();
    line 67:    auto&         bcssm = static_cast< BcSsm& >(ssm);
    line 69:    CauseInfo*    cci;
    line 121:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 122:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    line 123:    auto       sid = msg->GetSignal();
    line 124:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    line 166:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 167:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    line 168:    auto       sid = msg->GetSignal();
    line 169:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    line 200:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 201:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 202:    auto          sid = msg->GetSignal();
    line 203:    auto&         bcssm = static_cast< BcSsm& >(ssm);
    line 205:    CauseInfo*    cci;
C:/Users/gregu/Documents/tsf/tsf/cb/BcProgress.cpp:
  W008 reinterpret_cast
    line 105:    reinterpret_cast< const ProgressInfo* >(bytes)->Display(stream, prefix);
  W098 Function does not invoke Debug::ft
    line 94: CliParm* ProgressParameter::CreateCliParm(Usage use) const
C:/Users/gregu/Documents/tsf/tsf/cb/BcProgress.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
    line 17: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.cpp:
  W007 Functional cast
    line 260: ipport_t CipUdpService::Port() const { return ipport_t(port_); }
    line 363: ipport_t CipTcpService::Port() const { return ipport_t(port_); }
  W008 reinterpret_cast
    line 513:    reinterpret_cast< const RouteResult* >(bytes)->Display(stream, prefix);
  W009 Cast down the inheritance hierarchy
    line 528:    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
    line 558:    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
    line 870:       if(m->GetSignal() == sid) return static_cast< CipMessage* >(m);
    line 904:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    line 1034:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    line 1433:    auto& tmsg = static_cast< const CipMessage& >(msg);
    line 1438:    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
  W091 Line contains adjacent spaces
    line 525:    id_t        idx;
    line 526:    word        fid, rid;
    line 528:    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
    line 557:    TestRc       rc;
    line 558:    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
    line 560:    id_t         idx;
    line 561:    word         fid, rid;
    line 903:    auto          state = GetState();
    line 904:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    line 905:    auto          sig = tmsg.GetSignal();
    line 906:    TimeoutInfo*  toi = nullptr;
    line 908:    auto          err = true;
    line 909:    debug64_t     error;
    line 1033:    auto          state = GetState();
    line 1034:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    line 1035:    auto          sig = msg.GetSignal();
    line 1037:    auto          err = true;
    line 1038:    debug64_t     error;
  W098 Function does not invoke Debug::ft
    line 250: Faction CipUdpService::GetFaction() const { return PayloadFaction; }
    line 260: ipport_t CipUdpService::Port() const { return ipport_t(port_); }
    line 264: size_t CipUdpService::RxSize() const { return IoThread::MaxRxBuffSize; }
    line 268: size_t CipUdpService::TxSize() const { return IoThread::MaxTxBuffSize; }
    line 345: Faction CipTcpService::GetFaction() const { return PayloadFaction; }
    line 349: size_t CipTcpService::MaxBacklog() const { return 200; }
    line 353: size_t CipTcpService::MaxConns() const { return TcpIoThread::MaxConns; }
    line 363: ipport_t CipTcpService::Port() const { return ipport_t(port_); }
    line 367: size_t CipTcpService::RxSize() const { return IoThread::MaxRxBuffSize; }
    line 371: size_t CipTcpService::TxSize() const { return IoThread::MaxTxBuffSize; }
    line 417: CliText* CipIamSignal::CreateText() const
    line 431: CliText* CipCpgSignal::CreateText() const
    line 445: CliText* CipAnmSignal::CreateText() const
    line 459: CliText* CipRelSignal::CreateText() const
    line 503: CliParm* CipRouteParameter::CreateCliParm(Usage use) const
    line 607: CliParm* CipCallingParameter::CreateCliParm(Usage use) const
    line 631: CliParm* CipCalledParameter::CreateCliParm(Usage use) const
    line 657: CliParm* CipOriginalCallingParameter::CreateCliParm(Usage use) const
    line 683: CliParm* CipOriginalCalledParameter::CreateCliParm(Usage use) const
C:/Users/gregu/Documents/tsf/tsf/cb/BcProtocol.h:
  W017 Using statement in header
    line 34: using namespace NodeBase;
    line 35: using namespace SessionBase;
    line 36: using namespace MediaBase;
  W020 Unused class
    line 281: class CipUdpService : public UdpIpService
  W026 Unused function
    line 165:    MediaInfo* AddMedia(const MediaInfo& media);
    line 232:    virtual void InjectFinalMsg() override;
    line 303:    virtual CliText* CreateText() const override;
    line 356:    virtual CliText* CreateText() const override;
  W036 Member could be private
    line 219:    virtual void EnsureMediaMsg() override;
    line 223:    virtual IncomingRc ProcessIcMsg(Message& msg, Event*& event) override;
    line 404:    virtual Message* AllocIcMsg(SbIpBufferPtr& buff) const override;
  W101 Override of Base.Display not found
    line 281: class CipUdpService : public UdpIpService
    line 322: class CipTcpService : public TcpIpService
C:/Users/gregu/Documents/tsf/tsf/cb/BcRouting.h:
  W017 Using statement in header
    line 16: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/cb/BcSessions.h:
  W017 Using statement in header
    line 38: using namespace NodeBase;
    line 39: using namespace SessionBase;
    line 40: using namespace MediaBase;
  W032 Member hides inherited name
    line 301:    static const Id NextId = FirstId + 50;
    line 868:    static const Id NextId                 = FirstUn + 7;
  W036 Member could be private
    line 1000:    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
    line 1001:    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
    line 1002:    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
    line 1048:    virtual EventHandler::Rc RequestService(Event*& nextEvent);
    line 1137:    CipPsm* AllocNPsm();
  W037 Member could be protected
    line 1014:    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
    line 1019:    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
    line 1084:    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
  W047 Data could be const
    line 325:    Progress::Ind progress_;
    line 341:    Cause::Ind cause_;
  W069 Virtual function is public
    line 995:    virtual EventHandler::Rc RaiseAuthorizeOrigination(Event*& nextEvent);
    line 996:    virtual EventHandler::Rc RaiseCollectInformation(Event*& nextEvent);
    line 997:    virtual EventHandler::Rc RaiseLocalInformation(Event*& nextEvent);
    line 998:    virtual EventHandler::Rc RaiseCollectionTimeout(Event*& nextEvent);
    line 999:    virtual EventHandler::Rc RaiseAnalyzeInformation(Event*& nextEvent);
    line 1000:    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
    line 1001:    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
    line 1002:    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
    line 1003:    virtual EventHandler::Rc RaiseSendCall(Event*& nextEvent);
    line 1004:    virtual EventHandler::Rc RaiseRemoteBusy(Event*& nextEvent);
    line 1005:    virtual EventHandler::Rc RaiseRemoteProgress
    line 1007:    virtual EventHandler::Rc RaiseRemoteAlerting(Event*& nextEvent);
    line 1008:    virtual EventHandler::Rc RaiseRemoteNoAnswer(Event*& nextEvent);
    line 1009:    virtual EventHandler::Rc RaiseRemoteAnswer(Event*& nextEvent);
    line 1010:    virtual EventHandler::Rc RaiseAuthorizeTermination(Event*& nextEvent);
    line 1011:    virtual EventHandler::Rc RaiseSelectFacility(Event*& nextEvent);
    line 1012:    virtual EventHandler::Rc RaisePresentCall(Event*& nextEvent);
    line 1013:    virtual EventHandler::Rc RaiseLocalBusy(Event*& nextEvent);
    line 1014:    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
    line 1015:    virtual EventHandler::Rc RaiseLocalProgress
    line 1017:    virtual EventHandler::Rc RaiseLocalAlerting(Event*& nextEvent);
    line 1018:    virtual EventHandler::Rc RaiseLocalAnswer(Event*& nextEvent);
    line 1019:    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
    line 1020:    virtual EventHandler::Rc RaiseLocalSuspend(Event*& nextEvent);
    line 1021:    virtual EventHandler::Rc RaiseLocalResume(Event*& nextEvent);
    line 1022:    virtual EventHandler::Rc RaiseRemoteSuspend(Event*& nextEvent);
    line 1023:    virtual EventHandler::Rc RaiseRemoteResume(Event*& nextEvent);
    line 1030:    virtual EventHandler::Rc RaiseLocalRelease
    line 1032:    virtual EventHandler::Rc RaiseRemoteRelease
    line 1034:    virtual EventHandler::Rc RaiseReleaseCall
    line 1036:    virtual EventHandler::Rc RaiseApplyTreatment
    line 1043:    virtual EventHandler::Rc AnalyzeInformation(Event*& nextEvent);
    line 1048:    virtual EventHandler::Rc RequestService(Event*& nextEvent);
    line 1055:    virtual EventHandler::Rc SelectRoute(Event*& nextEvent);
    line 1061:    virtual EventHandler::Rc AnalyzeNPsmTimeout
    line 1068:    virtual EventHandler::Rc HandleLocalAlerting();
    line 1073:    virtual EventHandler::Rc HandleLocalAnswer();
    line 1077:    virtual EventHandler::Rc HandleRemoteRelease(Event& currEvent);
    line 1084:    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
    line 1090:    virtual CipMessage* BuildCipIam();
    line 1096:    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
    line 1198:    virtual Cause::Ind VerifyRoute(RouteResult::Id rid) const;
  W071 Virtual function has no overrides
    line 995:    virtual EventHandler::Rc RaiseAuthorizeOrigination(Event*& nextEvent);
    line 996:    virtual EventHandler::Rc RaiseCollectInformation(Event*& nextEvent);
    line 997:    virtual EventHandler::Rc RaiseLocalInformation(Event*& nextEvent);
    line 998:    virtual EventHandler::Rc RaiseCollectionTimeout(Event*& nextEvent);
    line 999:    virtual EventHandler::Rc RaiseAnalyzeInformation(Event*& nextEvent);
    line 1000:    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
    line 1001:    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
    line 1002:    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
    line 1003:    virtual EventHandler::Rc RaiseSendCall(Event*& nextEvent);
    line 1004:    virtual EventHandler::Rc RaiseRemoteBusy(Event*& nextEvent);
    line 1005:    virtual EventHandler::Rc RaiseRemoteProgress
    line 1007:    virtual EventHandler::Rc RaiseRemoteAlerting(Event*& nextEvent);
    line 1008:    virtual EventHandler::Rc RaiseRemoteNoAnswer(Event*& nextEvent);
    line 1009:    virtual EventHandler::Rc RaiseRemoteAnswer(Event*& nextEvent);
    line 1010:    virtual EventHandler::Rc RaiseAuthorizeTermination(Event*& nextEvent);
    line 1011:    virtual EventHandler::Rc RaiseSelectFacility(Event*& nextEvent);
    line 1012:    virtual EventHandler::Rc RaisePresentCall(Event*& nextEvent);
    line 1013:    virtual EventHandler::Rc RaiseLocalBusy(Event*& nextEvent);
    line 1014:    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
    line 1015:    virtual EventHandler::Rc RaiseLocalProgress
    line 1017:    virtual EventHandler::Rc RaiseLocalAlerting(Event*& nextEvent);
    line 1018:    virtual EventHandler::Rc RaiseLocalAnswer(Event*& nextEvent);
    line 1019:    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
    line 1020:    virtual EventHandler::Rc RaiseLocalSuspend(Event*& nextEvent);
    line 1021:    virtual EventHandler::Rc RaiseLocalResume(Event*& nextEvent);
    line 1022:    virtual EventHandler::Rc RaiseRemoteSuspend(Event*& nextEvent);
    line 1023:    virtual EventHandler::Rc RaiseRemoteResume(Event*& nextEvent);
    line 1030:    virtual EventHandler::Rc RaiseLocalRelease
    line 1032:    virtual EventHandler::Rc RaiseRemoteRelease
    line 1034:    virtual EventHandler::Rc RaiseReleaseCall
    line 1036:    virtual EventHandler::Rc RaiseApplyTreatment
    line 1043:    virtual EventHandler::Rc AnalyzeInformation(Event*& nextEvent);
    line 1048:    virtual EventHandler::Rc RequestService(Event*& nextEvent);
    line 1055:    virtual EventHandler::Rc SelectRoute(Event*& nextEvent);
    line 1068:    virtual EventHandler::Rc HandleLocalAlerting();
    line 1073:    virtual EventHandler::Rc HandleLocalAnswer();
    line 1077:    virtual EventHandler::Rc HandleRemoteRelease(Event& currEvent);
    line 1090:    virtual CipMessage* BuildCipIam();
    line 1096:    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
  W076 Adjacent arguments have the same type
    line 1202:    BcFactory(Id fid, ProtocolId prid, const char* name);
  W077 Virtual function defines default argument
    line 1036:    virtual EventHandler::Rc RaiseApplyTreatment
  W082 Function could be const
    line 1096:    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
    line 1153:    CipMessage* BuildCipRel(Cause::Ind cause);
C:/Users/gregu/Documents/tsf/tsf/cb/BcSsm.cpp:
  W009 Cast down the inheritance hierarchy
    line 390:    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
    line 905:       auto fac = static_cast< BcFactory* >(reg->GetFactory(route_.selector));
  W094 Line length exceeds the standard maximum
    line 285:    for(auto s = BcState::AuthorizingOrigination; s <= BcState::OrigAlerting; ++s)
C:/Users/gregu/Documents/tsf/tsf/cb/CbModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/cb/DigitString.cpp:
  W007 Functional cast
    line 124:       auto rc = AddDigit(Digit(ds.digits_[i]));
    line 156:    if(i < Size()) return Digit(digits_[i]);
  W098 Function does not invoke Debug::ft
    line 154: Digit DigitString::GetDigit(DigitCount i) const
C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.cpp:
  W009 Cast down the inheritance hierarchy
    line 408:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 409:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 411:    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
    line 448:    auto& ppe = static_cast< ProxyBcProgressEvent& >(currEvent);
    line 457:       auto& pssm = static_cast< ProxyBcSsm& >(ssm);
    line 489:    auto& pssm = static_cast< ProxyBcSsm& >(ssm);
    line 490:    auto ppsm = static_cast< ProxyBcPsm* >(Context::ContextPsm());
    line 609:    auto pssm = static_cast< ProxyBcSsm* >(RootSsm());
    line 767:          return static_cast< ProxyBcPsm* >(p);
    line 803:          ppsm = static_cast< ProxyBcPsm* >(psm);
    line 1029:    auto& tmsg = static_cast< const CipMessage& >(msg);
    line 1034:    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
  W091 Line contains adjacent spaces
    line 408:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 409:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 410:    auto          sid = msg->GetSignal();
    line 411:    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
    line 413:    CauseInfo*    cci;
C:/Users/gregu/Documents/tsf/tsf/cb/ProxyBcSessions.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
    line 20: using namespace SessionBase;
  W020 Unused class
    line 177: class ProxyBcDisconnecting : public BcDisconnecting
  W021 Unused data
    line 48:    static const ServicePortId NextPortId = FirstPortId + 1;
    line 204:    static const Id NextId        = FirstId + 4;
    line 288:    static const Id NextId              = FirstId + 7;
    line 373:    static const Id NextId          = FirstId + 3;
  W026 Unused function
    line 180:    explicit ProxyBcDisconnecting(ServiceId sid);
  W032 Member hides inherited name
    line 48:    static const ServicePortId NextPortId = FirstPortId + 1;
    line 198:    static const Id FirstId = BcEvent::NextId;
    line 204:    static const Id NextId        = FirstId + 4;
    line 288:    static const Id NextId              = FirstId + 7;
  W036 Member could be private
    line 480:    ProxyBcPsm* FirstBroadcast() const;
  W069 Virtual function is public
    line 457:    virtual EventHandler::Rc RaiseReleaseUser
    line 459:    virtual EventHandler::Rc RaiseProxyProgress
    line 461:    virtual EventHandler::Rc RaiseProxyAnswer(Event*& nextEvent);
    line 462:    virtual EventHandler::Rc RaiseProxyRelease
    line 497:    virtual void SetUPsm(MediaPsm& psm) override;
  W071 Virtual function has no overrides
    line 457:    virtual EventHandler::Rc RaiseReleaseUser
    line 459:    virtual EventHandler::Rc RaiseProxyProgress
    line 461:    virtual EventHandler::Rc RaiseProxyAnswer(Event*& nextEvent);
    line 462:    virtual EventHandler::Rc RaiseProxyRelease
C:/Users/gregu/Documents/tsf/tsf/cb/ServiceCodeRegistry.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W036 Member could be private
    line 30:    void SetService(Address::SC sc, ServiceId sid);
C:/Users/gregu/Documents/tsf/tsf/cn/CnModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.cpp:
  W008 reinterpret_cast
    line 46:    auto fake = reinterpret_cast< const CodeDir* >(&local);
  W098 Function does not invoke Debug::ft
    line 103: bool CodeDir::IsSubsDir() const
C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W047 Data could be const
    line 77:    RegCell did_;
  W084 Function could be free
    line 73:    static bool IsCodeFile(const std::string& name);
C:/Users/gregu/Documents/tsf/tsf/ct/CodeDir.win.cpp:
  W050 Default constructor invoked: POD members not initialized
    line 39:    _finddata_t fileAttrs;
C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.cpp:
  W006 C-style cast
    line 2068:    info_ = (LineInfo*) Memory::Alloc(sizeof(LineInfo) * lines_, MemTemp);
  W007 Functional cast
    line 541:       stream << setw(12) << LineType(t)
    line 553:          stream << setw(6) << WarningCode(Warning(w))
    line 571:       stream << WarningCode(w) << SPACE << Warning(w) << CRLF;
  W008 reinterpret_cast
    line 754:    auto fake = reinterpret_cast< const CodeFile* >(&local);
  W009 Cast down the inheritance hierarchy
    line 744:    affecterIds_ = static_cast< CodeFileSet* >(asSet)->Set();
    line 2353:          auto base = static_cast< const Class* >(*b);
    line 2449:                auto type = static_cast< const Typedef* >(*item2);
    line 2472:          auto type = static_cast< const Typedef* >(*item1);
    line 2667:          auto& affecterIds = static_cast< CodeFileSet* >(affecterSet)->Set();
  W019 Unused argument
    line 66/1:    word AddForward(string& item, string& expl);
    line 67/1:    word RemoveForward(string& item, string& expl);
    line 68/1:    word RemoveUsing(string& item, string& expl);
    line 73/1:    word GetEpilog(string& expl);
  W021 Unused data
    line 1058: const string SingleRule(COMMENT_STR + string(78, '-'));
  W026 Unused function
    line 419:    bool operator!=(const WarningLog& that) const;
  W047 Data could be const
    line 81:    stringVector intIncls_;
  W050 Default constructor invoked: POD members not initialized
    line 1950:       WarningLog log;
  W051 Default constructor invoked
    line 2249:    CxxUsageSets symbols;
  W084 Function could be free
    line 66:    word AddForward(string& item, string& expl);
    line 67:    word RemoveForward(string& item, string& expl);
    line 68:    word RemoveUsing(string& item, string& expl);
    line 74:    static void InsertInclude(const string& include, stringVector& list);
    line 75:    static bool EraseInclude(const string& include, stringVector& list);
    line 453:    static word FindWarning(const WarningLog& log);
    line 465:    static std::string WarningCode(Warning warning);
    line 469:    static bool IsSortedByFile
    line 474:    static bool IsSortedByWarning
  W098 Function does not invoke Debug::ft
    line 619: bool CodeInfo::IsSortedByFile(const WarningLog& log1, const WarningLog& log2)
    line 633: bool CodeInfo::IsSortedByWarning(const WarningLog& log1, const WarningLog& log2)
    line 1681: size_t CodeFile::GetLineNum(size_t pos) const
    line 1705: LineType CodeFile::GetLineType(size_t n) const
    line 1713: bool CodeFile::GetNthLine(size_t n, string& s) const
    line 1813: void CodeFile::InsertClass(Class* cls)
    line 1821: void CodeFile::InsertData(Data* data)
    line 1829: bool CodeFile::InsertDirective(DirectivePtr& dir)
    line 1838: void CodeFile::InsertEnum(Enum* item)
    line 1846: void CodeFile::InsertForw(Forward* forw)
    line 1854: void CodeFile::InsertFunc(Function* func)
    line 1862: void CodeFile::InsertInclude(IncludePtr& incl)
    line 1871: Include* CodeFile::InsertInclude(const string& fn)
    line 1889: void CodeFile::InsertMacro(Macro* macro)
    line 1897: void CodeFile::InsertType(Typedef* type)
    line 1905: void CodeFile::InsertUsing(UsingPtr& use)
C:/Users/gregu/Documents/tsf/tsf/ct/CodeFile.h:
  W017 Using statement in header
    line 31: using namespace NodeBase;
  W036 Member could be private
    line 97:    bool IsTemplateHeader() const;
  W047 Data could be const
    line 348:    RegCell fid_;
  W076 Adjacent arguments have the same type
    line 234:    word Modify(Modification act, std::string& item, std::string& expl);
  W082 Function could be const
    line 212:    word Format(std::string& expl);
    line 234:    word Modify(Modification act, std::string& item, std::string& expl);
  W084 Function could be free
    line 243:    static void GenerateReport(std::ostream& stream, const SetOfIds& set);
C:/Users/gregu/Documents/tsf/tsf/ct/CodeFileSet.cpp:
  W006 C-style cast
    line 486:    LibrarySet* nbSet = (LibrarySet*) this;
    line 518:    LibrarySet* nsSet = (LibrarySet*) this;
  W009 Cast down the inheritance hierarchy
    line 62:    auto curr = static_cast< CodeFileSet* >(Users(true));
    line 74:       curr = static_cast< CodeFileSet* >(prev->Users(true));
    line 94:    auto curr = static_cast< CodeFileSet* >(UsedBy(true));
    line 106:       curr = static_cast< CodeFileSet* >(prev->UsedBy(true));
    line 352:    auto& dirSet = static_cast< const CodeDirSet* >(that)->Set();
    line 384:    auto abSet = static_cast< CodeFileSet* >(this->AffectedBy());
    line 385:    auto asSet = static_cast< CodeFileSet* >(this->Affecters());
    line 497:       currCount = static_cast< CodeFileSet* >(nbSet)->Set().size();
    line 529:       currCount = static_cast< CodeFileSet* >(nsSet)->Set().size();
    line 564:    auto order = static_cast< CodeFileSet* >(affects)->SortInBuildOrder();
  W010 Cast removes const qualification
    line 486:    LibrarySet* nbSet = (LibrarySet*) this;
    line 518:    LibrarySet* nsSet = (LibrarySet*) this;
  W050 Default constructor invoked: POD members not initialized
    line 800:    FileLevel item;
C:/Users/gregu/Documents/tsf/tsf/ct/CodeIncrement.cpp:
  W037 Member could be protected
    line 96:    static LibrarySet* Evaluate(CliThread& cli);
  W084 Function could be free
    line 96:    static LibrarySet* Evaluate(CliThread& cli);
C:/Users/gregu/Documents/tsf/tsf/ct/CodeIncrement.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/ct/CodeSet.cpp:
  W009 Cast down the inheritance hierarchy
    line 49:    auto that = static_cast< CodeSet* >(rhs);
    line 85:    auto that = static_cast< const CodeSet* >(rhs);
    line 122:    auto that = static_cast< const CodeSet* >(rhs);
    line 136:    auto that = static_cast< const CodeSet* >(rhs);
C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.cpp:
  W095 Function not sorted in standard order
    line 271: bool IsUnusedItemWarning(Warning warning)
  W098 Function does not invoke Debug::ft
    line 271: bool IsUnusedItemWarning(Warning warning)
C:/Users/gregu/Documents/tsf/tsf/ct/CodeTypes.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W021 Unused data
    line 502: extern const Flags NoLF_Mask;
    line 503: extern const Flags Last_Mask;
  W047 Data could be const
    line 508: extern uint8_t Indent_Size;
C:/Users/gregu/Documents/tsf/tsf/ct/CtModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.cpp:
  W007 Functional cast
    line 245:       if(Attrs[i].symbol.compare(sym) == 0) return Cxx::Operator(i);
    line 297:          oper = Cxx::Operator(i);
    line 355:       Attrs[ValidIntDigits[i]].intValue = int8_t(i);
    line 361:       Attrs[ValidHexDigits[i]].hexValue = int8_t(h);
    line 366:       Attrs[ValidOctDigits[i]].octValue = int8_t(i);
  W091 Line contains adjacent spaces
    line 83:    CxxWord("-",   "-",    "D",  F),  // AUTO
    line 84:    CxxWord("-",   "-",    "b",  T),  // BREAK
    line 85:    CxxWord("-",   "-",    "c",  T),  // CASE
    line 86:    CxxWord("C",   "C",    "-",  T),  // CLASS
    line 87:    CxxWord("DP",  "DP",   "D",  F),  // CONST
    line 88:    CxxWord("DP",  "DP",   "D",  F),  // CONSTEXPR
    line 89:    CxxWord("-",   "-",    "n",  T),  // CONTINUE
    line 90:    CxxWord("-",   "-",    "o",  T),  // DEFAULT
    line 91:    CxxWord("-",   "-",    "d",  T),  // DO
    line 92:    CxxWord("E",   "E",    "E",  T),  // ENUM
    line 93:    CxxWord("-",   "P",    "-",  F),  // EXPLICIT
    line 94:    CxxWord("DP",  "-",    "-",  T),  // EXTERN
    line 95:    CxxWord("-",   "-",    "f",  T),  // FOR
    line 96:    CxxWord("-",   "F",    "-",  T),  // FRIEND
    line 97:    CxxWord("H",   "H",    "H",  F),  // HASH
    line 98:    CxxWord("-",   "-",    "i",  T),  // IF
    line 99:    CxxWord("P",   "P",    "-",  T),  // INLINE
    line 100:    CxxWord("-",   "D",    "-",  F),  // MUTABLE
    line 101:    CxxWord("N",   "-",    "-",  T),  // NAMESPACE
    line 102:    CxxWord("-",   "P",    "-",  F),  // OPERATOR
    line 103:    CxxWord("-",   "A",    "-",  T),  // PRIVATE
    line 104:    CxxWord("-",   "A",    "-",  T),  // PROTECTED
    line 105:    CxxWord("-",   "A",    "-",  T),  // PUBLIC
    line 106:    CxxWord("-",   "-",    "r",  T),  // RETURN
    line 107:    CxxWord("D",   "DP",   "D",  F),  // STATIC
    line 108:    CxxWord("C",   "C",    "-",  T),  // STRUCT
    line 109:    CxxWord("-",   "-",    "s",  T),  // SWITCH
    line 110:    CxxWord("DCP", "DCFP", "-",  F),  // TEMPLATE
    line 111:    CxxWord("-",   "-",    "t",  T),  // TRY
    line 112:    CxxWord("T",   "T",    "T",  T),  // TYPEDEF
    line 113:    CxxWord("C",   "C",    "-",  T),  // UNION
    line 114:    CxxWord("U",   "U",    "U",  T),  // USING
    line 115:    CxxWord("-",   "P",    "-",  F),  // VIRTUAL
    line 116:    CxxWord("-",   "-",    "w",  T),  // WHILE
    line 117:    CxxWord("-",   "P",    "-",  F),  // NVDTOR
    line 118:    CxxWord("DP",  "DP",   "xD", F)   // NIL_KEYWORD
    line 140:    CxxOp(           SCOPE_STR, 2, 18, F, F, F),  // SCOPE_RESOLUTION
    line 141:    CxxOp(                 ".", 2, 17, F, F, F),  // REFERENCE_SELECT
    line 142:    CxxOp(                "->", 2, 17, T, F, F),  // POINTER_SELECT
    line 143:    CxxOp(                 "[", 2, 17, T, F, F),  // ARRAY_SUBSCRIPT
    line 144:    CxxOp(                 "(", 0, 17, F, F, F),  // FUNCTION_CALL
    line 145:    CxxOp(                "++", 1, 17, T, F, F),  // POSTFIX_INCREMENT
    line 146:    CxxOp(                "--", 1, 17, T, F, F),  // POSTFIX_DECREMENT
    line 147:    CxxOp(         DEFINED_STR, 1, 17, F, F, F),  // DEFINED
    line 148:    CxxOp(          TYPEID_STR, 1, 17, F, F, F),  // TYPE_NAME
    line 149:    CxxOp(      CONST_CAST_STR, 2, 17, F, F, F),  // CONST_CAST
    line 150:    CxxOp(    DYNAMIC_CAST_STR, 2, 17, F, F, F),  // DYNAMIC_CAST
    line 152:    CxxOp(     STATIC_CAST_STR, 2, 17, F, F, F),  // STATIC_CAST
    line 153:    CxxOp(          SIZEOF_STR, 1, 16, F, T, F),  // SIZEOF_TYPE
    line 154:    CxxOp(                "++", 1, 16, T, T, F),  // PREFIX_INCREMENT
    line 155:    CxxOp(                "--", 1, 16, T, T, F),  // PREFIX_DECREMENT
    line 156:    CxxOp(                 "~", 1, 16, T, T, F),  // ONES_COMPLEMENT
    line 157:    CxxOp(                 "!", 1, 16, T, T, F),  // LOGICAL_NOT
    line 158:    CxxOp(                 "+", 1, 16, T, T, F),  // UNARY_PLUS
    line 159:    CxxOp(                 "-", 1, 16, T, T, F),  // UNARY_MINUS
    line 160:    CxxOp(                 "&", 1, 16, T, T, F),  // ADDRESS_OF
    line 161:    CxxOp(                 "*", 1, 16, T, T, F),  // INDIRECTION
    line 162:    CxxOp(             NEW_STR, 0, 16, T, T, F),  // OBJECT_CREATE
    line 163:    CxxOp(       NEW_ARRAY_STR, 0, 16, T, T, F),  // OBJECT_CREATE_ARRAY
    line 164:    CxxOp(          DELETE_STR, 1, 16, T, T, F),  // OBJECT_DELETE
    line 165:    CxxOp(    DELETE_ARRAY_STR, 1, 16, T, T, F),  // OBJECT_DELETE_ARRAY
    line 166:    CxxOp(                 "(", 2, 16, T, T, F),  // CAST
    line 167:    CxxOp(                ".*", 2, 15, F, F, F),  // REFERENCE_SELECT_MEMBER
    line 168:    CxxOp(               "->*", 2, 15, T, F, F),  // POINTER_SELECT_MEMBER
    line 169:    CxxOp(                 "*", 2, 14, T, F, T),  // MULTIPLY
    line 170:    CxxOp(                 "/", 2, 14, T, F, F),  // DIVIDE
    line 171:    CxxOp(                 "%", 2, 14, T, F, F),  // MODULO
    line 172:    CxxOp(                 "+", 2, 13, T, F, T),  // ADD
    line 173:    CxxOp(                 "-", 2, 13, T, F, F),  // SUBTRACT
    line 174:    CxxOp(                "<<", 2, 12, T, F, F),  // LEFT_SHIFT
    line 175:    CxxOp(                ">>", 2, 12, T, F, F),  // RIGHT_SHIFT
    line 176:    CxxOp(                 "<", 2, 11, T, F, T),  // LESS
    line 177:    CxxOp(                "<=", 2, 11, T, F, T),  // LESS_OR_EQUAL
    line 178:    CxxOp(                 ">", 2, 11, T, F, T),  // GREATER
    line 179:    CxxOp(                ">=", 2, 11, T, F, T),  // GREATER_OR_EQUAL
    line 180:    CxxOp(                "==", 2, 10, T, F, T),  // EQUALITY
    line 181:    CxxOp(                "!=", 2, 10, T, F, T),  // INEQUALITY
    line 182:    CxxOp(                 "&", 2,  9, T, F, T),  // BITWISE_AND
    line 183:    CxxOp(                 "^", 2,  8, T, F, T),  // BITWISE_XOR
    line 184:    CxxOp(                 "|", 2,  7, T, F, T),  // BITWISE_OR
    line 185:    CxxOp(                "&&", 2,  6, T, F, T),  // LOGICAL_AND
    line 186:    CxxOp(                "||", 2,  5, T, F, T),  // LOGICAL_OR
    line 187:    CxxOp(                 "?", 3,  4, F, F, F),  // CONDITIONAL
    line 188:    CxxOp(                 "=", 2,  3, T, T, F),  // ASSIGN
    line 189:    CxxOp(                "*=", 2,  3, T, T, F),  // MULTIPLY_ASSIGN
    line 190:    CxxOp(                "/=", 2,  3, T, T, F),  // DIVIDE_ASSIGN
    line 191:    CxxOp(                "%=", 2,  3, T, T, F),  // MODULO_ASSIGN
    line 192:    CxxOp(                "+=", 2,  3, T, T, F),  // ADD_ASSIGN
    line 193:    CxxOp(                "-=", 2,  3, T, T, F),  // SUBTRACT_ASSIGN
    line 194:    CxxOp(               "<<=", 2,  3, T, T, F),  // LEFT_SHIFT_ASSIGN
    line 195:    CxxOp(               ">>=", 2,  3, T, T, F),  // RIGHT_SHIFT_ASSIGN
    line 196:    CxxOp(                "&=", 2,  3, T, T, F),  // BITWISE_AND_ASSIGN
    line 197:    CxxOp(                "^=", 2,  3, T, T, F),  // BITWISE_XOR_ASSIGN
    line 198:    CxxOp(                "|=", 2,  3, T, T, F),  // BITWISE_OR_ASSIGN
    line 199:    CxxOp(           THROW_STR, 0,  2, F, T, F),  // THROW
    line 200:    CxxOp(                 ",", 2,  1, F, F, F),  // STATEMENT_SEPARATOR
    line 201:    CxxOp(                 "$", 0,  0, F, F, F),  // START_OF_EXPRESSION
    line 202:    CxxOp(           ERROR_STR, 0,  0, F, F, F),  // FALSE
    line 203:    CxxOp(           ERROR_STR, 0,  0, F, F, F),  // TRUE
    line 204:    CxxOp(           ERROR_STR, 0,  0, F, F, F),  // NULLPTR
    line 205:    CxxOp(           ERROR_STR, 0,  0, F, F, F)   // NIL_OPERATOR
C:/Users/gregu/Documents/tsf/tsf/ct/Cxx.h:
  W026 Unused function
    line 408:    Numeric(NumericType type, size_t width, bool sign)
C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.cpp:
  W009 Cast down the inheritance hierarchy
    line 194:       if((type == Cxx::Function) && (usingClass->GetTemplate() == this) &&
    line 207:          auto args = static_cast< ClassInst* >(usingClass)->GetSpec()->Args();
    line 1037:    auto area = static_cast< CxxArea* >(GetScope());
    line 1040:    if(inst != nullptr) return static_cast< ClassInst* >(inst);
    line 1057:          auto c = static_cast< Class* >(*s);
    line 1828:       auto func = static_cast< const Function* >(item);
    line 1854:       auto func = static_cast< const Function* >(item);
  W010 Cast removes const qualification
    line 1361:    return const_cast< Class* >(this);
    line 1824:       return const_cast< ClassInst* >(this);
  W050 Default constructor invoked: POD members not initialized
    line 1038:    SymbolView view;
    line 1340:    DataInitAttrs attrs;
    line 1577:    SymbolView local;
  W098 Function does not invoke Debug::ft
    line 250: void Class::AccessibilityTo(const CxxScope* scope, SymbolView* view) const
    line 359: void Class::AddItem(CxxNamed* item)
    line 1358: Class* Class::GetTemplate() const
    line 1613: Class* Class::OuterClass() const
    line 1620: bool Class::SetCurrAccess(Cxx::Access access)
    line 2290: Function* CxxArea::FoundFunc(Function* func, SymbolView* view, TypeMatch match)
    line 2298: const FunctionPtrVector* CxxArea::FuncVector(const string& name) const
C:/Users/gregu/Documents/tsf/tsf/ct/CxxArea.h:
  W006 C-style cast
    line 414:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  W009 Cast down the inheritance hierarchy
    line 766:       const { return static_cast< Namespace* >(GetScope()); }
  W010 Cast removes const qualification
    line 128:       override { return const_cast< CxxArea* >(this); }
    line 414:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
    line 451:       override { return const_cast< Class* >(this); }
    line 804:       override { return const_cast< Namespace* >(this); }
  W017 Using statement in header
    line 21: using namespace NodeBase;
  W036 Member could be private
    line 102:    Typedef* FindType(const std::string& name) const;
    line 144:    Enum* FindEnum(const std::string& name) const;
    line 148:    Enumerator* FindEnumerator(const std::string& name) const;
    line 334:    Function* FindFuncByRole(FunctionRole role, bool base) const;
    line 338:    FunctionDefinition GetFuncDefinition(const Function* func) const;
    line 765:    Namespace* OuterSpace()
    line 771:    Namespace* FindNamespace(const std::string& name) const;
  W037 Member could be protected
    line 62:    const ClassPtrVector* Classes() const { return &classes_; }
    line 70:    const EnumPtrVector* Enums() const { return &enums_; }
    line 74:    const ForwardPtrVector* Forws() const { return &forws_; }
  W054 Base class constructor is public
    line 220:    Class(QualNamePtr& name, Cxx::ClassTag tag);
  W069 Virtual function is public
    line 111:    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
    line 119:    virtual Function* MatchFunc(const Function* curr, bool base) const;
    line 249:    virtual ClassInst* EnsureInstance(const TypeName* type);
    line 257:    virtual Class* BaseClass()
    line 262:    virtual BaseDecl* GetBaseDecl() const { return base_.get(); }
    line 290:    virtual bool DerivesFrom(const Class* cls) const;
    line 405:    virtual bool AddAnonymousUnion(ClassPtr& cls) override;
    line 422:    virtual void CheckIfUsed(Warning warning) const override;
    line 430:    virtual Class* DirectClass() const override { return GetClass(); }
    line 791:    virtual CxxScoped* FindItem(const std::string& name) const override;
  W077 Virtual function defines default argument
    line 111:    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
    line 444:    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
    line 785:    virtual Function* FindFunc(const std::string& name, StackArgVector* args,
  W080 Argument could be const
    line 162/1:    virtual bool AddAnonymousUnion(ClassPtr& cls) { return false; }
  W084 Function could be free
    line 166:    static Function* FoundFunc
    line 551:    static size_t CreateCodeError(const std::string& name, debug32_t offset);
C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.cpp:
  W009 Cast down the inheritance hierarchy
    line 831:       auto macro = static_cast< Macro* >(ref_);
    line 844:       auto macro = static_cast< Macro* >(ref_);
  W050 Default constructor invoked: POD members not initialized
    line 826:    SymbolView view;
  W098 Function does not invoke Debug::ft
    line 32: void AlignLeft(ostream& stream, const string& prefix)
    line 135: CxxToken* Define::AutoType() const
C:/Users/gregu/Documents/tsf/tsf/ct/CxxDirective.h:
  W017 Using statement in header
    line 18: using namespace NodeBase;
  W036 Member could be private
    line 227:    virtual CxxToken* GetValue() const = 0;
    line 267:    virtual CxxToken* RootType() const override { return GetValue(); }
  W037 Member could be protected
    line 720:    const std::string& GetText() const { return text_; }
  W044 Data is not private
    line 292:    size_t refs_ : 16;
  W069 Virtual function is public
    line 227:    virtual CxxToken* GetValue() const = 0;
    line 232:    virtual bool IsDefined() const { return true; }
    line 238:    virtual void SetExpr(ExprPtr& rhs);
    line 267:    virtual CxxToken* RootType() const override { return GetValue(); }
    line 402:    virtual bool AddElif(Elif* e) { return false; }
    line 406:    virtual bool AddElse(const Else* e) { return false; }
    line 415:    virtual bool HasCompiledCode() const { return compile_; }
    line 456:    virtual void AddCondition(ExprPtr& c) override { condition_ = std::move(c); }
C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.cpp:
  W007 Functional cast
    line 1325:    if(count >= 0) return size_t(count);
  W009 Cast down the inheritance hierarchy
    line 1260:       auto thisClass = static_cast< Class* >(thisRoot);
    line 1268:             auto thatClass = static_cast< Class* >(thatRoot);
    line 1403:    if(AutoType_.SetAutoTypeOn(*static_cast< FuncData* >(item)))
    line 1447:    auto ref = static_cast< CxxNamed* >(item);
    line 1571:          static_cast< Class* >(root)->BlockCopied(this);
  W052 Default copy constructor invoked
    line 144:    arg_(arg)
  W069 Virtual function is public
    line 48:    virtual bool Display(std::ostream& stream) override;
    line 60:    virtual bool Display(std::ostream& stream) override;
    line 76:    virtual bool Display(std::ostream& stream) override;
    line 92:    virtual bool Display(std::ostream& stream) override;
    line 112:    virtual bool Display(std::ostream& stream) override;
  W098 Function does not invoke Debug::ft
    line 237: bool Context::OptionIsOn(char opt)
    line 244: bool Context::ParsingTemplateInstance()
    line 384: void Context::Trace(CxxTrace::Action act)
    line 392: void Context::Trace(CxxTrace::Action act, const StackArg& arg)
    line 400: void Context::Trace(CxxTrace::Action act, word err, const string& expl)
    line 408: void Context::Trace(CxxTrace::Action act, const CodeFile& file)
    line 416: void Context::Trace(CxxTrace::Action act, const CxxToken* token)
    line 424: void Context::WasCalled(Function* func)
    line 591: OptionalCode* ParseFrame::Optional() const
    line 778: CxxScope* ParseFrame::Scope() const
C:/Users/gregu/Documents/tsf/tsf/ct/CxxExecute.h:
  W017 Using statement in header
    line 18: using namespace NodeBase;
  W019 Unused argument
    line 566/1:    static void Shutdown(RestartLevel level);
    line 570/1:    static void Startup(RestartLevel level) { }
  W026 Unused function
    line 111:    size_t Arrays() const;
    line 246:    bool operator!=(const StackArg& that) const;
  W036 Member could be private
    line 245:    bool operator==(const StackArg& that) const;
    line 527:    static size_t GetPos() { return Frame_->GetPos(); }
  W044 Data is not private
    line 254:    CxxToken* item;
  W047 Data could be const
    line 278:    CxxToken* via_;
  W076 Adjacent arguments have the same type
    line 217:    TypeMatch CalcMatchWith(const StackArg& that, const std::string& thisType,
    line 263:    TypeMatch MatchWith(const StackArg& that, const std::string& thisType,
  W080 Argument could be const
    line 258/1:    bool SetAutoTypeOn(FuncData& data) const;
  W084 Function could be free
    line 274:    static void ContextFunctionIsNonConst();
    line 570:    static void Startup(RestartLevel level) { }
C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.cpp:
  W007 Functional cast
    line 645:    if(arrays_ != nullptr) count += TagCount(arrays_->size());
    line 1293:    if(arrays_ != nullptr) count += TagCount(arrays_->size());
  W009 Cast down the inheritance hierarchy
    line 343:          space = static_cast< Namespace* >(item);
    line 358:          cls = static_cast< Class* >(item);
    line 403:          return static_cast< Enum* >(item)->FindEnumerator(name);
    line 411:             auto tdef = static_cast< Typedef* >(item);
    line 416:             item = static_cast< CxxScoped* >(root);
    line 427:             item = static_cast< CxxScoped* >(ref);
    line 705:    return static_cast< Class* >(root);
    line 1000:          auto cls = static_cast< Class* >(ref);
    line 1157:       auto cls = static_cast< Class* >(ref);
    line 1990:          ref = static_cast< ClassInst* >(cls)->FindTemplateAnalog(ref);
    line 2000:       ref = static_cast< Function* >(ref)->FindRootFunc();
  W010 Cast removes const qualification
    line 927:    return const_cast< DataSpec* >(this);
    line 1335:    const_cast< DataSpec* >(this)->FindReferent();
    line 2570:    return const_cast< TypeName* >(this);
  W050 Default constructor invoked: POD members not initialized
    line 827:    SymbolView view;
    line 2138:    SymbolView view;
  W098 Function does not invoke Debug::ft
    line 133: CxxArea* CxxNamed::GetArea() const
    line 142: Class* CxxNamed::GetClass() const
    line 151: id_t CxxNamed::GetDeclFid() const
    line 160: Namespace* CxxNamed::GetSpace() const
    line 169: const TemplateParms* CxxNamed::GetTemplateParms() const
    line 178: bool CxxNamed::IsInTemplateInstance() const
    line 492: void CxxNamed::strName(ostream& stream, bool fq, const QualName* name) const
    line 889: Numeric DataSpec::GetNumeric() const
    line 909: CxxScope* DataSpec::GetScope() const
    line 918: TypeTags DataSpec::GetTags() const
    line 925: TypeSpec* DataSpec::GetTypeSpec() const
    line 1068: bool DataSpec::IsAutoDecl() const
    line 1871: CxxNamed* QualName::DirectType() const
    line 1926: CxxScoped* QualName::GetForward() const
    line 2063: TypeName* QualName::Names_at(size_t index) const
    line 2072: TypeName* QualName::Names_back() const
    line 2079: size_t QualName::Names_size() const
    line 2826: void TypeSpec::AddArray(ArraySpecPtr& array)
    line 2833: void TypeSpec::AdjustPtrs(TagCount count)
    line 2848: TagCount TypeSpec::ArrayCount() const
    line 2856: TagCount TypeSpec::Arrays() const
    line 2864: TypeSpec* TypeSpec::Clone() const
    line 2886: void TypeSpec::EnterArrays() const
    line 2893: void TypeSpec::EnteringScope(const CxxScope* scope)
    line 2900: TypeTags TypeSpec::GetTags() const
    line 2910: bool TypeSpec::HasArrayDefn() const
    line 2918: void TypeSpec::Instantiating() const
    line 2925: bool TypeSpec::MatchesExactly(const TypeSpec* that) const
    line 2933: TypeMatch TypeSpec::MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
    line 2942: TypeMatch TypeSpec::MatchTemplateArg(const TypeSpec* that) const
    line 2973: TagCount TypeSpec::PtrCount(bool arrays) const
    line 2981: TagCount TypeSpec::Ptrs(bool arrays) const
    line 2989: TagCount TypeSpec::RefCount() const
    line 2997: TagCount TypeSpec::Refs() const
    line 3005: void TypeSpec::RemoveRefs()
    line 3012: StackArg TypeSpec::ResultType() const
    line 3020: void TypeSpec::SetArrayPos(int8_t pos)
    line 3027: void TypeSpec::SetConst(bool readonly)
    line 3034: void TypeSpec::SetConstPtr(bool constptr)
    line 3052: void TypeSpec::SetPtrDetached(bool on)
    line 3059: void TypeSpec::SetPtrs(TagCount ptrs)
    line 3066: void TypeSpec::SetRefDetached(bool on)
    line 3073: void TypeSpec::SetReferent(CxxNamed* ref, UsingMode mode)
    line 3080: void TypeSpec::SetRefs(TagCount refs)
C:/Users/gregu/Documents/tsf/tsf/ct/CxxNamed.h:
  W006 C-style cast
    line 1010:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  W010 Cast removes const qualification
    line 517:       override { return const_cast< QualName* >(this); }
    line 1010:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  W017 Using statement in header
    line 21: using namespace NodeBase;
  W036 Member could be private
    line 452:    TypeName* Names_back() const;
  W037 Member could be protected
    line 106:    bool IsInternal() const { return decl_.internal; }
    line 246:    void Accessed() const;
    line 256:    void DisplayReferent(std::ostream& stream, bool fq) const;
    line 260:    std::string strLocation() const;
    line 265:    void strName(std::ostream& stream, bool fq, const QualName* name) const;
    line 751:    Cxx::ItemType GetLocale() const { return locale_; }
    line 755:    TemplateRole GetTemplateRole() const { return role_; }
  W047 Data could be const
    line 58:    bool const_ : 1;       // type is const
    line 59:    bool constptr_ : 1;    // pointer is const
    line 62:    TagCount refs_ : 8;    // number of references
  W056 Member not included in member initialization list
    line 587:       TypeNamePtrVector* names_;  // the names in a qualified name
  W069 Virtual function is public
    line 97:    virtual void SetDecl(CodeFile* file, size_t pos) { decl_.SetLoc(file, pos); }
    line 111:    virtual bool IsDeclaredInFunction() const { return false; }
    line 119:    virtual bool IsStatic() const { return true; }
    line 124:    virtual CxxScope* GetScope() const { return nullptr; }
    line 130:    virtual void SetScope(CxxScope* scope) const { }
    line 134:    virtual void SetAccess(Cxx::Access access) { }
    line 139:    virtual void SetTemplateParms(TemplateParmsPtr& parms);
    line 145:    virtual const TemplateParms* GetTemplateParms() const;
    line 153:    virtual Class* GetTemplate() const { return nullptr; }
    line 159:    virtual std::string QualifiedName(bool scopes, bool templates)
    line 165:    virtual std::string ScopedName(bool templates) const;
    line 170:    virtual CxxArea* GetArea() const;
    line 175:    virtual Function* GetFunction() const { return nullptr; }
    line 179:    virtual Cxx::Access GetAccess() const { return Cxx::Public; }
    line 183:    virtual id_t GetDeclFid() const;
    line 200:    virtual bool EnterScope() { return true; }
    line 210:    virtual bool IsImplemented() const { return true; }
    line 215:    virtual bool FindReferent();
    line 219:    virtual void SetAsReferent(const CxxNamed* user) { }
    line 224:    virtual bool Instantiate() { return false; }
    line 228:    virtual bool IsInTemplateInstance() const;
    line 235:    virtual StackArg NameToArg(Cxx::Operator op);
    line 241:    virtual StackArg MemberToArg(StackArg& via, Cxx::Operator op);
    line 508:    virtual CxxNamed* DirectType() const override;
    line 553:    virtual bool ResolveTypedef(Typedef* type) const override;
    line 557:    virtual bool ResolveTemplate
    line 570:    virtual void SubclassAccess(Class* cls) const override;
    line 747:    virtual void SetLocale(Cxx::ItemType locale);
    line 759:    virtual Function* GetFuncSpec() const { return nullptr; }
    line 770:    virtual TypeSpec* Clone() const = 0;
    line 774:    virtual void AddArray(ArraySpecPtr& array) = 0;
    line 778:    virtual void SetConst(bool readonly) = 0;
    line 782:    virtual void SetConstPtr(bool constptr) = 0;
    line 786:    virtual void SetPtrs(TagCount ptrs) = 0;
    line 790:    virtual void SetRefs(TagCount refs) = 0;
    line 794:    virtual void SetArrayPos(int8_t pos) = 0;
    line 798:    virtual void SetPtrDetached(bool on) = 0;
    line 802:    virtual void SetRefDetached(bool on) = 0;
    line 807:    virtual void SetReferent(CxxNamed* ref, UsingMode mode) = 0;
    line 813:    virtual TagCount Ptrs(bool arrays) const = 0;
    line 819:    virtual TagCount Refs() const = 0;
    line 824:    virtual TagCount Arrays() const = 0;
    line 828:    virtual bool HasArrayDefn() const = 0;
    line 832:    virtual void EnteringScope(const CxxScope* scope) = 0;
    line 836:    virtual void EnterArrays() const = 0;
    line 840:    virtual TypeTags GetTags() const = 0;
    line 845:    virtual std::string TypeTagsString(const TypeTags& tags) const = 0;
    line 850:    virtual void DisplayTags(std::ostream& stream) const = 0;
    line 854:    virtual void DisplayArrays(std::ostream& stream) const = 0;
    line 860:    virtual void AdjustPtrs(TagCount count) = 0;
    line 865:    virtual void RemoveRefs() = 0;
    line 870:    virtual TagCount PtrCount(bool arrays) const = 0;
    line 874:    virtual TagCount RefCount() const = 0;
    line 878:    virtual TagCount ArrayCount() const = 0;
    line 883:    virtual bool MatchesExactly(const TypeSpec* that) const = 0;
    line 887:    virtual StackArg ResultType() const = 0;
    line 891:    virtual void SetTemplateRole(TemplateRole role) const { role_ = role; }
    line 902:    virtual TypeMatch MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
    line 908:    virtual TypeMatch MatchTemplateArg(const TypeSpec* that) const = 0;
    line 913:    virtual std::string AlignTemplateArg(const TypeSpec* thatArg) const = 0;
    line 919:    virtual void Instantiating() const = 0;
  W076 Adjacent arguments have the same type
    line 499:    TypeMatch MatchTemplate(const QualName* that,
    line 687:    TypeMatch MatchTemplate(const TypeName* that,
    line 902:    virtual TypeMatch MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
  W082 Function could be const
    line 428:    void Append(const std::string& name, bool space = false);
C:/Users/gregu/Documents/tsf/tsf/ct/CxxRoot.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.cpp:
  W009 Cast down the inheritance hierarchy
    line 1278:    auto cls = static_cast< Class* >(root);
    line 1346:          auto op = static_cast< Operation* >(expr);
    line 1651:       if(anon) StackArg::SetAutoTypeFor(static_cast< FuncData& >(*next_));
    line 1697:    auto data = static_cast< FuncData* >(next_.get());
    line 2477:       if(!static_cast< Function* >(item)->virtual_)
    line 2828:             static_cast< ClassData* >(data)->SetInit(m->get());
    line 3028:    return static_cast< Function* >((*cti)->FindInstanceAnalog(this));
    line 4330:       auto func = static_cast< ClassInst* >(cls)->FindTemplateAnalog(this);
    line 4331:       if(func != nullptr) ++static_cast< Function* >(func)->calls_;
  W010 Cast removes const qualification
    line 2119:    return FoundFunc(const_cast< Function* >(this), args, match);
    line 2992:    auto prev = const_cast< Function* >(this);
    line 3385:    func->SetTemplate(const_cast< Function* >(this));
  W050 Default constructor invoked: POD members not initialized
    line 1284:       SymbolView view;
  W051 Default constructor invoked
    line 3163:    CxxUsageSets usages;
  W098 Function does not invoke Debug::ft
    line 98: bool Block::CrlfOver(Form form) const
    line 217: CxxToken* Block::FirstStatement() const
    line 225: Function* Block::GetFunction() const
    line 264: bool Block::InLine() const
    line 778: id_t CxxScope::GetDistinctDeclFid() const
    line 1374: bool Data::IsConst() const
    line 1382: bool Data::IsConstPtr() const
    line 1507: bool Data::WasRead()
    line 3033: Function* Function::FoundFunc
    line 3062: FunctionRole Function::FuncRole() const
    line 3098: FunctionType Function::FuncType() const
    line 3108: void Function::GetDefnRange(size_t& begin, size_t& end) const
    line 3116: CxxScope* Function::GetScope() const
    line 3615: bool Function::IsInTemplateInstance() const
    line 3993: void Function::SetDefnRange(size_t begin, size_t end)
    line 4352: void FuncSpec::AddArray(ArraySpecPtr& array)
    line 4359: void FuncSpec::AdjustPtrs(TagCount count)
    line 4373: TagCount FuncSpec::ArrayCount() const
    line 4380: TagCount FuncSpec::Arrays() const
    line 4387: void FuncSpec::Check() const
    line 4395: TypeSpec* FuncSpec::Clone() const
    line 4417: void FuncSpec::EnterArrays() const
    line 4436: bool FuncSpec::FindReferent()
    line 4444: TypeTags FuncSpec::GetTags() const
    line 4451: TypeName* FuncSpec::GetTemplateArgs() const
    line 4458: TypeSpec* FuncSpec::GetTypeSpec() const
    line 4465: bool FuncSpec::HasArrayDefn() const
    line 4472: void FuncSpec::Instantiating() const
    line 4480: bool FuncSpec::IsConst() const
    line 4487: bool FuncSpec::IsConstPtr() const
    line 4494: bool FuncSpec::MatchesExactly(const TypeSpec* that) const
    line 4502: TypeMatch FuncSpec::MatchTemplate(TypeSpec* that, stringVector& tmpltParms,
    line 4512: TypeMatch FuncSpec::MatchTemplateArg(const TypeSpec* that) const
    line 4534: TagCount FuncSpec::PtrCount(bool arrays) const
    line 4541: TagCount FuncSpec::Ptrs(bool arrays) const
    line 4548: TagCount FuncSpec::RefCount() const
    line 4555: TagCount FuncSpec::Refs() const
    line 4562: void FuncSpec::RemoveRefs()
    line 4569: StackArg FuncSpec::ResultType() const
    line 4576: void FuncSpec::SetArrayPos(int8_t pos)
    line 4584: void FuncSpec::SetConst(bool readonly)
    line 4592: void FuncSpec::SetConstPtr(bool constptr)
    line 4600: void FuncSpec::SetPtrDetached(bool on)
    line 4608: void FuncSpec::SetPtrs(TagCount ptrs)
    line 4616: void FuncSpec::SetRefDetached(bool on)
    line 4624: void FuncSpec::SetReferent(CxxNamed* ref, UsingMode mode)
    line 4632: void FuncSpec::SetRefs(TagCount refs)
C:/Users/gregu/Documents/tsf/tsf/ct/CxxScope.h:
  W006 C-style cast
    line 331:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  W010 Cast removes const qualification
    line 331:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
    line 1084:       const override { return const_cast< Function* >(this); }
  W023 Unused enumerator
    line 137:       Multiple   // two statements or more
  W036 Member could be private
    line 962:    size_t MinArgs() const;
    line 967:    size_t MaxArgs() const { return args_.size(); }
    line 1029:    bool IsInvokedInBase() const;
  W037 Member could be protected
    line 289:    bool IsExtern() const { return extern_; }
    line 293:    bool IsConstexpr() const { return constexpr_; }
    line 297:    bool WasInited() const { return inited_; }
  W069 Virtual function is public
    line 66:    virtual Cxx::Access GetCurrAccess() const { return Cxx::Private; }
    line 71:    virtual bool HasUsingFor(const std::string& name, size_t prefix)
    line 79:    virtual void AccessibilityOf
    line 321:    virtual void Promote
    line 389:    virtual void SetDefn(CodeFile* file, size_t pos) override;
    line 1054:    virtual void CheckAccessControl() const override;
    line 1058:    virtual void CheckIfHiding() const override;
    line 1143:    virtual void SetDefn(CodeFile* file, size_t pos) override;
    line 1160:    virtual void WasCalled() override;
  W076 Adjacent arguments have the same type
    line 321:    virtual void Promote
    line 1236:    static TypeMatch MatchTemplate
  W084 Function could be free
    line 1236:    static TypeMatch MatchTemplate
    line 1249:    static Function* InstantiateError
C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.cpp:
  W006 C-style cast
    line 1194:    return (CxxToken*) this;
    line 1369:    return (CxxToken*) this;
  W009 Cast down the inheritance hierarchy
    line 64:          auto func = static_cast< Function* >(GetScope());
    line 256:    GetClass()->AddSubclass(static_cast< Class* >(Context::Scope()));
    line 292:    return static_cast< Class* >(name_->GetReferent());
    line 1357:          auto tf = (*t)->FindFriend(static_cast< const CxxScope* >(ref));
    line 1499:          space = static_cast< Namespace* >(item);
    line 1511:          cls = static_cast< Class* >(item);
    line 1549:             auto tdef = static_cast< Typedef* >(item);
    line 1554:             item = static_cast< CxxScoped* >(root);
    line 1827:       static_cast< CxxArea* >(scope)->AddFunc(func);
  W010 Cast removes const qualification
    line 1194:    return (CxxToken*) this;
    line 1369:    return (CxxToken*) this;
    line 1737:    const_cast< Friend* >(this)->FindReferent();
  W050 Default constructor invoked: POD members not initialized
    line 270:    SymbolView view;
    line 2302:    SymbolView view;
  W052 Default copy constructor invoked
    line 1906:    attrs_(Numeric::Nil)
  W098 Function does not invoke Debug::ft
    line 290: Class* BaseDecl::GetClass() const
    line 391: void CxxScoped::AddFiles(SetOfIds& imSet) const
    line 545: CodeFile* CxxScoped::GetImplFile() const
    line 554: bool CxxScoped::GetScopedName(string& name, size_t n) const
    line 563: bool CxxScoped::IsAuto() const
    line 572: bool CxxScoped::IsConst() const
    line 581: bool CxxScoped::IsConstPtr() const
    line 590: bool CxxScoped::IsDeclaredInFunction() const
    line 598: bool CxxScoped::IsDefinedIn(const CxxArea* area) const
    line 611: bool CxxScoped::IsIndirect() const
    line 1126: void Enumerator::RecordAccess(Cxx::Access access) const
    line 1190: CxxToken* Forward::AutoType() const
    line 1365: CxxToken* Friend::AutoType() const
    line 1620: Function* Friend::GetFunction() const
    line 1629: QualName* Friend::GetQualName() const
    line 1638: CxxNamed* Friend::GetReferent() const
C:/Users/gregu/Documents/tsf/tsf/ct/CxxScoped.h:
  W006 C-style cast
    line 146:    virtual CxxNamed* Referent() const override { return (CxxNamed*) this; }
    line 451:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
    line 541:    virtual CxxToken* AutoType() const override { return (CxxNamed*) enum_; }
    line 942:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
    line 1018:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  W010 Cast removes const qualification
    line 146:    virtual CxxNamed* Referent() const override { return (CxxNamed*) this; }
    line 451:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
    line 541:    virtual CxxToken* AutoType() const override { return (CxxNamed*) enum_; }
    line 942:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
    line 1018:    virtual CxxToken* AutoType() const override { return (CxxToken*) this; }
  W017 Using statement in header
    line 20: using namespace NodeBase;
  W037 Member could be protected
    line 38:    CodeFile* GetImplFile() const;
    line 57:    virtual bool GetScopedName(std::string& name, size_t n) const;
    line 79:    CxxScoped* FindInheritedName() const;
    line 84:    void DisplayFiles(std::ostream& stream) const;
    line 97:    FileRole GetFileRole(const CodeFile* file) const;
    line 105:    virtual bool IsUnused() const { return false; }
  W069 Virtual function is public
    line 57:    virtual bool GetScopedName(std::string& name, size_t n) const;
    line 61:    virtual void AccessibilityTo(const CxxScope* scope, SymbolView* view) const;
    line 70:    virtual void RecordAccess(Cxx::Access access) const;
    line 89:    virtual CodeFile* GetDefnFile() const { return nullptr; }
    line 93:    virtual size_t GetDefnPos() const { return std::string::npos; }
    line 101:    virtual void AddFiles(SetOfIds& imSet) const;
    line 105:    virtual bool IsUnused() const { return false; }
    line 460:    virtual void CheckAccessControl() const override;
    line 823:    virtual bool ResolveTemplate
    line 1182:    virtual bool ResolveTypedef(Typedef* type) const override { return false; }
C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.cpp:
  W098 Function does not invoke Debug::ft
    line 255: void CxxStatement::EnterBlock()
    line 324: bool Do::InLine() const
    line 520: bool For::InLine() const
    line 614: bool If::InLine() const
    line 978: bool While::InLine() const
C:/Users/gregu/Documents/tsf/tsf/ct/CxxStatement.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.cpp:
  W076 Adjacent arguments have the same type
    line 25: size_t FindTemplateBegin(const string& name, size_t pos, size_t depth);
    line 42: size_t RfindScopeOperator(const string& name, size_t begin, size_t end);
C:/Users/gregu/Documents/tsf/tsf/ct/CxxString.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W026 Unused function
    line 44:    std::string& Prefix(std::string&& scope);
  W076 Adjacent arguments have the same type
    line 101:    size_t Replace(std::string& code,
C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.cpp:
  W009 Cast down the inheritance hierarchy
    line 368:    return static_cast< Macro* >(macros.front());
    line 407:       if((*s)->ScopedName(false) == name) return static_cast< CxxScope* >(*s);
    line 415:       if((*c)->ScopedName(false) == name) return static_cast< CxxScope* >(*c);
    line 423:       if(pos != string::npos) return static_cast< CxxScope* >(*s);
    line 429:       if(pos != string::npos) return static_cast< CxxScope* >(*c);
  W050 Default constructor invoked: POD members not initialized
    line 601:    SymbolView view;
  W098 Function does not invoke Debug::ft
    line 75: template< typename T > void Erase(const CxxScoped* item,
    line 173: template< typename T > void ListSymbols(const string& name,
    line 210: void CxxSymbols::EraseClass(const Class* cls)
    line 217: void CxxSymbols::EraseData(const Data* data)
    line 224: void CxxSymbols::EraseEnum(const Enum* item)
    line 231: void CxxSymbols::EraseEtor(const Enumerator* etor)
    line 238: void CxxSymbols::EraseForw(const Forward* forw)
    line 245: void CxxSymbols::EraseFriend(const Friend* frnd)
    line 252: void CxxSymbols::EraseFunc(const Function* func)
    line 281: void CxxSymbols::EraseMacro(const Macro* macro)
    line 288: void CxxSymbols::EraseSpace(const Namespace* space)
    line 295: void CxxSymbols::EraseTerm(const Terminal* term)
    line 302: void CxxSymbols::EraseType(const Typedef* type)
    line 647: void CxxSymbols::InsertClass(Class* cls)
    line 654: void CxxSymbols::InsertData(Data* data)
    line 661: void CxxSymbols::InsertEnum(Enum* item)
    line 668: void CxxSymbols::InsertEtor(Enumerator* etor)
    line 675: void CxxSymbols::InsertForw(Forward* forw)
    line 682: void CxxSymbols::InsertFriend(Friend* frnd)
    line 689: void CxxSymbols::InsertFunc(Function* func)
    line 723: void CxxSymbols::InsertMacro(Macro* macro)
    line 730: void CxxSymbols::InsertSpace(Namespace* space)
    line 737: void CxxSymbols::InsertTerm(Terminal* term)
    line 744: void CxxSymbols::InsertType(Typedef* type)
C:/Users/gregu/Documents/tsf/tsf/ct/CxxSymbols.h:
  W017 Using statement in header
    line 24: using namespace NodeBase;
  W082 Function could be const
    line 109:    void InsertClass(Class* cls);
    line 110:    void InsertData(Data* data);
    line 111:    void InsertEtor(Enumerator* etor);
    line 112:    void InsertEnum(Enum* item);
    line 113:    void InsertForw(Forward* forw);
    line 114:    void InsertFriend(Friend* frnd);
    line 115:    void InsertFunc(Function* func);
    line 116:    void InsertMacro(Macro* macro);
    line 117:    void InsertSpace(Namespace* space);
    line 118:    void InsertTerm(Terminal* term);
    line 119:    void InsertType(Typedef* type);
    line 124:    void EraseClass(const Class* cls);
    line 125:    void EraseData(const Data* data);
    line 126:    void EraseEtor(const Enumerator* etor);
    line 127:    void EraseEnum(const Enum* item);
    line 128:    void EraseForw(const Forward* forw);
    line 129:    void EraseFriend(const Friend* frnd);
    line 130:    void EraseFunc(const Function* func);
    line 131:    void EraseMacro(const Macro* macro);
    line 132:    void EraseSpace(const Namespace* space);
    line 133:    void EraseTerm(const Terminal* term);
    line 134:    void EraseType(const Typedef* type);
    line 135:    void EraseLocal(const CxxScoped* name);
    line 139:    void EraseLocals();
  W101 Override of Base.Display not found
    line 72: class CxxSymbols: public Temporary
C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.cpp:
  W007 Functional cast
    line 815:          stream << uint64_t(num_);
  W009 Cast down the inheritance hierarchy
    line 393:    auto oper = static_cast< Operation* >(item.get());
    line 419:          auto ante = static_cast< Operation* >(prev.get());
    line 471:       auto oper = static_cast< Operation* >(item.get());
    line 504:    auto oper = static_cast< Operation* >(prev.get());
    line 533:       auto oper = static_cast< Operation* >(item.get());
    line 575:    auto oper = static_cast< Operation* >(item.get());
    line 598:       auto ante = static_cast< Operation* >(prev.get());
    line 702:    Context::PushOp(static_cast< Operation* >(StartOfExpr.get()));
    line 1066:       inClass = static_cast< Class* >(inRoot);
    line 1071:       outClass = static_cast< Class* >(outRoot);
    line 1096:    auto call = static_cast< Operation* >(args_.front().get());
    line 1483:       func = static_cast< Function* >(proc.item);
    line 1501:       cls = static_cast< Class* >(proc.item);
    line 1596:    auto dtor = static_cast< Class* >
    line 1645:       auto newCall = static_cast< Operation* >(args_.front().get());
    line 1665:    auto cls = static_cast< Class* >(spec.item->Root());
    line 1686:       auto ctorCall = static_cast< Operation* >(args_[2].get());
    line 1710:       cls = static_cast< Class* >(root);
    line 1894:       area = static_cast< Class* >(targ);
    line 1896:       static_cast< Class* >(targ)->Instantiate();
    line 2231:    auto cls = static_cast< Class* >(root);
    line 2270:       static_cast< QualName* >(arg2.item)->MemberAccessed(cls, mem);
    line 2293:          mem = static_cast< Function* >(mem)->InstantiateFunction(tmplt);
  W010 Cast removes const qualification
    line 282:    CxxToken* prev = const_cast< CxxToken* >(this);
  W050 Default constructor invoked: POD members not initialized
    line 2476:    SymbolView view;
  W098 Function does not invoke Debug::ft
    line 327: void CxxUsageSets::AddBase(const CxxNamed* item)
    line 335: void CxxUsageSets::AddDirect(const CxxNamed* item)
    line 343: void CxxUsageSets::AddForward(const CxxNamed* item)
    line 354: void CxxUsageSets::AddIndirect(const CxxNamed* item)
    line 362: void CxxUsageSets::AddUsing(const CxxNamed* item)
    line 716: Numeric FloatLiteral::GetNumeric() const
    line 777: Numeric IntLiteral::GetNumeric() const
C:/Users/gregu/Documents/tsf/tsf/ct/CxxToken.h:
  W010 Cast removes const qualification
    line 274:    virtual CxxToken* RootType() const { return const_cast< CxxToken* >(this); }
  W017 Using statement in header
    line 23: using namespace NodeBase;
  W052 Default copy constructor invoked
    line 340:       : num_(num), tags_(tags) { CxxStats::Incr(CxxStats::INT_LITERAL); }
    line 376:       : num_(num), tags_(tags) { CxxStats::Incr(CxxStats::FLOAT_LITERAL); }
  W069 Virtual function is public
    line 64:    virtual Cxx::ItemType Type() const { return Cxx::Undefined; }
    line 70:    virtual const std::string* Name() const;
    line 74:    virtual QualName* GetQualName() const { return nullptr; }
    line 79:    virtual std::string TypeString(bool arg) const { return ERROR_STR; }
    line 83:    virtual TypeSpec* GetTypeSpec() const { return nullptr; }
    line 87:    virtual bool IsConst() const { return false; }
    line 91:    virtual bool IsConstPtr() const { return false; }
    line 96:    virtual bool IsAuto() const { return false; }
    line 101:    virtual bool IsIndirect() const { return false; }
    line 105:    virtual bool IsInitializing() const { return false; }
    line 114:    virtual CxxToken* AutoType() const { return nullptr; }
    line 119:    virtual Namespace* GetSpace() const { return nullptr; }
    line 124:    virtual Class* GetClass() const { return nullptr; }
    line 129:    virtual Class* Declarer() const { return GetClass(); }
    line 135:    virtual TypeName* GetTemplateArgs() const;
    line 140:    virtual Numeric GetNumeric() const { return Numeric::Nil; }
    line 144:    virtual void GetConvertibleTypes(StackArgVector& types) { }
    line 149:    virtual CxxNamed* Referent() const;
    line 155:    virtual void EnterBlock();
    line 160:    virtual void ExitBlock() { }
    line 166:    virtual bool AppendUnary() { return false; }
    line 170:    virtual CxxToken* Back() { return this; }
    line 175:    virtual bool WasRead() { return false; }
    line 187:    virtual bool WasWritten(const StackArg* arg, bool passed);
    line 192:    virtual bool SetNonConst() { return true; }
    line 197:    virtual void WasMutated(const StackArg* arg) { }
    line 203:    virtual void RecordUsage() const { }
    line 208:    virtual void GetUsages(const CodeFile& file, CxxUsageSets& symbols) const { }
    line 212:    virtual void Check() const { }
    line 216:    virtual std::string Trace() const { return EMPTY_STR; }
    line 220:    virtual bool InLine() const { return true; }
    line 225:    virtual void Print(std::ostream& stream) const;
    line 230:    virtual void Shrink() { }
  W076 Adjacent arguments have the same type
    line 587:    Function* FindNewOrDelete(const StackArg& arg, bool del, bool& pod) const;
  W082 Function could be const
    line 160:    virtual void ExitBlock() { }
  W084 Function could be free
    line 263:    static void ShrinkExpression(const ExprPtr& expr);
    line 576:    static void PushType(const std::string& name);
C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.cpp:
  W007 Functional cast
    line 140:          type = LibTokenType(i);
  W084 Function could be free
    line 36:    static const OperatorInfo* GetAttrs(LibTokenType type);
  W091 Line contains adjacent spaces
    line 78:    OperatorInfo(" ",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpNil
    line 79:    OperatorInfo("(",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpLeftPar
    line 80:    OperatorInfo(")",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpRightPar
    line 81:    OperatorInfo("&",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpIntersection
    line 82:    OperatorInfo("-",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpDifference
    line 83:    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpUnion
    line 84:    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpAutoUnion
    line 85:    OperatorInfo("d",  1, DIR_SET,  FILE_SET, ERR_SET),   // OpDirectories
    line 86:    OperatorInfo("f",  1, FILE_SET, DIR_SET,  ERR_SET),   // OpFiles
C:/Users/gregu/Documents/tsf/tsf/ct/Interpreter.h:
  W017 Using statement in header
    line 23: using namespace NodeBase;
  W084 Function could be free
    line 49:    static bool IsOperator(const std::string& s);
  W101 Override of Base.Display not found
    line 31: class Interpreter : public Temporary
C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.cpp:
  W007 Functional cast
    line 823:          oper = Cxx::Operator(match->second);
  W009 Cast down the inheritance hierarchy
    line 1498:          auto def = static_cast< Define* >(item);
    line 1502:             auto code = const_cast< string* >(source_);
  W010 Cast removes const qualification
    line 1502:             auto code = const_cast< string* >(source_);
  W050 Default constructor invoked: POD members not initialized
    line 650:       IntLiteral::Tags tags;
    line 697:       FloatLiteral::Tags tags;
    line 761:    IntLiteral::Tags tags;
    line 1481:    SymbolView view;
C:/Users/gregu/Documents/tsf/tsf/ct/Lexer.h:
  W036 Member could be private
    line 97:    std::string NextOperator() const;
    line 214:    bool ThisCharIs(char c);
  W041 Data is init-only
    line 391:    static bool Initialized;
  W076 Adjacent arguments have the same type
    line 110:    size_t FindClosing(char lhc, char rhc, size_t pos = std::string::npos) const;
  W084 Function could be free
    line 47:    static bool IsValidIdentifier(const std::string& id);
C:/Users/gregu/Documents/tsf/tsf/ct/Library.cpp:
  W009 Cast down the inheritance hierarchy
    line 77:    sourcePathCfg_.reset
C:/Users/gregu/Documents/tsf/tsf/ct/Library.h:
  W017 Using statement in header
    line 29: using namespace NodeBase;
  W036 Member could be private
    line 54:    CodeDir* FindDir(const std::string& name) const;
    line 75:    LibrarySet* FindVar(const std::string& name) const;
  W042 Data is write-only
    line 211:    LibraryVarSet* varSet_;
  W076 Adjacent arguments have the same type
    line 49:    word Import
    line 91:    word Assign(const std::string& name,
  W082 Function could be const
    line 59:    CodeFile* EnsureFile(const std::string& file, CodeDir* dir = nullptr);
    line 91:    word Assign(const std::string& name,
C:/Users/gregu/Documents/tsf/tsf/ct/LibraryErrSet.cpp:
  W098 Function does not invoke Debug::ft
    line 87: word LibraryErrSet::Error(string& expl) const
C:/Users/gregu/Documents/tsf/tsf/ct/LibraryErrSet.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/ct/LibraryItem.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.cpp:
  W008 reinterpret_cast
    line 257:    auto fake = reinterpret_cast< const LibrarySet* >(&local);
  W098 Function does not invoke Debug::ft
    line 60: LibrarySet* LibrarySet::AffectedBy() const
    line 67: LibrarySet* LibrarySet::Affecters() const
    line 74: LibrarySet* LibrarySet::Assign(LibrarySet* rhs)
    line 92: LibrarySet* LibrarySet::CommonAffecters() const
    line 142: LibrarySet* LibrarySet::Create(const string& name, SetOfIds* set) const
    line 149: LibrarySet* LibrarySet::Difference(const LibrarySet* that) const
    line 156: LibrarySet* LibrarySet::Directories() const
    line 175: LibrarySet* LibrarySet::FileName(const LibrarySet* that) const
    line 182: LibrarySet* LibrarySet::Files() const
    line 189: LibrarySet* LibrarySet::FileType(const LibrarySet* that) const
    line 207: LibrarySet* LibrarySet::FoundIn(const LibrarySet* that) const
    line 226: LibrarySet* LibrarySet::Implements() const
    line 233: LibrarySet* LibrarySet::Intersection(const LibrarySet* that) const
    line 240: bool LibrarySet::IsReadOnly() const
    line 247: bool LibrarySet::IsTemporary() const
    line 274: LibrarySet* LibrarySet::MatchString(const LibrarySet* that) const
    line 281: LibrarySet* LibrarySet::NeededBy() const
    line 288: LibrarySet* LibrarySet::Needers() const
    line 297: word LibrarySet::NotImplemented(string& expl) const
    line 323: LibrarySet* LibrarySet::OpError() const
    line 439: LibrarySet* LibrarySet::Union(const LibrarySet* that) const
    line 446: LibrarySet* LibrarySet::UsedBy(bool self) const
    line 453: LibrarySet* LibrarySet::Users(bool self) const
C:/Users/gregu/Documents/tsf/tsf/ct/LibrarySet.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
  W036 Member could be private
    line 46:    bool IsReadOnly() const;
    line 147:    static ptrdiff_t LinkDiff();
  W037 Member could be protected
    line 125:    virtual LibrarySet* Create(const std::string& name, SetOfIds* set) const;
  W047 Data could be const
    line 195:    Q2Link link_;
  W059 Base class virtual destructor is not public
    line 163:    virtual ~LibrarySet();
  W069 Virtual function is public
    line 54:    virtual LibSetType GetType() const;
    line 60:    virtual word Check(std::ostream& stream, std::string& expl) const;
    line 66:    virtual word Count(std::string& result) const;
    line 72:    virtual word Countlines(std::string& result) const;
    line 77:    virtual word Format(std::string& expl) const;
    line 83:    virtual word List(std::ostream& stream, std::string& expl) const;
    line 91:    virtual word Parse(std::string& expl, const std::string& opts) const;
    line 97:    virtual word Scan(std::ostream& stream,
    line 104:    virtual word Show(std::string& result) const;
    line 110:    virtual word Sort(std::ostream& stream, std::string& expl) const;
    line 116:    virtual word Trim(std::ostream& stream, std::string& expl) const;
    line 125:    virtual LibrarySet* Create(const std::string& name, SetOfIds* set) const;
    line 126:    virtual LibrarySet* Assign(LibrarySet* rhs);
    line 127:    virtual LibrarySet* Intersection(const LibrarySet* that) const;
    line 128:    virtual LibrarySet* Difference(const LibrarySet* that) const;
    line 129:    virtual LibrarySet* Union(const LibrarySet* that) const;
    line 130:    virtual LibrarySet* Directories() const;
    line 131:    virtual LibrarySet* Files() const;
    line 132:    virtual LibrarySet* FileName(const LibrarySet* that) const;
    line 133:    virtual LibrarySet* FileType(const LibrarySet* that) const;
    line 134:    virtual LibrarySet* MatchString(const LibrarySet* that) const;
    line 135:    virtual LibrarySet* FoundIn(const LibrarySet* that) const;
    line 136:    virtual LibrarySet* Implements() const;
    line 137:    virtual LibrarySet* UsedBy(bool self) const;
    line 138:    virtual LibrarySet* Users(bool self) const;
    line 139:    virtual LibrarySet* AffectedBy() const;
    line 140:    virtual LibrarySet* Affecters() const;
    line 141:    virtual LibrarySet* CommonAffecters() const;
    line 142:    virtual LibrarySet* NeededBy() const;
    line 143:    virtual LibrarySet* Needers() const;
  W084 Function could be free
    line 167:    static word Counted(std::string& result, const size_t* count);
    line 172:    static word Shown(std::string& result);
C:/Users/gregu/Documents/tsf/tsf/ct/LibraryTypes.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/ct/Parser.cpp:
  W009 Cast down the inheritance hierarchy
    line 239:    auto op = static_cast< Operation* >(call.get());
    line 488:    auto brace = static_cast< BraceInit* >(token.get());
    line 562:    auto cast = static_cast< Operation* >(token.get());
    line 601:    auto c = static_cast< Catch* >(statement.get());
    line 698:    static_cast< ClassData* >(data.get())->SetMutable(mute);
    line 699:    static_cast< ClassData* >(data.get())->SetWidth(width);
    line 858:    auto cond = static_cast< Operation* >(token.get());
    line 1132:    auto cast = static_cast< Operation* >(token.get());
    line 1238:    auto op = static_cast< Operation* >(token.get());
    line 1261:    auto delOp = static_cast< Operation* >(token.get());
    line 1289:    auto d = static_cast< Do* >(statement.get());
    line 1483:    auto f = static_cast< For* >(statement.get());
    line 1583:       static_cast< FuncData* >(data.get())->SetExpression(expr);
    line 1632:          curr = static_cast< FuncData* >(data.get());
    line 1638:          curr = static_cast< FuncData* >(subseq.get());
    line 1891:             static_cast< If* >(first)->SetElseIf();
    line 1897:    auto i = static_cast< If* >(statement.get());
    line 2026:    auto inner = static_cast< Namespace* >(outer)->EnsureNamespace(name);
    line 2068:    auto newOp = static_cast< Operation* >(token.get());
    line 2558:    static_cast< Return* >(statement.get())->AddExpr(expr);
    line 2605:    auto op = static_cast< Operation* >(token.get());
    line 2752:    auto op = static_cast< Operation* >(token.get());
    line 2778:    auto s = static_cast< Switch* >(statement.get());
    line 2860:    auto op = static_cast< Operation* >(token.get());
    line 2896:    auto t = static_cast< Try* >(statement.get());
    line 2954:    auto op = static_cast< Operation* >(token.get());
    line 3158:    auto w = static_cast< While* >(statement.get());
    line 3536:          auto op = static_cast< Operation* >(token)->Op();
  W050 Default constructor invoked: POD members not initialized
    line 983:             SymbolView view;
C:/Users/gregu/Documents/tsf/tsf/ct/Parser.h:
  W017 Using statement in header
    line 20: using namespace NodeBase;
  W026 Unused function
    line 172:    size_t GetCurr() const { return lexer_.Curr(); }
  W076 Adjacent arguments have the same type
    line 384:    static bool SetCompoundType
    line 428:    bool GetParExpr(ExprPtr& expr, bool omit, bool opt = false);
  W080 Argument could be const
    line 236/1:    bool GetStatements(BlockPtr& block, bool braced);
    line 334/1:    bool GetCtorInit(FunctionPtr& func);
    line 353/1:    bool GetArguments(FunctionPtr& func);
    line 385/1:       (QualNamePtr& name, Cxx::Type type, int size, int sign);
    line 443/1:    bool GetNum(ExprPtr& expr);
    line 444/1:    bool GetChar(ExprPtr& expr);
    line 445/1:    bool GetStr(ExprPtr& expr);
    line 455/1:    bool GetCast(ExprPtr& expr);
    line 456/1:    bool GetPrecedence(ExprPtr& expr);
    line 463/1:    bool HandleTilde(ExprPtr& expr, size_t start);
    line 467/1:    bool GetSubscript(ExprPtr& expr);
    line 476/1:    bool GetCxxCast(ExprPtr& expr, Cxx::Operator op);
    line 477/1:    bool GetConditional(ExprPtr& expr);
    line 478/1:    bool GetDefined(ExprPtr& expr);
    line 479/1:    bool GetDelete(ExprPtr& expr, Cxx::Operator op);
    line 480/1:    bool GetNew(ExprPtr& expr, Cxx::Operator op);
    line 481/1:    bool GetSizeOf(ExprPtr& expr);
    line 482/1:    bool GetThrow(ExprPtr& expr);
    line 483/1:    bool GetTypeId(ExprPtr& expr);
    line 551/1:    bool Punt(ExprPtr& expr, size_t end);
  W084 Function could be free
    line 384:    static bool SetCompoundType
    line 571:    static std::string Indent();
C:/Users/gregu/Documents/tsf/tsf/ct/SetOperations.h:
  W076 Adjacent arguments have the same type
    line 18:    void SetDifference
    line 27:    void SetIntersection
    line 36:    void SetUnion
C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.cpp:
  W008 reinterpret_cast
    line 49:    auto fake = reinterpret_cast< const Circuit* >(&local);
C:/Users/gregu/Documents/tsf/tsf/mb/Circuit.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
    line 18: using namespace SessionBase;
  W047 Data could be const
    line 75:    RegCell port_;
  W069 Virtual function is public
    line 49:    virtual std::string Name() const = 0;
    line 53:    virtual bool Supports(ProtocolId prid) const { return false; }
C:/Users/gregu/Documents/tsf/tsf/mb/MbModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/mb/MbPools.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/mb/MediaEndpt.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
    line 20: using namespace SessionBase;
  W019 Unused argument
    line 94/1:    virtual void ProcessIcMsg(Message& msg);
  W026 Unused function
    line 43:    StateId GetState() const { return state_; }
    line 47:    virtual void SetState(StateId stid);
    line 57:    ProtocolSM* MgwPsm() const;
    line 63:    virtual void Deallocate();
    line 72:    static void* operator new(size_t size);
    line 77:    explicit MediaEndpt(MediaPsm& psm);
  W036 Member could be private
    line 89:    virtual void EndOfTransaction();
  W069 Virtual function is public
    line 47:    virtual void SetState(StateId stid);
    line 63:    virtual void Deallocate();
  W071 Virtual function has no overrides
    line 47:    virtual void SetState(StateId stid);
    line 63:    virtual void Deallocate();
    line 89:    virtual void EndOfTransaction();
    line 94:    virtual void ProcessIcMsg(Message& msg);
C:/Users/gregu/Documents/tsf/tsf/mb/MediaFailureEvent.h:
  W017 Using statement in header
    line 18: using namespace NodeBase;
    line 19: using namespace SessionBase;
  W020 Unused class
    line 27: class MediaFailureEvent : public Event
  W026 Unused function
    line 33:    MediaFailureEvent(ServiceSM& owner, MediaEndpt& mep);
    line 41:    MediaEndpt* Mep() const { return mep_; }
C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.cpp:
  W008 reinterpret_cast
    line 103:    reinterpret_cast< const MediaInfo* >(bytes)->Display(stream, prefix);
  W098 Function does not invoke Debug::ft
    line 92: CliParm* MediaParameter::CreateCliParm(Usage use) const
C:/Users/gregu/Documents/tsf/tsf/mb/MediaParameter.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
    line 17: using namespace SessionBase;
  W036 Member could be private
    line 38:    bool operator==(const MediaInfo& that) const;
C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.cpp:
  W008 reinterpret_cast
    line 560:       auto cxi = reinterpret_cast< MediaInfo* >(pptr->bytes);
  W009 Cast down the inheritance hierarchy
    line 238:    if(root->Sid() != TestServiceId) return static_cast< MediaSsm* >(root);
  W098 Function does not invoke Debug::ft
    line 244: MediaPsm* MediaPsm::GetOgPsm() const
C:/Users/gregu/Documents/tsf/tsf/mb/MediaPsm.h:
  W017 Using statement in header
    line 22: using namespace NodeBase;
    line 23: using namespace SessionBase;
  W026 Unused function
    line 105:    MediaEndpt* Mep() const { return mep_; }
  W036 Member could be private
    line 117:    Tone::Id GetOgTone() const { return ogTone_; }
    line 155:    void SetOgPort(Switch::PortId ogport);
    line 174:    virtual Event* ReceiveMsg(Message& msg) override;
    line 178:    virtual void PrepareOgMsgq() override;
  W069 Virtual function is public
    line 53:    virtual void SetOgPsm(MediaPsm* ogPsm);
    line 58:    virtual void SetOgTone(Tone::Id ogTone);
    line 63:    virtual void SetIcTone(Tone::Id icTone);
  W071 Virtual function has no overrides
    line 53:    virtual void SetOgPsm(MediaPsm* ogPsm);
    line 58:    virtual void SetOgTone(Tone::Id ogTone);
    line 63:    virtual void SetIcTone(Tone::Id icTone);
C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.cpp:
  W009 Cast down the inheritance hierarchy
    line 79:       auto mpsm = static_cast< MediaPsm* >(psm);
    line 103:       auto mpsm = static_cast< MediaPsm* >(psm);
C:/Users/gregu/Documents/tsf/tsf/mb/MediaSsm.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
  W026 Unused function
    line 33:    virtual bool SetMgwPsm(ProtocolSM* psm);
  W069 Virtual function is public
    line 33:    virtual bool SetMgwPsm(ProtocolSM* psm);
  W071 Virtual function has no overrides
    line 33:    virtual bool SetMgwPsm(ProtocolSM* psm);
C:/Users/gregu/Documents/tsf/tsf/mb/Switch.cpp:
  W098 Function does not invoke Debug::ft
    line 82: Circuit* Switch::GetCircuit(PortId pid) const
C:/Users/gregu/Documents/tsf/tsf/mb/Switch.h:
  W017 Using statement in header
    line 22: using namespace NodeBase;
  W084 Function could be free
    line 50:    static bool IsValidPort(PortId pid)
C:/Users/gregu/Documents/tsf/tsf/mb/ToneRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 64: Tone* ToneRegistry::GetTone(Tone::Id tid) const
C:/Users/gregu/Documents/tsf/tsf/mb/ToneRegistry.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/mb/Tones.cpp:
  W008 reinterpret_cast
    line 51:    auto fake = reinterpret_cast< const Tone* >(&local);
C:/Users/gregu/Documents/tsf/tsf/mb/Tones.h:
  W007 Functional cast
    line 50:    Id Tid() const { return Id(tid_.GetId()); }
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W026 Unused function
    line 50:    Id Tid() const { return Id(tid_.GetId()); }
  W032 Member hides inherited name
    line 54:    static ptrdiff_t CellDiff();
  W059 Base class virtual destructor is not public
    line 67:    virtual ~Tone();
C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.cpp:
  W006 C-style cast
    line 18:    return (void*) ((ptr_t) ptr2 - diff);
    line 25:    return (void*) ((ptr_t) ptr1 + diff);
    line 62:    return ((ptr_t) ptr1 - (ptr_t) ptr2);
  W010 Cast removes const qualification
    line 18:    return (void*) ((ptr_t) ptr2 - diff);
    line 25:    return (void*) ((ptr_t) ptr1 + diff);
    line 62:    return ((ptr_t) ptr1 - (ptr_t) ptr2);
  W011 Pointer arithmetic
    line 18:    return (void*) ((ptr_t) ptr2 - diff);
C:/Users/gregu/Documents/tsf/tsf/nb/Algorithms.h:
  W076 Adjacent arguments have the same type
    line 35:    uint64_t pack3(uint16_t a, uint16_t b, uint16_t c);
    line 39:    uint64_t pack4(uint16_t a, uint16_t b, uint16_t c, uint16_t d);
C:/Users/gregu/Documents/tsf/tsf/nb/Array.h:
  W091 Line contains adjacent spaces
    line 238:    inline static fn_name Array_ctor()     { return "Array.ctor"; }
    line 239:    inline static fn_name Array_dtor()     { return "Array.dtor"; }
    line 240:    inline static fn_name Array_Init()     { return "Array.Init"; }
    line 241:    inline static fn_name Array_Reserve()  { return "Array.Reserve"; }
    line 243:    inline static fn_name Array_Erase()    { return "Array.Erase"; }
    line 244:    inline static fn_name Array_Replace()  { return "Array.Replace"; }
    line 245:    inline static fn_name Array_Extend()   { return "Array.Extend"; }
C:/Users/gregu/Documents/tsf/tsf/nb/Base.cpp:
  W008 reinterpret_cast
    line 118:    auto obj = reinterpret_cast< ObjectStruct* >(this);
    line 146:    auto obj = reinterpret_cast< const ObjectStruct* >(this);
  W010 Cast removes const qualification
    line 83:       objects[count++] = const_cast< Base* >(this);
  W098 Function does not invoke Debug::ft
    line 113: void Base::Nullify(size_t n)
    line 142: Base::vptr_t Base::Vptr() const
C:/Users/gregu/Documents/tsf/tsf/nb/Base.h:
  W036 Member could be private
    line 94:    virtual void Claim() { }
    line 137:    virtual MemoryType MemType() const { return MemPerm; }
  W037 Member could be protected
    line 63:    virtual void Display(std::ostream& stream,
    line 87:    void LogSubtended(std::ostream& stream,
  W069 Virtual function is public
    line 63:    virtual void Display(std::ostream& stream,
    line 82:    virtual void GetSubtended(Base* objects[], size_t& count) const;
    line 94:    virtual void Claim() { }
    line 99:    virtual void ClaimBlocks();
    line 117:    virtual void Cleanup() { }
    line 125:    virtual void Startup(RestartLevel level) { }
    line 133:    virtual void Shutdown(RestartLevel level) { }
    line 137:    virtual MemoryType MemType() const { return MemPerm; }
    line 141:    virtual const char* ClassName() const;
  W071 Virtual function has no overrides
    line 141:    virtual const char* ClassName() const;
C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.cpp:
  W098 Function does not invoke Debug::ft
    line 37: void CfgBitParm::Explain(string& expl) const
C:/Users/gregu/Documents/tsf/tsf/nb/CfgBitParm.h:
  W036 Member could be private
    line 51:    virtual bool SetNext(const std::string& input) override;
  W076 Adjacent arguments have the same type
    line 33:    CfgBitParm(const char* key, const char* def, const char* expl);
  W084 Function could be free
    line 61:    static fixed_string ValidTrueChars();
    line 66:    static fixed_string ValidFalseChars();
C:/Users/gregu/Documents/tsf/tsf/nb/CfgBoolParm.h:
  W036 Member could be private
    line 52:    virtual bool SetNextValue(bool value) override;
  W054 Base class constructor is public
    line 23:    CfgBoolParm(const char* key, const char* def, bool* field, const char* expl);
  W076 Adjacent arguments have the same type
    line 23:    CfgBoolParm(const char* key, const char* def, bool* field, const char* expl);
C:/Users/gregu/Documents/tsf/tsf/nb/CfgFlagParm.cpp:
  W098 Function does not invoke Debug::ft
    line 55: bool CfgFlagParm::GetCurrValue() const
C:/Users/gregu/Documents/tsf/tsf/nb/CfgFlagParm.h:
  W036 Member could be private
    line 50:    virtual bool SetNextValue(bool value) override;
  W047 Data could be const
    line 62:    FlagId fid_;
  W076 Adjacent arguments have the same type
    line 24:    CfgFlagParm(const char* key, const char* def,
C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.cpp:
  W098 Function does not invoke Debug::ft
    line 57: void CfgIntParm::Explain(string& expl) const
C:/Users/gregu/Documents/tsf/tsf/nb/CfgIntParm.h:
  W026 Unused function
    line 42:    word GetCurrValue() const { return *curr_; }
  W036 Member could be private
    line 66:    virtual bool SetNext(const std::string& input) override;
  W047 Data could be const
    line 78:    word min_;
    line 82:    word max_;
  W054 Base class constructor is public
    line 24:    CfgIntParm(const char* key, const char* def, word* field,
  W076 Adjacent arguments have the same type
    line 24:    CfgIntParm(const char* key, const char* def, word* field,
C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.cpp:
  W008 reinterpret_cast
    line 122:    auto fake = reinterpret_cast< const CfgParm* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/CfgParm.h:
  W036 Member could be private
    line 45:    const char* Key() const;
    line 60:    static ptrdiff_t LinkDiff();
  W047 Data could be const
    line 140:    Q1Link link_;
  W048 Data could be const pointer
    line 128:    const char* default_;
    line 132:    const char* expl_;
  W069 Virtual function is public
    line 49:    virtual void Explain(std::string& expl) const { expl = expl_; }
  W076 Adjacent arguments have the same type
    line 75:    CfgParm(const char* key, const char* def, const char* expl);
C:/Users/gregu/Documents/tsf/tsf/nb/CfgParmRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 259: void CfgParmRegistry::ListParms(ostream& stream, const string& prefix) const
C:/Users/gregu/Documents/tsf/tsf/nb/CfgParmRegistry.h:
  W026 Unused function
    line 75:    const std::vector< stringPtr >& GetMainArgs() const { return *mainArgs_; }
  W082 Function could be const
    line 79:    void AddMainArg(const std::string& arg);
C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.cpp:
  W098 Function does not invoke Debug::ft
    line 53: void CfgStrParm::Explain(string& expl) const
C:/Users/gregu/Documents/tsf/tsf/nb/CfgStrParm.h:
  W036 Member could be private
    line 86:    virtual bool SetNext(const std::string& input) override;
  W054 Base class constructor is public
    line 24:    CfgStrParm(const char* key, const char* def,
  W076 Adjacent arguments have the same type
    line 24:    CfgStrParm(const char* key, const char* def,
    line 77:    CfgFileTimeParm(const char* key, const char* def,
  W101 Override of Base.Display not found
    line 72: class CfgFileTimeParm : public CfgStrParm
C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.cpp:
  W008 reinterpret_cast
    line 75:    auto fake = reinterpret_cast< const CfgTuple* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/CfgTuple.h:
  W047 Data could be const
    line 102:    Q1Link link_;
  W084 Function could be free
    line 62:    static const std::string& ValidNameChars();
    line 67:    static const std::string& ValidValueChars();
    line 72:    static const std::string& ValidBlankChars();
C:/Users/gregu/Documents/tsf/tsf/nb/CinThread.cpp:
  W041 Data is init-only
    line 134:    FunctionGuard guard(FunctionGuard::MakeUnpreemptable);
  W099 Function does not invoke Debug::ft as first statement
    line 91:       Debug::ft(CinThread_Enter);
    line 136:    Debug::ft(CinThread_GetLine);
C:/Users/gregu/Documents/tsf/tsf/nb/Class.cpp:
  W006 C-style cast
    line 205:    if(addr != nullptr) return (Object*) addr;
  W008 reinterpret_cast
    line 60:    auto fake = reinterpret_cast< const Class* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/Class.h:
  W026 Unused function
    line 42:    virtual void Initialize();
    line 47:    virtual Object* Create();
    line 55:    virtual void FreeQuasiSingleton(Object* obj);
    line 104:    bool SetVptr(Object& obj);
    line 111:    bool SetTemplate(Object& obj);
    line 118:    bool SetQuasiSingleton(Object& obj);
  W036 Member could be private
    line 51:    virtual Object* GetQuasiSingleton();
    line 98:    virtual Object* New(size_t size);
  W059 Base class virtual destructor is not public
    line 92:    virtual ~Class();
  W069 Virtual function is public
    line 42:    virtual void Initialize();
    line 47:    virtual Object* Create();
    line 51:    virtual Object* GetQuasiSingleton();
    line 55:    virtual void FreeQuasiSingleton(Object* obj);
  W071 Virtual function has no overrides
    line 42:    virtual void Initialize();
    line 47:    virtual Object* Create();
    line 51:    virtual Object* GetQuasiSingleton();
    line 55:    virtual void FreeQuasiSingleton(Object* obj);
  W082 Function could be const
    line 98:    virtual Object* New(size_t size);
C:/Users/gregu/Documents/tsf/tsf/nb/ClassRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 64: Class* ClassRegistry::Lookup(ClassId cid) const
C:/Users/gregu/Documents/tsf/tsf/nb/CliAppData.h:
  W047 Data could be const
    line 78:    Id id_;
  W059 Base class virtual destructor is not public
    line 70:    virtual ~CliAppData();
  W069 Virtual function is public
    line 51:    virtual void EventOccurred(Event evt);
C:/Users/gregu/Documents/tsf/tsf/nb/CliBoolParm.h:
  W054 Base class constructor is public
    line 24:    explicit CliBoolParm(const char* help,
C:/Users/gregu/Documents/tsf/tsf/nb/CliBuffer.h:
  W080 Argument could be const
    line 87/1:       (CliThread& cli, const std::string& expl, std::streamsize p = -1) const;
C:/Users/gregu/Documents/tsf/tsf/nb/CliCharParm.h:
  W037 Member could be protected
    line 24:    CliCharParm(const char* help, const char* chars,
  W048 Data could be const pointer
    line 54:    const char* chars_;
  W054 Base class constructor is public
    line 24:    CliCharParm(const char* help, const char* chars,
  W076 Adjacent arguments have the same type
    line 24:    CliCharParm(const char* help, const char* chars,
C:/Users/gregu/Documents/tsf/tsf/nb/CliCommand.h:
  W069 Virtual function is public
    line 56:    virtual Rc GetTextParmRc
  W076 Adjacent arguments have the same type
    line 85:    CliCommand(const char* comm, const char* help, size_t size = 32);
  W084 Function could be free
    line 117:    static Rc Exhausted(CliThread& cli, const std::string& type);
C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.cpp:
  W008 reinterpret_cast
    line 64:    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
    line 144:    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
  W009 Cast down the inheritance hierarchy
    line 64:    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
    line 144:    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
C:/Users/gregu/Documents/tsf/tsf/nb/CliCommandSet.h:
  W076 Adjacent arguments have the same type
    line 43:    CliCommandSet(const char* comm, const char* help, size_t size = 32);
  W084 Function could be free
    line 48:    static void DescendTo(CliCookie& cookie, size_t index);
C:/Users/gregu/Documents/tsf/tsf/nb/CliCookie.cpp:
  W007 Functional cast
    line 110:       stream << int(index_[i]) << SPACE;
  W098 Function does not invoke Debug::ft
    line 121: size_t CliCookie::Index(size_t depth) const
C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.cpp:
  W008 reinterpret_cast
    line 88:    auto fake = reinterpret_cast< const CliIncrement* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/CliIncrement.h:
  W047 Data could be const
    line 90:    RegCell iid_;
  W048 Data could be const pointer
    line 94:    const char* name_;
    line 98:    const char* help_;
  W069 Virtual function is public
    line 50:    virtual void Enter();
    line 55:    virtual void Exit();
  W071 Virtual function has no overrides
    line 55:    virtual void Exit();
  W076 Adjacent arguments have the same type
    line 77:    CliIncrement(const char* name, const char* help, size_t size = 32);
C:/Users/gregu/Documents/tsf/tsf/nb/CliIntParm.h:
  W047 Data could be const
    line 64:    word min_;
    line 68:    word max_;
    line 72:    bool hex_;
  W054 Base class constructor is public
    line 34:    CliIntParm(const char* help, word min, word max,
  W076 Adjacent arguments have the same type
    line 34:    CliIntParm(const char* help, word min, word max,
C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.cpp:
  W008 reinterpret_cast
    line 81:    auto fake = reinterpret_cast< const CliParm* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/CliParm.h:
  W026 Unused function
    line 152:    bool GetCharParm(char& c, CliThread& cli) const;
  W037 Member could be protected
    line 142:    bool GetBoolParm(bool& b, CliThread& cli) const;
    line 162:    bool GetPtrParm(void*& p, CliThread& cli) const;
    line 188:    bool GetTextParm(id_t& i, std::string& s, CliThread& cli) const;
    line 210:    bool GetFileName(std::string& s, CliThread& cli) const;
    line 222:    bool GetIdentifier(std::string& s, CliThread& cli,
    line 233:    const char* Help() const { return help_; }
    line 237:    bool IsOptional() const { return opt_; }
  W048 Data could be const pointer
    line 316:    const char* help_;
    line 324:    const char* tag_;
  W069 Virtual function is public
    line 119:    virtual CliParm* AccessParm(CliCookie& cookie, size_t depth) const;
    line 127:    virtual void Explain(std::ostream& stream, col_t indent) const;
    line 137:    virtual Rc GetIntParmRc(word& i, CliThread& cli) const;
    line 147:    virtual Rc GetBoolParmRc(bool& b, CliThread& cli) const;
    line 157:    virtual Rc GetCharParmRc(char& c, CliThread& cli) const;
    line 167:    virtual Rc GetPtrParmRc(void*& p, CliThread& cli) const;
    line 195:    virtual Rc GetTextParmRc(id_t& i, std::string& s, CliThread& cli) const;
    line 205:    virtual Rc GetStringRc(std::string& s, CliThread& cli) const;
    line 215:    virtual Rc GetFileNameRc(std::string& s, CliThread& cli) const;
    line 228:    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  W076 Adjacent arguments have the same type
    line 222:    bool GetIdentifier(std::string& s, CliThread& cli,
    line 228:    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  W084 Function could be free
    line 307:    static Rc Mismatch(CliThread& cli, const std::string& type);
C:/Users/gregu/Documents/tsf/tsf/nb/CliPtrParm.cpp:
  W006 C-style cast
    line 83:          p = (void*) n;
C:/Users/gregu/Documents/tsf/tsf/nb/CliPtrParm.h:
  W037 Member could be protected
    line 23:    explicit CliPtrParm(const char* help,
  W054 Base class constructor is public
    line 23:    explicit CliPtrParm(const char* help,
C:/Users/gregu/Documents/tsf/tsf/nb/CliText.h:
  W036 Member could be private
    line 46:    const char* HelpText() const;
  W037 Member could be protected
    line 50:    const Registry< CliParm >& Parms() const { return parms_; }
  W048 Data could be const pointer
    line 95:    const char* text_;
  W054 Base class constructor is public
    line 33:    CliText(const char* help, const char* text,
  W069 Virtual function is public
    line 54:    virtual bool BindParm(CliParm& parm);
  W076 Adjacent arguments have the same type
    line 33:    CliText(const char* help, const char* text,
C:/Users/gregu/Documents/tsf/tsf/nb/CliTextParm.h:
  W054 Base class constructor is public
    line 34:    explicit CliTextParm(const char* help, bool opt = false,
C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.cpp:
  W098 Function does not invoke Debug::ft
    line 353: CliAppData* CliThread::GetAppData(CliAppData::Id aid) const
C:/Users/gregu/Documents/tsf/tsf/nb/CliThread.h:
  W026 Unused function
    line 98:    word Result() const { return result_; }
  W044 Data is not private
    line 164:    std::unique_ptr< CliBuffer > ibuf;
    line 168:    ostringstreamPtr obuf;
  W076 Adjacent arguments have the same type
    line 76:    char CharPrompt(const std::string& prompt,
  W082 Function could be const
    line 57:    word Report(word rc, const std::string& expl, col_t indent = 2);
    line 181:    const CliCommand* ParseCommand();
C:/Users/gregu/Documents/tsf/tsf/nb/Clock.h:
  W026 Unused function
    line 57:    ticks_t TicksPerSec();
    line 106:    ticks_t UsecsToTicks(usecs_t usecs);
    line 110:    const SysTime& TimeZero();
C:/Users/gregu/Documents/tsf/tsf/nb/CoutThread.cpp:
  W009 Cast down the inheritance hierarchy
    line 69:       auto req = static_cast< StreamRequest* >(msg);
  W041 Data is init-only
    line 118:    FunctionGuard
C:/Users/gregu/Documents/tsf/tsf/nb/CoutThread.h:
  W084 Function could be free
    line 32:    static void Spool(const char* s, bool eol = false);
C:/Users/gregu/Documents/tsf/tsf/nb/Debug.cpp:
  W098 Function does not invoke Debug::ft
    line 120: void Debug::Reset()
  W099 Function does not invoke Debug::ft as first statement
    line 49:    Debug::ft(Debug_GenerateSwLog);
C:/Users/gregu/Documents/tsf/tsf/nb/Debug.h:
  W026 Unused function
    line 81:    static void noop();
  W076 Adjacent arguments have the same type
    line 57:    static void SwErr
    line 77:    static void Progress(const std::string& s, bool eol, bool force = false);
  W084 Function could be free
    line 66:    static void Assert(bool condition, debug32_t errval = 0)
    line 77:    static void Progress(const std::string& s, bool eol, bool force = false);
    line 81:    static void noop();
    line 125:    static void GenerateSwLog(fn_name_arg func, const std::string& errstr,
C:/Users/gregu/Documents/tsf/tsf/nb/Dynamic.h:
  W026 Unused function
    line 41:    static void* operator new[](size_t size);
C:/Users/gregu/Documents/tsf/tsf/nb/Element.h:
  W084 Function could be free
    line 31:    static std::string strTimePlace();
C:/Users/gregu/Documents/tsf/tsf/nb/Exception.cpp:
  W099 Function does not invoke Debug::ft as first statement
    line 30:    Debug::ft(Exception_ctor1);
C:/Users/gregu/Documents/tsf/tsf/nb/Exception.h:
  W026 Unused function
    line 45:    Exception(const Exception& that);
    line 46:    Exception(Exception&& that);
  W059 Base class virtual destructor is not public
    line 50:    virtual ~Exception() noexcept;
  W069 Virtual function is public
    line 30:    virtual void Display(std::ostream& stream, const std::string& prefix) const;
C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.cpp:
  W009 Cast down the inheritance hierarchy
    line 202:       auto req = static_cast< FileRequest* >(msg);
  W026 Unused function
    line 39:    FileRequest(const FileRequest& that);
  W041 Data is init-only
    line 272:    FunctionGuard
C:/Users/gregu/Documents/tsf/tsf/nb/FileThread.h:
  W076 Adjacent arguments have the same type
    line 42:    static void Spool(const std::string& name,
  W084 Function could be free
    line 29:    static ostringstreamPtr CreateStream();
    line 42:    static void Spool(const std::string& name,
    line 47:    static void Truncate(const std::string& name);
C:/Users/gregu/Documents/tsf/tsf/nb/Formatters.h:
  W026 Unused function
    line 51:    std::string strHex(uint16_t n, int width = -1, bool prefix = true);
  W076 Adjacent arguments have the same type
    line 61:    std::string strIndex(int n, int width = 0, bool colon = true);
    line 81:    std::string strCenter(const std::string& s, int breadth, int blanks);
C:/Users/gregu/Documents/tsf/tsf/nb/FunctionName.cpp:
  W098 Function does not invoke Debug::ft
    line 25: int FunctionName::compare(fn_name_arg func, const char* str)
    line 32: size_t FunctionName::find(fn_name_arg func, const char* str)
    line 41: size_t FunctionName::rfind(fn_name_arg func, const char* str)
C:/Users/gregu/Documents/tsf/tsf/nb/FunctionName.h:
  W026 Unused function
    line 24:    size_t find(fn_name_arg func, const char* str);
C:/Users/gregu/Documents/tsf/tsf/nb/FunctionTrace.cpp:
  W006 C-style cast
    line 371:          auto src = (ptr_t) this;
  W009 Cast down the inheritance hierarchy
    line 76:       auto curr = static_cast< FunctionTrace* >(rec);
    line 110:       auto curr = static_cast< FunctionTrace* >(rec);
    line 174:                   auto last = static_cast< const FunctionTrace* >(rec);
    line 246:       auto curr = static_cast< FunctionTrace* >(rec);
    line 285:          curr = static_cast< FunctionTrace* >(rec);
    line 353:       curr = static_cast< FunctionTrace* >(rec);
    line 406:          auto curr = static_cast< FunctionTrace* >(rec);
    line 471:          auto curr = static_cast< FunctionTrace* >(rec);
C:/Users/gregu/Documents/tsf/tsf/nb/Immutable.h:
  W026 Unused function
    line 40:    static void* operator new[](size_t size);
C:/Users/gregu/Documents/tsf/tsf/nb/InitFlags.cpp:
  W098 Function does not invoke Debug::ft
    line 13: bool InitFlags::AllowBreak()
    line 24: bool InitFlags::CauseTimeout()
    line 33: bool InitFlags::ImmediateTrace()
    line 42: bool InitFlags::TraceInit()
    line 53: bool InitFlags::TraceWork()
C:/Users/gregu/Documents/tsf/tsf/nb/InitThread.cpp:
  W041 Data is init-only
    line 292:    FunctionGuard guard(FunctionGuard::MakeUnpreemptable);
C:/Users/gregu/Documents/tsf/tsf/nb/Log.h:
  W033 Class could be namespace
    line 19: class Log
  W084 Function could be free
    line 25:    static ostringstreamPtr Create(fixed_string title);
    line 30:    static void Spool(ostringstreamPtr& log);
    line 34:    static std::string FileName();
C:/Users/gregu/Documents/tsf/tsf/nb/LogThread.cpp:
  W009 Cast down the inheritance hierarchy
    line 74:       auto req = static_cast< StreamRequest* >(msg);
  W041 Data is init-only
    line 141:    FunctionGuard
C:/Users/gregu/Documents/tsf/tsf/nb/Memory.cpp:
  W006 C-style cast
    line 210:    auto seg = (Segment*) addr;
    line 267:    auto segment = (Segment*) getptr1(addr, SegmentHeader::Size());
    line 318:    auto source = (Segment*) getptr1(addr, SegmentHeader::Size());
    line 369:    auto source = (Segment*) getptr1(addr, SegmentHeader::Size());
  W084 Function could be free
    line 136:    static size_t Size();
  W098 Function does not invoke Debug::ft
    line 139: size_t SegmentHeader::Size()
    line 156: SysHeap* Memory::AccessHeap(MemoryType type)
    line 174: size_t Memory::Align(size_t size, size_t log2align)
    line 240: SysHeap* Memory::EnsureHeap(MemoryType type)
    line 294: const SysHeap* Memory::Heap(MemoryType type)
    line 388: size_t Memory::Words(size_t nBytes)
C:/Users/gregu/Documents/tsf/tsf/nb/Memory.h:
  W026 Unused function
    line 41:    static void Set(void* dest, byte_t value, size_t nBytes);
    line 64:    static bool Verify(MemoryType type, void* addr);
  W084 Function could be free
    line 29:    static size_t Align(size_t size, size_t log2align = BYTES_PER_WORD_LOG2);
    line 33:    static size_t Words(size_t nBytes);
    line 37:    static void Copy(void* dest, const void* source, size_t nBytes);
    line 41:    static void Set(void* dest, byte_t value, size_t nBytes);
    line 59:    static void* Realloc(void* addr, size_t nBytes);
    line 68:    static MemoryType Type(const void* addr);
    line 76:    static void Shutdown(RestartLevel level);
    line 84:    static SysHeap* EnsureHeap(MemoryType type);
    line 88:    static SysHeap* AccessHeap(MemoryType type);
C:/Users/gregu/Documents/tsf/tsf/nb/MemoryTrace.cpp:
  W009 Cast down the inheritance hierarchy
    line 51:       auto curr = static_cast< MemoryTrace* >(rec);
C:/Users/gregu/Documents/tsf/tsf/nb/MemoryTrace.h:
  W084 Function could be free
    line 42:    static const char* TypeString(MemoryType type);
C:/Users/gregu/Documents/tsf/tsf/nb/Module.cpp:
  W008 reinterpret_cast
    line 49:    auto fake = reinterpret_cast< const Module* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/Module.h:
  W026 Unused function
    line 88:    ModuleId Mid() const { return mid_.GetId(); }
    line 96:    virtual ModuleId* Dependencies(size_t& count) const;
  W059 Base class virtual destructor is not public
    line 131:    virtual ~Module();
  W069 Virtual function is public
    line 96:    virtual ModuleId* Dependencies(size_t& count) const;
  W071 Virtual function has no overrides
    line 96:    virtual ModuleId* Dependencies(size_t& count) const;
C:/Users/gregu/Documents/tsf/tsf/nb/ModuleRegistry.cpp:
  W007 Functional cast
    line 91:          return RestartLevel(errval_);
  W098 Function does not invoke Debug::ft
    line 137: Module* ModuleRegistry::GetModule(ModuleId mid) const
C:/Users/gregu/Documents/tsf/tsf/nb/ModuleRegistry.h:
  W084 Function could be free
    line 72:    static RestartLevel NextLevel();
C:/Users/gregu/Documents/tsf/tsf/nb/MsgBuffer.cpp:
  W098 Function does not invoke Debug::ft
    line 59: TraceStatus MsgBuffer::GetStatus() const
C:/Users/gregu/Documents/tsf/tsf/nb/MsgBuffer.h:
  W054 Base class constructor is public
    line 28:    MsgBuffer();
    line 32:    MsgBuffer(const MsgBuffer& that);
  W069 Virtual function is public
    line 49:    virtual TraceStatus GetStatus() const;
C:/Users/gregu/Documents/tsf/tsf/nb/MutexGuard.cpp:
  W099 Function does not invoke Debug::ft as first statement
    line 23:    Debug::ft(MutexGuard_ctor);
    line 36:       Debug::ft(MutexGuard_dtor);
C:/Users/gregu/Documents/tsf/tsf/nb/NbCliParms.cpp:
  W098 Function does not invoke Debug::ft
    line 99: word ExplainTraceRc(CliThread& cli, TraceRc rc)
C:/Users/gregu/Documents/tsf/tsf/nb/NbCliParms.h:
  W076 Adjacent arguments have the same type
    line 105: CliParm::Rc GetCBV(const CliCommand& comm, CliThread& cli, bool& c, bool& v);
C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.cpp:
  W007 Functional cast
    line 469:       rc = nbt->SelectFaction(Faction(id), TraceDefault);
    line 677:       rc = nbt->SelectFaction(Faction(id), TraceExcluded);
    line 1075:       rc = nbt->SelectFaction(Faction(id), TraceIncluded);
    line 2426:       auto heap = Memory::Heap(MemoryType(m));
  W008 reinterpret_cast
    line 573:    reinterpret_cast< const Base* >(p)->Output(*cli.obuf, 2, v);
    line 624:    strBytes(*cli.obuf, spaces(2), reinterpret_cast< const byte_t* >(p), n);
  W036 Member could be private
    line 1878:    static void SendAckToOutputFile(const CliThread& cli);
  W041 Data is init-only
    line 1682:    FunctionGuard guard(FunctionGuard::MakePreemptable, yield);
  W084 Function could be free
    line 742:    static word DisplayHelpFile(CliThread& cli, const string& name);
    line 1878:    static void SendAckToOutputFile(const CliThread& cli);
C:/Users/gregu/Documents/tsf/tsf/nb/NbIncrement.h:
  W021 Unused data
    line 138:    static const id_t LastNbIndex     = 3;
  W054 Base class constructor is public
    line 26:    StatusCommand();
    line 40:    SetWhatParm();
    line 53:    explicit SetCommand(bool bind = true);
    line 69:    IncludeWhatParm();
    line 83:    explicit IncludeCommand(bool bind = true);
    line 99:    ExcludeWhatParm();
    line 112:    explicit ExcludeCommand(bool bind = true);
    line 142:    explicit QueryCommand(bool bind = true);
    line 158:    SaveWhatParm();
    line 170:    explicit SaveCommand(bool bind = true);
    line 186:    ClearWhatParm();
    line 204:    explicit ClearCommand(bool bind = true);
  W102 Override of Object.Patch not found
    line 23: class StatusCommand : public CliCommand
    line 44: class SetCommand : public CliCommand
    line 73: class IncludeCommand : public CliCommand
    line 103: class ExcludeCommand : public CliCommand
    line 132: class QueryCommand : public CliCommand
    line 162: class SaveCommand : public CliCommand
    line 190: class ClearCommand : public CliCommand
C:/Users/gregu/Documents/tsf/tsf/nb/NbModule.h:
  W041 Data is init-only
    line 49:    static bool Registered;
  W084 Function could be free
    line 45:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.cpp:
  W007 Functional cast
    line 192:             stream << Faction(f) << CRLF;
  W098 Function does not invoke Debug::ft
    line 157: TraceStatus NbTracer::FactionStatus(Faction faction) const
C:/Users/gregu/Documents/tsf/tsf/nb/NbTracer.h:
  W036 Member could be private
    line 62:    static bool ThreadsEmpty();
  W084 Function could be free
    line 58:    static TraceRc SelectThread(ThreadId tid, TraceStatus status);
    line 62:    static bool ThreadsEmpty();
  W101 Override of Base.Display not found
    line 48: class NbTracer : public Permanent
  W102 Override of Object.Patch not found
    line 48: class NbTracer : public Permanent
C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.cpp:
  W095 Function not sorted in standard order
    line 61: char NodeBase::FactionChar(Faction faction)
  W098 Function does not invoke Debug::ft
    line 30: char NodeBase::BlockingReasonChar(BlockingReason reason)
    line 61: char NodeBase::FactionChar(Faction faction)
C:/Users/gregu/Documents/tsf/tsf/nb/NbTypes.h:
  W023 Unused enumerator
    line 29:    DispOption_N  // number of reasons; can be used to extend this enum
    line 59:    IdleFaction,         // idle thread (not used)
  W027 Unused typedef
    line 160: typedef std::basic_string<char, CharTraits, ImmAllocator<char>>  ImmString;
    line 161: typedef std::basic_string<char, CharTraits, PermAllocator<char>> PermString;
    line 162: typedef std::basic_string<char, CharTraits, ProtAllocator<char>> ProtString;
  W091 Line contains adjacent spaces
    line 159: typedef std::basic_string<char, CharTraits, DynAllocator<char>>  DynString;
    line 160: typedef std::basic_string<char, CharTraits, ImmAllocator<char>>  ImmString;
C:/Users/gregu/Documents/tsf/tsf/nb/Object.cpp:
  W008 reinterpret_cast
    line 126:    auto obj = reinterpret_cast< ObjectStruct* >(this);
  W098 Function does not invoke Debug::ft
    line 56: Object::ClassId Object::GetClassId() const
    line 67: bool Object::GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid)
    line 94: Object::ObjectId Object::GetObjectId() const
C:/Users/gregu/Documents/tsf/tsf/nb/Object.h:
  W026 Unused function
    line 80:    ClassId GetClassId() const;
    line 92:    ObjectId GetObjectId() const;
    line 98:    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid);
    line 106:    static void* operator new(size_t size, MemoryType type);
    line 107:    static void* operator new[](size_t size, MemoryType type);
    line 109:    static void operator delete[](void* addr);
    line 110:    static void operator delete(void* addr, MemoryType type);
    line 111:    static void operator delete[](void* addr, MemoryType type);
    line 120:    void MorphTo(Class& target);
  W036 Member could be private
    line 55:    typedef uint32_t InstanceId;  // identifies an object within a Class
    line 56:    typedef uint32_t ObjectId;    // ClassId (12 bits) + InstanceId (20 bits)
    line 86:    virtual InstanceId GetInstanceId() const;
  W037 Member could be protected
    line 33:    typedef uint8_t sel_t;
    line 42:    virtual void Patch(sel_t selector, void* arguments) { }
    line 54:    typedef id_t ClassId;         // identifies a Class
  W047 Data could be const
    line 125:    uintptr_t patchArea_;
  W069 Virtual function is public
    line 42:    virtual void Patch(sel_t selector, void* arguments) { }
    line 67:    virtual Class* GetClass() const;
    line 75:    virtual void PostInitialize() { }
    line 86:    virtual InstanceId GetInstanceId() const;
  W071 Virtual function has no overrides
    line 67:    virtual Class* GetClass() const;
    line 75:    virtual void PostInitialize() { }
    line 86:    virtual InstanceId GetInstanceId() const;
  W084 Function could be free
    line 98:    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid);
C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.cpp:
  W006 C-style cast
    line 223:       blocks_[currSegments_] = (uword*) Memory::Alloc(size, type_, false);
    line 246:          auto b = (ObjectBlock*) &seg[j];
    line 298:             auto b = (ObjectBlock*) &seg[j];
    line 335:             auto curr = (Pooled*) getptr1(item, diff);
    line 699:       return (ObjectBlock*) &blocks_[0][0];
    line 769:       return (ObjectBlock*) &blocks_[i][j];
    line 794:             auto b = (ObjectBlock*) &seg[j];
    line 826:    auto block = (ptr_t) ObjToBlock(obj);
    line 827:    auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
    line 831:       auto b0 = (ptr_t) &blocks_[i][0];
    line 874:    return (ObjectBlock*) getptr1(obj, BlockHeader::Size);
    line 904:          auto b = (ObjectBlock*) &seg[j];
  W008 reinterpret_cast
    line 462:    auto fake = reinterpret_cast< const ObjectPool* >(&local);
  W010 Cast removes const qualification
    line 827:    auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
  W091 Line contains adjacent spaces
    line 80:    CounterPtr      allocCount_;
    line 81:    CounterPtr      freeCount_;
    line 82:    CounterPtr      failCount_;
    line 83:    CounterPtr      auditCount_;
  W098 Function does not invoke Debug::ft
    line 262: size_t ObjectPool::AllocCount() const
    line 428: bool ObjectPool::BidToIndices(Bid bid, size_t& i, size_t& j) const
    line 683: size_t ObjectPool::FailCount() const
    line 728: size_t ObjectPool::FreeCount() const
    line 735: bool ObjectPool::IndicesToBid(size_t i, size_t j, Bid& bid) const
    line 747: size_t ObjectPool::InUseCount() const
    line 754: size_t ObjectPool::LowAvailCount() const
    line 761: ObjectBlock* ObjectPool::Next(Bid& bid) const
    line 780: Pooled* ObjectPool::NextUsed(Bid& bid) const
    line 853: ObjectPoolId ObjectPool::ObjPid(const Pooled* obj)
    line 862: PooledObjectSeqNo ObjectPool::ObjSeq(const Pooled* obj)
    line 871: ObjectBlock* ObjectPool::ObjToBlock(const Pooled* obj)
  W101 Override of Base.Display not found
    line 60: class ObjectPoolSizeCfg : public CfgIntParm
    line 73: class ObjectPoolStats : public Dynamic
C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPool.h:
  W007 Functional cast
    line 82:    ObjectPoolId Pid() const { return ObjectPoolId(pid_.GetId()); }
  W021 Unused data
    line 67:    static const Bid MaxBid = MaxSegments << ObjectsPerSegmentLog2;
  W036 Member could be private
    line 176:    static ptrdiff_t CellDiff();
  W059 Base class virtual destructor is not public
    line 203:    virtual ~ObjectPool();
  W069 Virtual function is public
    line 93:    virtual Pooled* DeqBlock(size_t size);
    line 98:    virtual void EnqBlock(Pooled* obj, bool deleted);
    line 162:    virtual void DisplayStats(std::ostream& stream) const;
  W071 Virtual function has no overrides
    line 93:    virtual Pooled* DeqBlock(size_t size);
    line 98:    virtual void EnqBlock(Pooled* obj, bool deleted);
  W076 Adjacent arguments have the same type
    line 223:    bool BidToIndices(Bid bid, size_t& i, size_t& j) const;
    line 228:    bool IndicesToBid(size_t i, size_t j, Bid& bid) const;
  W084 Function could be free
    line 242:    static ObjectBlock* ObjToBlock(const Pooled* obj);
C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPoolRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 274: ObjectPool* ObjectPoolRegistry::Pool(ObjectPoolId pid) const
C:/Users/gregu/Documents/tsf/tsf/nb/ObjectPoolRegistry.h:
  W036 Member could be private
    line 41:    static bool NullifyObjectData() { return NullifyObjectData_; }
C:/Users/gregu/Documents/tsf/tsf/nb/Permanent.h:
  W026 Unused function
    line 42:    static void* operator new[](size_t size);
C:/Users/gregu/Documents/tsf/tsf/nb/PermanentHeap.cpp:
  W098 Function does not invoke Debug::ft
    line 33: PermanentHeap* PermanentHeap::Instance()
C:/Users/gregu/Documents/tsf/tsf/nb/PermanentHeap.h:
  W084 Function could be free
    line 26:    static PermanentHeap* Instance();
  W102 Override of Object.Patch not found
    line 21: class PermanentHeap : public SysHeap
C:/Users/gregu/Documents/tsf/tsf/nb/Pooled.cpp:
  W006 C-style cast
    line 127:    auto obj = (Pooled*) addr;
  W008 reinterpret_cast
    line 101:    auto fake = reinterpret_cast< const Pooled* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/PooledClass.h:
  W020 Unused class
    line 24: class PooledClass : public Class
  W026 Unused function
    line 38:    PooledClass(ClassId cid, size_t size);
    line 54:    bool SetPool(ObjectPool& pool);
C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.cpp:
  W008 reinterpret_cast
    line 54:    auto fake = reinterpret_cast< const PosixSignal* >(&local);
  W098 Function does not invoke Debug::ft
    line 109: Flags PS_Break()
    line 114: Flags PS_Delayed()
    line 119: Flags PS_Exit()
    line 124: Flags PS_Final()
    line 129: Flags PS_Interrupt()
    line 134: Flags PS_Native()
    line 139: Flags PS_NoError()
    line 144: Flags PS_NoLog()
    line 149: Flags PS_NoRecover()
C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignal.h:
  W047 Data could be const
    line 99:    signal_t value_;
    line 111:    uint8_t severity_;
    line 115:    Flags attrs_;
    line 119:    RegCell sid_;
  W048 Data could be const pointer
    line 103:    const char* name_;
    line 107:    const char* expl_;
  W059 Base class virtual destructor is not public
    line 90:    virtual ~PosixSignal();
  W076 Adjacent arguments have the same type
    line 84:    PosixSignal(signal_t value, const char* name,
C:/Users/gregu/Documents/tsf/tsf/nb/PosixSignalRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 42: Flags PosixSignalRegistry::Attrs(signal_t value) const
    line 75: PosixSignal* PosixSignalRegistry::Find(signal_t value) const
    line 87: PosixSignal* PosixSignalRegistry::Find(const string& name) const
    line 138: signal_t PosixSignalRegistry::Value(const string& name) const
C:/Users/gregu/Documents/tsf/tsf/nb/Protected.h:
  W026 Unused function
    line 41:    static void* operator new[](size_t size);
C:/Users/gregu/Documents/tsf/tsf/nb/Q1Link.cpp:
  W099 Function does not invoke Debug::ft as first statement
    line 34:    Debug::ft(Q1Link_dtor);
C:/Users/gregu/Documents/tsf/tsf/nb/Q1Link.h:
  W026 Unused function
    line 42:    bool IsQueued() const { return next != nullptr; }
C:/Users/gregu/Documents/tsf/tsf/nb/Q1Way.h:
  W080 Argument could be const
    line 64/1:    bool Enq(T& elem)
    line 85/1:    bool Henq(T& elem)
    line 107/1:    bool Insert(T* prev, T& elem)
    line 142/1:    bool Exq(T& elem)
    line 306/1:    void Corrupt(T* elem)
  W091 Line contains adjacent spaces
    line 372:    inline static fn_name Q1Way_ctor()   { return "Q1Way.ctor"; }
    line 373:    inline static fn_name Q1Way_dtor()   { return "Q1Way.dtor"; }
    line 374:    inline static fn_name Q1Way_Init()   { return "Q1Way.Init"; }
    line 375:    inline static fn_name Q1Way_Enq()    { return "Q1Way.Enq"; }
    line 376:    inline static fn_name Q1Way_Henq()   { return "Q1Way.Henq"; }
    line 378:    inline static fn_name Q1Way_Deq()    { return "Q1Way.Deq"; }
    line 379:    inline static fn_name Q1Way_Exq()    { return "Q1Way.Exq"; }
    line 380:    inline static fn_name Q1Way_Next()   { return "Q1Way.Next"; }
    line 381:    inline static fn_name Q1Way_Count()  { return "Q1Way.Count"; }
    line 382:    inline static fn_name Q1Way_Purge()  { return "Q1Way.Purge"; }
    line 383:    inline static fn_name Q1Way_Item()   { return "Q1Way.Item"; }
C:/Users/gregu/Documents/tsf/tsf/nb/Q2Link.cpp:
  W098 Function does not invoke Debug::ft
    line 24: Q2Link::~Q2Link()
C:/Users/gregu/Documents/tsf/tsf/nb/Q2Link.h:
  W026 Unused function
    line 42:    bool IsQueued() const { return next != nullptr; }
C:/Users/gregu/Documents/tsf/tsf/nb/Q2Way.h:
  W080 Argument could be const
    line 120/1:    bool Exq(T& elem)
  W082 Function could be const
    line 120:    bool Exq(T& elem)
  W091 Line contains adjacent spaces
    line 345:    inline static fn_name Q2Way_ctor()  { return "Q2Way.ctor"; }
    line 346:    inline static fn_name Q2Way_dtor()  { return "Q2Way.dtor"; }
    line 347:    inline static fn_name Q2Way_Init()  { return "Q2Way.Init"; }
    line 348:    inline static fn_name Q2Way_Enq()   { return "Q2Way.Enq"; }
    line 349:    inline static fn_name Q2Way_Henq()  { return "Q2Way.Henq"; }
    line 350:    inline static fn_name Q2Way_Deq()   { return "Q2Way.Deq"; }
    line 351:    inline static fn_name Q2Way_Exq()   { return "Q2Way.Exq"; }
    line 352:    inline static fn_name Q2Way_Next()  { return "Q2Way.Next"; }
    line 353:    inline static fn_name Q2Way_Prev()  { return "Q2Way.Prev"; }
    line 356:    inline static fn_name Q2Way_Item()  { return "Q2Way.Item"; }
C:/Users/gregu/Documents/tsf/tsf/nb/RegCell.cpp:
  W098 Function does not invoke Debug::ft
    line 24: RegCell::~RegCell()
    line 36: void RegCell::SetId(id_t cid)
C:/Users/gregu/Documents/tsf/tsf/nb/Registry.h:
  W080 Argument could be const
    line 251/1:    bool Erase(T& item)
  W091 Line contains adjacent spaces
    line 610:    inline static fn_name Registry_ctor()   { return "Registry.ctor"; }
    line 611:    inline static fn_name Registry_dtor()   { return "Registry.dtor"; }
    line 612:    inline static fn_name Registry_Init()   { return "Registry.Init"; }
    line 614:    inline static fn_name Registry_Erase()  { return "Registry.Erase"; }
    line 615:    inline static fn_name Registry_Next()   { return "Registry.Next"; }
    line 616:    inline static fn_name Registry_Prev()   { return "Registry.Prev"; }
    line 617:    inline static fn_name Registry_Size()   { return "Registry.Size"; }
    line 618:    inline static fn_name Registry_Empty()  { return "Registry.Empty"; }
    line 619:    inline static fn_name Registry_Purge()  { return "Registry.Purge"; }
    line 620:    inline static fn_name Registry_Cell()   { return "Registry.Cell"; }
C:/Users/gregu/Documents/tsf/tsf/nb/Restart.h:
  W084 Function could be free
    line 65:    static void Initiate(reinit_t reason, debug32_t errval);
C:/Users/gregu/Documents/tsf/tsf/nb/Singleton.h:
  W041 Data is init-only
    line 115:    static T* Instance_;
  W091 Line contains adjacent spaces
    line 111:       Singleton_Destroy()  { return "Singleton.Destroy"; }
C:/Users/gregu/Documents/tsf/tsf/nb/Singletons.cpp:
  W050 Default constructor invoked: POD members not initialized
    line 77:    SingletonTuple entry;
  W098 Function does not invoke Debug::ft
    line 110: Singletons* Singletons::Instance()
C:/Users/gregu/Documents/tsf/tsf/nb/SoftwareException.h:
  W054 Base class constructor is public
    line 26:    SoftwareException
    line 28:    SoftwareException
C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.cpp:
  W008 reinterpret_cast
    line 74:    auto fake = reinterpret_cast< const Statistic* >(&local);
  W098 Function does not invoke Debug::ft
    line 102: uint64_t Statistic::Overall() const
    line 243: uint64_t HighWatermark::Overall() const
    line 319: uint64_t LowWatermark::Overall() const
C:/Users/gregu/Documents/tsf/tsf/nb/Statistics.h:
  W036 Member could be private
    line 51:    static ptrdiff_t CellDiff();
  W037 Member could be protected
    line 47:    virtual void DisplayStat(std::ostream& stream) const;
  W044 Data is not private
    line 74:    std::atomic_uint32_t curr_;
    line 78:    std::atomic_uint32_t prev_;
    line 82:    std::atomic_uint64_t total_;
    line 86:    uint32_t divisor_;
  W047 Data could be const
    line 103:    RegCell sid_;
    line 107:    DynString expl_;
  W054 Base class constructor is public
    line 119:    explicit Counter(const std::string& expl, uint32_t divisor = 1);
  W069 Virtual function is public
    line 43:    virtual uint64_t Overall() const;
    line 47:    virtual void DisplayStat(std::ostream& stream) const;
C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.cpp:
  W008 reinterpret_cast
    line 66:    auto fake = reinterpret_cast< const StatisticsGroup* >(&local);
  W091 Line contains adjacent spaces
    line 24: fixed_string StatisticsGroup::ReportHeader =   "      Curr      Prev         All";
C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsGroup.h:
  W036 Member could be private
    line 42:    id_t Gid() const { return gid_.GetId(); }
    line 46:    static ptrdiff_t CellDiff();
  W047 Data could be const
    line 85:    RegCell gid_;
    line 89:    DynString expl_;
  W069 Virtual function is public
    line 54:    virtual void DisplayStats(std::ostream& stream, id_t id) const;
C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.cpp:
  W009 Cast down the inheritance hierarchy
    line 46:    statsFileName_.reset
  W098 Function does not invoke Debug::ft
    line 132: StatisticsGroup* StatisticsRegistry::GetGroup(id_t gid) const
C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsRegistry.h:
  W036 Member could be private
    line 62:    StatisticsGroup* GetGroup(id_t gid) const;
    line 66:    void DisplayStats(std::ostream& stream) const;
    line 70:    static std::string StatsFileName() { return StatsFileName_; }
  W082 Function could be const
    line 100:    void StartInterval(bool first);
C:/Users/gregu/Documents/tsf/tsf/nb/StatisticsThread.h:
  W047 Data could be const
    line 38:    static secs_t LongIntervalSecs;
    line 43:    static secs_t ShortIntervalSecs;
    line 50:    static size_t WakeupsBetweenReports;
    line 55:    static ticks_t PrevToCurrTicks;
C:/Users/gregu/Documents/tsf/tsf/nb/StreamRequest.h:
  W037 Member could be protected
    line 42:    StreamRequest(const StreamRequest& that);
  W054 Base class constructor is public
    line 37:    StreamRequest();
    line 42:    StreamRequest(const StreamRequest& that);
C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.cpp:
  W008 reinterpret_cast
    line 85:    auto fake = reinterpret_cast< const Symbol* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/Symbol.h:
  W047 Data could be const
    line 81:    DynString name_;
    line 93:    Q1Link link_;
  W084 Function could be free
    line 37:    static const std::string& ValidNameChars();
    line 42:    static const std::string& InvalidInitialChars();
C:/Users/gregu/Documents/tsf/tsf/nb/SymbolRegistry.h:
  W076 Adjacent arguments have the same type
    line 38:    bool BindSymbol
C:/Users/gregu/Documents/tsf/tsf/nb/SysConsole.cpp:
  W098 Function does not invoke Debug::ft
    line 17: std::istream& SysConsole::In()
    line 24: ostream& SysConsole::Out()
C:/Users/gregu/Documents/tsf/tsf/nb/SysDecls.h:
  W038 Typedef of pointer type
    line 31: typedef void* SysHeap_t;
    line 32: typedef void* SysThread_t;
    line 34: typedef void* SysMutex_t;
    line 35: typedef void* SysSentry_t;
C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.h:
  W026 Unused function
    line 86:    static void* operator new[](size_t size);
    line 91:    static void operator delete[](void* addr);
  W082 Function could be const
    line 40:    bool Validate(const void* addr);
  W084 Function could be free
    line 72:    static void DisplayHeaps(std::ostream& stream);
C:/Users/gregu/Documents/tsf/tsf/nb/SysHeap.win.cpp:
  W006 C-style cast
    line 146:    aHeaps = (HANDLE*) HeapAlloc(DefaultProcessHeap, 0, BytesToAllocate);
C:/Users/gregu/Documents/tsf/tsf/nb/SysMutex.cpp:
  W098 Function does not invoke Debug::ft
    line 33: Thread* SysMutex::Owner() const
C:/Users/gregu/Documents/tsf/tsf/nb/SysMutex.win.cpp:
  W099 Function does not invoke Debug::ft as first statement
    line 90:    Debug::ft(SysMutex_Acquire);
C:/Users/gregu/Documents/tsf/tsf/nb/SysSignals.h:
  W020 Unused class
    line 39:    class SigAlrm : public PosixSignal
    line 53:    class SigBus : public PosixSignal
    line 81:    class SigQuit : public PosixSignal
    line 95:    class SigSys : public PosixSignal
    line 109:    class SigVtAlrm : public PosixSignal
  W030 No referent for friend declaration
    line 41:       friend class Singleton< SigAlrm >;
    line 55:       friend class Singleton< SigBus >;
    line 83:       friend class Singleton< SigQuit >;
    line 97:       friend class Singleton< SigSys >;
    line 111:       friend class Singleton< SigVtAlrm >;
  W084 Function could be free
    line 22:    static void CreateNativeSignals();
C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.h:
  W023 Unused enumerator
    line 43:       LowPriority,       // preemptable threads
  W080 Argument could be const
    line 91/4:       const Thread* client, size_t size, SysThreadId& nid);
  W082 Function could be const
    line 126:    DelayRc Delay(msecs_t msecs);
    line 132:    bool Interrupt();
  W084 Function could be free
    line 37:    static SysThreadId RunningThreadId();
    line 97:    static SysThread_t Wrap();
    line 101:    static void Delete(SysThread_t& thread);
    line 106:    static SysSentry_t CreateSentry();
    line 110:    static void DeleteSentry(SysSentry_t& sentry);
C:/Users/gregu/Documents/tsf/tsf/nb/SysThread.win.cpp:
  W006 C-style cast
    line 122:    return CreateThread(
    line 329:    _set_se_translator((_se_translator_function) SE_Handler);
  W010 Cast removes const qualification
    line 122:    return CreateThread(
  W019 Unused argument
    line 36/2: void SE_Handler(uint32_t errval, void* ex)
  W098 Function does not invoke Debug::ft
    line 253: void SysThread::RegisterForSignal(signal_t sig, sighandler_t handler)
    line 280: SysThreadId SysThread::RunningThreadId()
  W099 Function does not invoke Debug::ft as first statement
    line 41:    Debug::ft(NodeBase_SE_Handler);
C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.h:
  W019 Unused argument
    line 23/1:    void Startup(RestartLevel level);
C:/Users/gregu/Documents/tsf/tsf/nb/SysThreadStack.win.cpp:
  W006 C-style cast
    line 147:    Symbols = (SYMBOL_INFO*) Memory::Alloc(size, MemPerm, false);
  W015 #include not sorted in standard order
    line 13: #include <dbghelp.h>
  W076 Adjacent arguments have the same type
    line 56:    static const char* GetFileLoc(DWORD64 frame, DWORD& line, DWORD& disp);
  W098 Function does not invoke Debug::ft
    line 105: DWORD64 StackInfo::GetFrame(fn_depth depth)
    line 121: fn_depth StackInfo::GetFrames()
    line 129: void StackInfo::Shutdown()
    line 138: DWORD StackInfo::Startup()
    line 249: fn_depth SysThreadStack::FuncDepth()
C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.h:
  W026 Unused function
    line 56:    bool TickTimingAvailable() const { return available_; }
  W101 Override of Base.Display not found
    line 26: class SysTickTimer : public Immutable
  W102 Override of Object.Patch not found
    line 26: class SysTickTimer : public Immutable
C:/Users/gregu/Documents/tsf/tsf/nb/SysTickTimer.win.cpp:
  W050 Default constructor invoked: POD members not initialized
    line 28:    LARGE_INTEGER frequency;
    line 59:       LARGE_INTEGER now;
    line 65:       _timeb now;
  W098 Function does not invoke Debug::ft
    line 55: ticks_t SysTickTimer::TicksNow() const
C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.cpp:
  W007 Functional cast
    line 347:          Truncate(TimeField(int(field) + 1));
    line 528:          return OutOfRange(TimeField(f));
  W098 Function does not invoke Debug::ft
    line 166: int16_t SysTime::DayOfWeek() const
    line 176: int16_t SysTime::DayOfYear() const
    line 192: const int16_t* SysTime::DaysPerMonth(int16_t year)
    line 200: size_t SysTime::DaysSinceT0() const
    line 230: bool SysTime::IsLeapYear(int16_t year)
    line 250: int64_t SysTime::MsecsSinceT0() const
C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.h:
  W026 Unused function
    line 61:    int16_t Get(TimeField field) const { return time_[field]; }
  W036 Member could be private
    line 65:    int16_t DayOfWeek() const;
    line 116:    const char* strMonth() const;
  W076 Adjacent arguments have the same type
    line 56:    SysTime(int16_t year, int16_t month, int16_t day,
  W084 Function could be free
    line 73:    static bool IsLeapYear(int16_t year);
    line 138:    static const int16_t* DaysPerMonth(int16_t year);
C:/Users/gregu/Documents/tsf/tsf/nb/SysTime.win.cpp:
  W050 Default constructor invoked: POD members not initialized
    line 26:    _timeb timebuff;
    line 27:    tm timeofday;
C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.cpp:
  W008 reinterpret_cast
    line 18:    auto bytes = reinterpret_cast< uint8_t* >(&value);
  W098 Function does not invoke Debug::ft
    line 15: uintptr_t BadPointer()
C:/Users/gregu/Documents/tsf/tsf/nb/SysTypes.h:
  W021 Unused data
    line 35: constexpr uword UWORD_MAX = (sizeof(word) == 8 ? UINT64_MAX : UINT32_MAX);
  W023 Unused enumerator
    line 132:    DebugLog,    // only useful to software designers
  W038 Typedef of pointer type
    line 71: typedef char* ptr_t;
    line 87: typedef const char* const fixed_string;
    line 92: typedef const char* const fn_name;      // for defining a function name
    line 93: typedef const char* const fn_name_arg;  // when fn_name is an argument
C:/Users/gregu/Documents/tsf/tsf/nb/Temporary.h:
  W026 Unused function
    line 40:    static void* operator new[](size_t size);
C:/Users/gregu/Documents/tsf/tsf/nb/ThisThread.cpp:
  W098 Function does not invoke Debug::ft
    line 14: bool ThisThread::EnterBlockingOperation(BlockingReason why, fn_name_arg func)
    line 21: void ThisThread::ExitBlockingOperation(fn_name_arg func)
    line 28: void ThisThread::MakePreemptable()
    line 35: void ThisThread::MakeUnpreemptable()
    line 42: void ThisThread::MemProtect()
    line 49: void ThisThread::MemUnprotect()
    line 56: DelayRc ThisThread::Pause(msecs_t msecs)
    line 63: void ThisThread::PauseOver(word limit)
    line 70: word ThisThread::RtcPercentUsed()
    line 77: ThreadId ThisThread::RunningThreadId()
    line 84: TraceRc ThisThread::StartTracing(bool immediate, bool autostop)
    line 91: void ThisThread::StopTracing()
C:/Users/gregu/Documents/tsf/tsf/nb/Thread.cpp:
  W008 reinterpret_cast
    line 1155:    auto fake = reinterpret_cast< const Thread* >(&local);
    line 1519:    auto self = reinterpret_cast< Thread* >(arg);
  W041 Data is init-only
    line 467:    MutexGuard guard(&lock_);
    line 661:    MutexGuard guard(&lock_);
    line 696:    MutexGuard guard(&lock_);
  W084 Function could be free
    line 73:    static void CaptureEvent(fn_name_arg func, Id rid, word info = 0);
  W091 Line contains adjacent spaces
    line 249:    CounterPtr       traps_;
    line 250:    CounterPtr       yields_;
    line 251:    CounterPtr       exceeds_;
    line 255:    AccumulatorPtr   totUsecs_;
  W098 Function does not invoke Debug::ft
    line 423: ContextSwitch* ContextSwitches::AddSwitch()
    line 1136: TraceStatus Thread::CalcStatus(bool dynamic) const
    line 1517: main_t Thread::EnterThread(void* arg)
    line 1721: void Thread::FunctionInvoked(fn_name_arg func)
    line 1818: bool Thread::HasExited() const
    line 1881: bool Thread::IsLocked() const
    line 1888: Thread* Thread::LockedThread()
    line 1955: TraceRc Thread::LogContextSwitches(bool on)
    line 2080: SysThreadId Thread::NativeThreadId() const
    line 2108: DelayRc Thread::Pause(msecs_t msecs)
    line 2148: double Thread::PercentIdle()
    line 2507: bool Thread::RunningLocked()
    line 2658: void Thread::StackCheck()
    line 2930: TraceRc Thread::StartTracing(bool immediate, bool autostop)
    line 2966: void Thread::StopTracing()
    line 3029: void Thread::Trace
    line 3046: bool Thread::TraceRunningThread(Thread*& thr)
    line 3081: void Thread::TrapCheck()
  W099 Function does not invoke Debug::ft as first statement
    line 1641:    Debug::ft(Thread_ExitIfSafe);
    line 2452:    Debug::ft(Thread_ResumeLocked);
    line 2630:    Debug::ft(Thread_SignalHandler);
    line 2702:          Debug::ft(Thread_Start);
    line 3215:       Debug::ft(Thread_Unlock);
  W101 Override of Base.Display not found
    line 243: class ThreadStats : public Dynamic
    line 336: class ContextSwitches : public Permanent
    line 591: class Orphans : public Permanent
  W102 Override of Object.Patch not found
    line 336: class ContextSwitches : public Permanent
    line 591: class Orphans : public Permanent
    line 725: class ThreadPriv : public Permanent
C:/Users/gregu/Documents/tsf/tsf/nb/Thread.h:
  W007 Functional cast
    line 143:    Id Tid() const { return Id(tid_.GetId()); }
  W019 Unused argument
    line 339/2:       (BlockingReason why, fn_name_arg func) { return true; }
    line 347/1:    virtual void ScheduledIn(fn_name_arg func) { }
  W026 Unused function
    line 107:    static std::atomic_uint32_t* Vector();
    line 155:    bool ChangeFaction(Faction faction);
  W036 Member could be private
    line 111:    static bool TestFlag(FlagId fid);
    line 115:    static void ResetFlag(FlagId fid);
    line 147:    SysThreadId NativeThreadId() const;
    line 224:    static ptrdiff_t CellDiff();
  W059 Base class virtual destructor is not public
    line 266:    virtual ~Thread();
  W069 Virtual function is public
    line 172:    virtual TraceStatus CalcStatus(bool dynamic) const;
    line 196:    virtual void DisplayStats(std::ostream& stream) const;
  W071 Virtual function has no overrides
    line 196:    virtual void DisplayStats(std::ostream& stream) const;
    line 278:    virtual bool EnqMsg(MsgBuffer& msg);
    line 284:    virtual MsgBuffer* DeqMsg(msecs_t timeout);
  W076 Adjacent arguments have the same type
    line 546:    void DisplaySummary
  W082 Function could be const
    line 103:    bool Interrupt(const Flags& mask = Flags());
    line 494:    void SetTrap(bool on);
    line 502:    void StackCheck();
    line 514:    void SetSignal(signal_t sig);
  W084 Function could be free
    line 91:    static void PauseOver(word limit);
    line 205:    static double PercentIdle();
    line 209:    static TraceRc LogContextSwitches(bool on);
    line 213:    static void DisplayContextSwitches(std::ostream& stream);
    line 424:    static SysThread::Priority FactionToPriority(Faction& faction);
C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.cpp:
  W098 Function does not invoke Debug::ft
    line 272: bool ThreadAdmin::BreakEnabled()
    line 370: void ThreadAdmin::Incr(Register r)
    line 478: word ThreadAdmin::TrapCount()
  W101 Override of Base.Display not found
    line 36: class ThreadsStats : public Dynamic
C:/Users/gregu/Documents/tsf/tsf/nb/ThreadAdmin.h:
  W084 Function could be free
    line 75:    static int WarpFactor();
  W091 Line contains adjacent spaces
    line 161:    CfgIntParmPtr  initTimeoutMsecs_;
    line 162:    CfgIntParmPtr  schedTimeoutMsecs_;
    line 164:    CfgIntParmPtr  rtcTimeoutMsecs_;
    line 166:    CfgIntParmPtr  rtcLimit_;
    line 167:    CfgIntParmPtr  rtcInterval_;
    line 169:    CfgIntParmPtr  trapLimit_;
    line 170:    CfgIntParmPtr  trapInterval_;
    line 172:    CfgIntParmPtr  stackUsageLimit_;
    line 173:    CfgIntParmPtr  stackCheckInterval_;
C:/Users/gregu/Documents/tsf/tsf/nb/ThreadRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 194: ThreadId ThreadRegistry::FindThreadId(SysThreadId nid) const
    line 203: Thread* ThreadRegistry::GetThread(ThreadId tid) const
C:/Users/gregu/Documents/tsf/tsf/nb/ThreadRegistry.h:
  W082 Function could be const
    line 97:    void AssociateIds(const Thread& thread);
C:/Users/gregu/Documents/tsf/tsf/nb/TimedRecord.h:
  W037 Member could be protected
    line 33:    ticks_t GetTicks() const { return ticks_; }
    line 37:    void SetTicks(const ticks_t& ticks) { ticks_ = ticks; }
    line 41:    SysThreadId Nid() const { return nid_; }
C:/Users/gregu/Documents/tsf/tsf/nb/Tool.cpp:
  W008 reinterpret_cast
    line 52:    auto fake = reinterpret_cast< const Tool* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nb/Tool.h:
  W047 Data could be const
    line 90:    char abbr_;
    line 94:    bool safe_;
  W059 Base class virtual destructor is not public
    line 77:    virtual ~Tool();
  W069 Virtual function is public
    line 41:    virtual const char* Name() const = 0;
    line 45:    virtual const char* Expl() const = 0;
    line 51:    virtual std::string Status() const;
C:/Users/gregu/Documents/tsf/tsf/nb/ToolRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 102: Tool* ToolRegistry::GetTool(FlagId fid) const
C:/Users/gregu/Documents/tsf/tsf/nb/ToolTypes.cpp:
  W095 Function not sorted in standard order
    line 53: ostream& operator<<(std::ostream& stream, TraceStatus status)
C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.cpp:
  W006 C-style cast
    line 110:    buff_ = (uword*) Memory::Alloc(InitialSize << BYTES_PER_WORD_LOG2, MemPerm);
    line 220:    auto addr = (TraceRecord*) &buff_[end_];
    line 413:       next = (uword*) record + incr;
    line 431:             record = (TraceRecord*) buff_;  // case (b)
    line 435:          record = (TraceRecord*) next;
    line 444:       next = (uword*) record + incr;
    line 470:       auto record = (TraceRecord*) &buff_[start_];
    line 577:    buff_ = (uword*) Memory::Alloc(size << BYTES_PER_WORD_LOG2, MemPerm, false);
  W098 Function does not invoke Debug::ft
    line 96: TraceBuffer::TraceBuffer() :
    line 124: TraceBuffer::~TraceBuffer()
    line 138: void* TraceBuffer::AddRecord(size_t nBytes)
    line 336: bool TraceBuffer::Empty() const
    line 367: bool TraceBuffer::IsLocked()
    line 376: void TraceBuffer::Lock()
    line 396: void TraceBuffer::Next(TraceRecord*& record, const Flags& mask) const
    line 457: void TraceBuffer::PurgeRecords(size_t end)
    line 525: void TraceBuffer::RecordInvocation(fn_name_arg func) const
    line 728: void TraceBuffer::Unlock()
C:/Users/gregu/Documents/tsf/tsf/nb/TraceBuffer.h:
  W026 Unused function
    line 154:    const SysTime& StartTimeFull() const { return startTime_; }
  W036 Member could be private
    line 163:    typedef std::map< fn_name_arg, size_t > InvocationsTable;
  W101 Override of Base.Display not found
    line 48: class TraceBuffer : public Permanent
C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.cpp:
  W007 Functional cast
    line 23:    size_(int16_t(size)),
C:/Users/gregu/Documents/tsf/tsf/nb/TraceRecord.h:
  W026 Unused function
    line 81:    static void operator delete(void* addr, void* where) { }
  W036 Member could be private
    line 72:    static void operator delete(void* addr) { }
    line 76:    static void* operator new(size_t size, void* where);
  W037 Member could be protected
    line 55:    void Nullify() { owner_ = NIL_ID; }
  W044 Data is not private
    line 118:    Id rid_ : 8;
  W069 Virtual function is public
    line 62:    virtual bool Display(std::ostream& stream);
  W082 Function could be const
    line 98:    virtual void ClaimBlocks() { }
C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.cpp:
  W006 C-style cast
    line 43:    functionq_ = (Q2Way< FunctionStats >*) Memory::Alloc(size, MemTemp);
  W009 Cast down the inheritance hierarchy
    line 183:             auto ft = static_cast<FunctionTrace*>(rec);
  W098 Function does not invoke Debug::ft
    line 82: void FunctionProfiler::CheckHigh(FunctionStats*& high,
C:/Users/gregu/Documents/tsf/tsf/nt/FunctionProfiler.h:
  W017 Using statement in header
    line 23: using namespace NodeBase;
  W047 Data could be const
    line 90:    size_t size_;
  W076 Adjacent arguments have the same type
    line 68:    static void CheckHigh(FunctionStats*& high, FunctionStats* curr,
  W082 Function could be const
    line 62:    FunctionStats* EnsureRecord(fn_name_arg func, size_t count);
  W084 Function could be free
    line 68:    static void CheckHigh(FunctionStats*& high, FunctionStats* curr,
  W101 Override of Base.Display not found
    line 34: class FunctionProfiler : public Temporary
C:/Users/gregu/Documents/tsf/tsf/nt/FunctionStats.cpp:
  W008 reinterpret_cast
    line 56:    auto fake = reinterpret_cast< const FunctionStats* >(&local);
  W098 Function does not invoke Debug::ft
    line 45: void FunctionStats::IncrCalls(usecs_t net)
C:/Users/gregu/Documents/tsf/tsf/nt/FunctionStats.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W047 Data could be const
    line 63:    Q2Link link_;
C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.cpp:
  W007 Functional cast
    line 3018:    pool->time_[id1].Truncate(TimeField(field - 1));
    line 3049:    pool->time_[id1].Round(TimeField(field - 1), interval);
  W008 reinterpret_cast
    line 1164:    auto fake = reinterpret_cast< const Q1WayItem* >(&local);
    line 1684:    auto fake = reinterpret_cast< const Q2WayItem* >(&local);
    line 2245:    auto fake = reinterpret_cast< const RegistryItem* >(&local);
    line 3479:    auto p = reinterpret_cast< char* >(BAD_POINTER);
  W036 Member could be private
    line 3263:    typedef id_t Test;
  W041 Data is init-only
    line 243:    FunctionGuard guard(FunctionGuard::MakePreemptable, yield);
  W047 Data could be const
    line 1028:    Q1Link link_;
    line 1540:    Q2Link link_;
  W084 Function could be free
    line 3285:    static void UseBadPointer();
    line 3286:    static void LoopForever();
  W098 Function does not invoke Debug::ft
    line 1143: Q1WayItem::~Q1WayItem()
    line 1177: Q1WayPool::Q1WayPool()
    line 1206: void Q1WayPool::Reallocate()
    line 1663: Q2WayItem::~Q2WayItem()
    line 1697: Q2WayPool::Q2WayPool()
    line 1726: void Q2WayPool::Reallocate()
    line 2227: RegistryItem::~RegistryItem()
    line 2258: RegistryPool::RegistryPool()
  W099 Function does not invoke Debug::ft as first statement
    line 3359:       Debug::ft(RecoveryTestThread_Enter);
    line 3441:       Debug::ft(RecoveryTestThread_LoopForever);
  W101 Override of Base.Display not found
    line 890: class LbcPool : public Temporary
    line 2649: class SysTimePool : public Temporary
C:/Users/gregu/Documents/tsf/tsf/nt/NtIncrement.h:
  W017 Using statement in header
    line 18: using namespace NodeBase;
  W021 Unused data
    line 66:    static const id_t LastNtIndex    = FuncTraceScope;
  W036 Member could be private
    line 148:    virtual void ConcludeTest(CliThread& cli) const;
  W054 Base class constructor is public
    line 30:    CorruptWhatParm();
    line 42:    explicit CorruptCommand(bool bind = true);
    line 84:    NtSaveWhatParm();
    line 96:    explicit NtSaveCommand(bool bind = true);
    line 110:    SizesCommand();
    line 125:    TestcaseAction();
    line 144:    explicit TestcaseCommand(bool bind = true);
  W071 Virtual function has no overrides
    line 148:    virtual void ConcludeTest(CliThread& cli) const;
C:/Users/gregu/Documents/tsf/tsf/nt/NtModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/nt/NtTestData.cpp:
  W009 Cast down the inheritance hierarchy
    line 51:    return static_cast< NtTestData* >(data);
C:/Users/gregu/Documents/tsf/tsf/nt/NtTestData.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W084 Function could be free
    line 30:    static NtTestData* Access(CliThread& cli);
C:/Users/gregu/Documents/tsf/tsf/nw/InputHandler.h:
  W037 Member could be protected
    line 47:    IpPort* Port() const { return port_; }
  W069 Virtual function is public
    line 76:    virtual IpBuffer* AllocBuff
    line 92:    virtual void ReceiveBuff
C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.cpp:
  W006 C-style cast
    line 62:    buffer_ = (byte_t*) Memory::Alloc(SysSocket::MaxMsgSize, MemDyn);
  W011 Pointer arithmetic
    line 190:       source += rcvd;
C:/Users/gregu/Documents/tsf/tsf/nw/IoThread.h:
  W036 Member could be private
    line 79:    virtual bool ExitOnRestart(RestartLevel level) const override;
  W044 Data is not private
    line 83:    const ipport_t port_;
    line 88:    IpPort* ipPort_;
    line 92:    size_t rxSize_;
    line 96:    size_t txSize_;
    line 100:    SysIpL2Addr host_;
    line 104:    size_t recvs_;
    line 108:    SysIpL3Addr txAddr_;
    line 112:    SysIpL3Addr rxAddr_;
    line 116:    ticks_t ticks0_;
    line 120:    byte_t* buffer_;
  W069 Virtual function is public
    line 44:    virtual bool InsertSocket(SysSocket* socket);
  W071 Virtual function has no overrides
    line 75:    virtual bool ConditionalPause(word percent);
  W076 Adjacent arguments have the same type
    line 60:    IoThread(Faction faction, ipport_t port, size_t rxSize, size_t txSize);
  W080 Argument could be const
    line 70/1:    void InvokeHandler(IpPort& port, const byte_t* source, MsgSize size) const;
C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.cpp:
  W006 C-style cast
    line 56:    buff_ = (byte_t*) Memory::Alloc(BuffSize(buffSize_), MemDyn);
    line 75:    buff_ = (byte_t*) Memory::Alloc(BuffSize(buffSize_), MemDyn);
    line 116:       auto buff = (byte_t*) Memory::Realloc(buff_, BuffSize(newSize));
  W011 Pointer arithmetic
    line 246:    bytes += hdrSize_;
  W098 Function does not invoke Debug::ft
    line 190: TraceStatus IpBuffer::GetStatus() const
C:/Users/gregu/Documents/tsf/tsf/nw/IpBuffer.h:
  W036 Member could be private
    line 100:    virtual MsgSize PayloadSize() const;
  W054 Base class constructor is public
    line 34:    IpBuffer(MsgDirection dir, MsgSize header, MsgSize payload);
    line 38:    IpBuffer(const IpBuffer& that);
  W069 Virtual function is public
    line 100:    virtual MsgSize PayloadSize() const;
    line 119:    virtual bool AddBytes(const byte_t* source, MsgSize size, bool& moved);
  W071 Virtual function has no overrides
    line 119:    virtual bool AddBytes(const byte_t* source, MsgSize size, bool& moved);
  W076 Adjacent arguments have the same type
    line 34:    IpBuffer(MsgDirection dir, MsgSize header, MsgSize payload);
  W084 Function could be free
    line 149:    static size_t BuffSize(size_t nBytes);
C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.cpp:
  W008 reinterpret_cast
    line 261:    auto fake = reinterpret_cast< const IpPort* >(&local);
  W091 Line contains adjacent spaces
    line 40:    CounterPtr       recvs_;
    line 41:    AccumulatorPtr   bytesRcvd_;
    line 44:    CounterPtr       discards_;
    line 45:    CounterPtr       rejects_;
    line 46:    CounterPtr       sends_;
    line 47:    AccumulatorPtr   bytesSent_;
    line 49:    CounterPtr       overflows_;
  W098 Function does not invoke Debug::ft
    line 190: size_t IpPort::Discards() const
  W101 Override of Base.Display not found
    line 34: class IpPortStats : public Dynamic
C:/Users/gregu/Documents/tsf/tsf/nw/IpPort.h:
  W037 Member could be protected
    line 52:    IoThread* GetThread() const { return thread_; }
  W047 Data could be const
    line 164:    Q1Link link_;
    line 168:    ipport_t port_;
  W048 Data could be const pointer
    line 172:    IpService* service_;
  W069 Virtual function is public
    line 73:    virtual SysSocket* CreateAppSocket(size_t rxSize, size_t txSize);
    line 108:    virtual void DisplayStats(std::ostream& stream) const;
  W071 Virtual function has no overrides
    line 108:    virtual void DisplayStats(std::ostream& stream) const;
  W082 Function could be const
    line 145:    virtual IoThread* CreateIoThread();
C:/Users/gregu/Documents/tsf/tsf/nw/IpPortCfgParm.h:
  W076 Adjacent arguments have the same type
    line 31:    IpPortCfgParm(const char* key, const char* def,
C:/Users/gregu/Documents/tsf/tsf/nw/IpPortRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 268: IpPort* IpPortRegistry::GetPort(ipport_t port, IpProtocol protocol) const
  W101 Override of Base.Display not found
    line 32: class HostAddrCfg : public CfgStrParm
C:/Users/gregu/Documents/tsf/tsf/nw/IpService.cpp:
  W008 reinterpret_cast
    line 54:    auto fake = reinterpret_cast< const IpService* >(&local);
C:/Users/gregu/Documents/tsf/tsf/nw/IpService.h:
  W026 Unused function
    line 62:    virtual CliText* CreateText() const = 0;
  W036 Member could be private
    line 80:    IpPort* Provision(ipport_t port);
  W047 Data could be const
    line 132:    RegCell sid_;
  W059 Base class virtual destructor is not public
    line 114:    virtual ~IpService();
  W069 Virtual function is public
    line 36:    virtual const char* Name() const = 0;
    line 40:    virtual IpProtocol Protocol() const = 0;
    line 45:    virtual ipport_t Port() const = 0;
    line 49:    virtual Faction GetFaction() const = 0;
    line 53:    virtual size_t RxSize() const = 0;
    line 57:    virtual size_t TxSize() const = 0;
    line 62:    virtual CliText* CreateText() const = 0;
    line 68:    virtual SysSocket* CreateAppSocket() const { return nullptr; }
    line 76:    virtual void GetAppSocketSizes(size_t& rxSize, size_t& txSize) const;
  W071 Virtual function has no overrides
    line 68:    virtual SysSocket* CreateAppSocket() const { return nullptr; }
C:/Users/gregu/Documents/tsf/tsf/nw/IpServiceRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 63: IpService* IpServiceRegistry::GetService(const string& name) const
C:/Users/gregu/Documents/tsf/tsf/nw/IpServiceRegistry.h:
  W026 Unused function
    line 33:    IpService* GetService(const std::string& name) const;
C:/Users/gregu/Documents/tsf/tsf/nw/NwIncrement.h:
  W054 Base class constructor is public
    line 24:    NwClearWhatParm();
    line 39:    explicit NwClearCommand(bool bind = true);
    line 52:    NwExcludeWhatParm();
    line 65:    explicit NwExcludeCommand(bool bind = true);
    line 78:    NwIncludeWhatParm();
    line 91:    explicit NwIncludeCommand(bool bind = true);
    line 106:    explicit NwQueryCommand(bool bind = true);
    line 119:    NwStatusCommand() { }
  W102 Override of Object.Patch not found
    line 28: class NwClearCommand : public ClearCommand
    line 56: class NwExcludeCommand : public ExcludeCommand
    line 82: class NwIncludeCommand : public IncludeCommand
    line 101: class NwQueryCommand : public QueryCommand
    line 116: class NwStatusCommand : public StatusCommand
C:/Users/gregu/Documents/tsf/tsf/nw/NwModule.h:
  W041 Data is init-only
    line 49:    static bool Registered;
  W084 Function could be free
    line 45:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/nw/NwTracer.h:
  W036 Member could be private
    line 39:    bool PeersEmpty() const;
    line 43:    bool PortsEmpty() const;
  W101 Override of Base.Display not found
    line 25: class NwTracer : public Permanent
  W102 Override of Object.Patch not found
    line 25: class NwTracer : public Permanent
C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.h:
  W054 Base class constructor is public
    line 25:    SysIpL2Addr();
    line 29:    explicit SysIpL2Addr(ipv4addr_t v4Addr);
    line 34:    explicit SysIpL2Addr(const std::string& text);
    line 38:    SysIpL2Addr(const SysIpL2Addr& that);
  W069 Virtual function is public
    line 62:    virtual std::string to_str() const;
  W084 Function could be free
    line 50:    static SysIpL2Addr LoopbackAddr();
    line 66:    static bool HostName(std::string& name);
C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL2Addr.win.cpp:
  W050 Default constructor invoked: POD members not initialized
    line 36:    in_addr result;
  W098 Function does not invoke Debug::ft
    line 94: SysIpL2Addr SysIpL2Addr::LoopbackAddr()
C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.h:
  W026 Unused function
    line 95:    bool operator!=(const SysIpL3Addr& that) const;
  W036 Member could be private
    line 91:    bool operator==(const SysIpL3Addr& that) const;
  W054 Base class constructor is public
    line 25:    SysIpL3Addr();
    line 30:    SysIpL3Addr(ipv4addr_t v4Addr, ipport_t port,
    line 36:    SysIpL3Addr(const SysIpL2Addr& l2Addr, ipport_t port,
    line 44:    SysIpL3Addr
    line 49:    SysIpL3Addr(const SysIpL3Addr& that);
  W076 Adjacent arguments have the same type
    line 44:    SysIpL3Addr
C:/Users/gregu/Documents/tsf/tsf/nw/SysIpL3Addr.win.cpp:
  W006 C-style cast
    line 42:          auto netaddr = (sockaddr_in*) info->ai_addr;
    line 97:    if(getnameinfo
  W050 Default constructor invoked: POD members not initialized
    line 32:    addrinfo hints;
    line 89:    sockaddr_in addr;
C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.cpp:
  W098 Function does not invoke Debug::ft
    line 134: bool SysSocket::SetTracing(bool tracing)
    line 142: bool SysSocket::Trace(TraceStatus status)
    line 153: bool SysSocket::TraceEnabled()
C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.h:
  W036 Member could be private
    line 77:    bool IsValid() const;
    line 175:    void Close();
  W037 Member could be protected
    line 82:    bool IsOpen() const;
  W059 Base class virtual destructor is not public
    line 161:    virtual ~SysSocket();
  W069 Virtual function is public
    line 61:    virtual IpProtocol Protocol() const { return IpAny; }
    line 65:    virtual void Acquire() { }
    line 69:    virtual void Release() { }
    line 99:    virtual SendRc SendBuff(IpBuffer& buff) = 0;
  W076 Adjacent arguments have the same type
    line 150:    SysSocket(ipport_t port, IpProtocol proto,
  W084 Function could be free
    line 113:    static bool StartLayer();
    line 117:    static void StopLayer();
C:/Users/gregu/Documents/tsf/tsf/nw/SysSocket.win.cpp:
  W006 C-style cast
    line 71:    if(bind(socket_, (sockaddr*) &addr, sizeof(addr)) == SOCKET_ERROR)
    line 189:    if(setsockopt(socket_, SOL_SOCKET, SO_RCVBUF,
    line 196:    if(getsockopt(socket_, SOL_SOCKET, SO_RCVBUF,
    line 206:    if(setsockopt(socket_, SOL_SOCKET, SO_SNDBUF,
    line 213:    if(getsockopt(socket_, SOL_SOCKET, SO_SNDBUF,
  W015 #include not sorted in standard order
    line 10: #include <windows.h>
  W050 Default constructor invoked: POD members not initialized
    line 36:    sockaddr_in addr;
    line 245:    WSAData wsaData;
C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.h:
  W026 Unused function
    line 114:    bool LocAddr(SysIpL3Addr& locAddr);
  W036 Member could be private
    line 69:    word Connect(const SysIpL3Addr& remAddr);
    line 109:    word Send(const byte_t* data, size_t len);
  W076 Adjacent arguments have the same type
    line 54:    SysTcpSocket(ipport_t port, size_t rxSize, size_t txSize, AllocRc& rc);
C:/Users/gregu/Documents/tsf/tsf/nw/SysTcpSocket.win.cpp:
  W006 C-style cast
    line 27:    auto socket = accept(Socket(), (sockaddr*) &peer, &peersize);
    line 55:    if(connect(Socket(), (sockaddr*) &peer, sizeof(peer)) == SOCKET_ERROR)
    line 100:    if(getsockname(Socket(), (sockaddr*) &host, &hostsize) != 0)
    line 208:    if(getpeername(Socket(), (sockaddr*) &peer, &peersize) == SOCKET_ERROR)
  W008 reinterpret_cast
    line 190:    auto rcvd = recv(Socket(), reinterpret_cast< char* >(buff), max, 0);
    line 235:    auto sent = send(Socket(), reinterpret_cast< const char* >(data), len, 0);
  W050 Default constructor invoked: POD members not initialized
    line 24:    sockaddr_in peer;
    line 49:    sockaddr_in peer;
    line 97:    sockaddr_in host;
    line 205:    sockaddr_in peer;
  W051 Default constructor invoked
    line 131:    auto list = std::unique_ptr< pollfd[] >(new pollfd[count]);
C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.h:
  W036 Member could be private
    line 53:    word SendTo(const byte_t* data, size_t len, const SysIpL3Addr& remAddr);
  W076 Adjacent arguments have the same type
    line 36:    SysUdpSocket(ipport_t port, size_t rxSize, size_t txSize, AllocRc& rc);
  W101 Override of Base.Display not found
    line 21: class SysUdpSocket : public SysSocket
C:/Users/gregu/Documents/tsf/tsf/nw/SysUdpSocket.win.cpp:
  W006 C-style cast
    line 30:       if(getsockopt(Socket(), SOL_SOCKET, SO_MAX_MSG_SIZE,
    line 59:    auto rcvd = recvfrom(Socket(), reinterpret_cast< char* >(buff),
    line 97:    auto sent = sendto(Socket(), reinterpret_cast< const char* >(data),
  W008 reinterpret_cast
    line 59:    auto rcvd = recvfrom(Socket(), reinterpret_cast< char* >(buff),
    line 97:    auto sent = sendto(Socket(), reinterpret_cast< const char* >(data),
  W050 Default constructor invoked: POD members not initialized
    line 50:    sockaddr_in peer;
    line 82:    sockaddr_in peer;
C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.cpp:
  W009 Cast down the inheritance hierarchy
    line 141:    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
    line 160:    auto svc = static_cast< TcpIpService* >(ipPort_->GetService());
    line 251:    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
    line 397:    auto sock = static_cast< SysTcpSocket* >(socket);
  W098 Function does not invoke Debug::ft
    line 413: SysTcpSocket* TcpIoThread::Listener() const
C:/Users/gregu/Documents/tsf/tsf/nw/TcpIoThread.h:
  W036 Member could be private
    line 56:    virtual void Unblock() override;
  W076 Adjacent arguments have the same type
    line 34:    TcpIoThread(Faction faction, ipport_t port,
C:/Users/gregu/Documents/tsf/tsf/nw/TcpIpPort.cpp:
  W009 Cast down the inheritance hierarchy
    line 90:    auto svc = static_cast< TcpIpService* >(GetService());
C:/Users/gregu/Documents/tsf/tsf/nw/TcpIpService.h:
  W036 Member could be private
    line 55:    virtual IpPort* CreatePort(ipport_t pid) override;
  W069 Virtual function is public
    line 24:    virtual size_t MaxConns() const = 0;
    line 29:    virtual size_t MaxBacklog() const = 0;
C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.cpp:
  W009 Cast down the inheritance hierarchy
    line 91:    auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
    line 225:       auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
C:/Users/gregu/Documents/tsf/tsf/nw/UdpIoThread.h:
  W036 Member could be private
    line 40:    virtual void Unblock() override;
  W076 Adjacent arguments have the same type
    line 28:    UdpIoThread(Faction faction, ipport_t port, size_t rxSize, size_t txSize);
  W082 Function could be const
    line 60:    void ReleaseResources();
C:/Users/gregu/Documents/tsf/tsf/nw/UdpIpService.h:
  W036 Member could be private
    line 39:    virtual IpPort* CreatePort(ipport_t pid) override;
C:/Users/gregu/Documents/tsf/tsf/on/OnModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/pb/PbModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/pb/PotsBicFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 82: CliText* PotsBicFeature::Attrs() const { return new PotsBicAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsBicFeature.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsBocFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 67: CliText* PotsBocFeature::Attrs() const { return new PotsBocAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsBocFeature.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfbFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 64: CliText* PotsCfbFeature::Attrs() const { return new PotsCfbAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfbFeature.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
    line 16: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfnFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 82: CliText* PotsCfnFeature::Attrs() const { return new PotsCfnAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfnFeature.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
    line 17: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfuFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 64: CliText* PotsCfuFeature::Attrs() const { return new PotsCfuAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCfuFeature.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
    line 16: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.cpp:
  W098 Function does not invoke Debug::ft
    line 502: void PotsCircuit::Trace(const SignalEntry& entry)
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCircuit.h:
  W017 Using statement in header
    line 25: using namespace NodeBase;
    line 26: using namespace SessionBase;
    line 27: using namespace CallBase;
  W026 Unused function
    line 77:    bool IsRinging() const { return ringing_; }
    line 81:    bool CanFlash() const { return flash_; }
    line 86:    Cause::Ind GetCause() const { return cause_; }
  W036 Member could be private
    line 118:    void ResetCircuit();
  W048 Data could be const pointer
    line 206:    PotsProfile* profile_;
  W050 Default constructor invoked: POD members not initialized
    line 218:    SignalEntry trace_[TraceSize];
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCliParms.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCwtFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 61: CliText* PotsCwtFeature::Attrs() const { return new PotsCwtAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCwtFeature.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCxfFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 54: CliText* PotsCxfFeature::Attrs() const { return new PotsCxfAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsCxfFeature.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.cpp:
  W008 reinterpret_cast
    line 73:    auto fake = reinterpret_cast< const PotsFeature* >(&local);
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeature.h:
  W007 Functional cast
    line 48:    Id Fid() const { return Id(fid_.GetId()); }
  W017 Using statement in header
    line 23: using namespace NodeBase;
  W019 Unused argument
    line 72/1:       (PotsProfile& profile, CliThread& cli) const = 0;  //d
  W036 Member could be private
    line 48:    Id Fid() const { return Id(fid_.GetId()); }
    line 56:    const char* FullName() const { return name_; }
    line 60:    bool CanBeDeactivated() const { return deactivation_; }
    line 76:    static ptrdiff_t CellDiff();
  W048 Data could be const pointer
    line 118:    const char* abbr_;
    line 122:    const char* name_;
  W059 Base class virtual destructor is not public
    line 93:    virtual ~PotsFeature();
  W069 Virtual function is public
    line 71:    virtual PotsFeatureProfile* Subscribe
  W076 Adjacent arguments have the same type
    line 88:    PotsFeature(PotsFeature::Id fid, bool deactivation,
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.cpp:
  W008 reinterpret_cast
    line 82:    auto fake = reinterpret_cast< const PotsFeatureProfile* >(&local);
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureProfile.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W019 Unused argument
    line 40/1:    virtual bool Deactivate(PotsProfile& profile);
    line 74/1:    virtual bool Unsubscribe(PotsProfile& profile);
  W036 Member could be private
    line 44:    PotsFeature::Id Fid() const { return fid_; }
    line 48:    static ptrdiff_t LinkDiff();
  W047 Data could be const
    line 78:    PotsFeature::Id fid_;
    line 82:    Q1Link link_;
  W059 Base class virtual destructor is not public
    line 61:    virtual ~PotsFeatureProfile();
  W069 Virtual function is public
    line 35:    virtual bool Activate(PotsProfile& profile, CliThread& cli);  //d
    line 40:    virtual bool Deactivate(PotsProfile& profile);
  W071 Virtual function has no overrides
    line 74:    virtual bool Unsubscribe(PotsProfile& profile);
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 133: PotsFeature* PotsFeatureRegistry::Feature(PotsFeature::Id fid) const
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatureRegistry.h:
  W017 Using statement in header
    line 21: using namespace NodeBase;
  W082 Function could be const
    line 42:    void Audit();
C:/Users/gregu/Documents/tsf/tsf/pb/PotsFeatures.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsHtlFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 69: CliText* PotsHtlFeature::Attrs() const { return new PotsHtlAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsHtlFeature.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
    line 16: using namespace CallBase;
  W047 Data could be const
    line 44:    Address::DN dn_;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsIncrement.cpp:
  W009 Cast down the inheritance hierarchy
    line 426:       auto mep = static_cast< MediaEndpt* >(obj);
C:/Users/gregu/Documents/tsf/tsf/pb/PotsIncrement.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionTools;
  W054 Base class constructor is public
    line 26:    PbSizesCommand() { }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsMessages.cpp:
  W053 Default assignment operator invoked
    line 132:       addr = GlobalAddress(peer, PotsCallIpPort, PotsCallFactoryId);
    line 187:       addr = GlobalAddress(peer, PotsShelfIpPort, PotsShelfFactoryId);
C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.cpp:
  W008 reinterpret_cast
    line 72:    auto fake = reinterpret_cast< const PotsProfile* >(&local);
  W052 Default copy constructor invoked
    line 39:    objAddr_(NilLocalAddress)
C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfile.h:
  W017 Using statement in header
    line 25: using namespace NodeBase;
    line 26: using namespace SessionBase;
    line 27: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfileRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 98: PotsProfile* PotsProfileRegistry::Profile(Address::DN dn) const
C:/Users/gregu/Documents/tsf/tsf/pb/PotsProfileRegistry.h:
  W017 Using statement in header
    line 20: using namespace NodeBase;
    line 21: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.cpp:
  W008 reinterpret_cast
    line 563:    reinterpret_cast< const PotsFacilityInfo* >(bytes)->Display(stream, prefix);
    line 732:    reinterpret_cast< const PotsHeaderInfo* >(bytes)->Display(stream, prefix);
    line 853:    reinterpret_cast< const PotsRingInfo* >(bytes)->Display(stream, prefix);
    line 941:    reinterpret_cast< const PotsScanInfo* >(bytes)->Display(stream, prefix);
  W009 Cast down the inheritance hierarchy
    line 578:    auto&            pmsg = static_cast< PotsMessage& >(msg);
    line 639:    auto&             pmsg = static_cast< const PotsMessage& >(msg);
    line 746:    auto&          pmsg = static_cast< PotsMessage& >(msg);
    line 772:    auto&           pmsg = static_cast< const PotsMessage& >(msg);
    line 866:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
    line 954:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  W091 Line contains adjacent spaces
    line 575:    id_t             index;
    line 576:    word             sid, ind;
    line 578:    auto&            pmsg = static_cast< PotsMessage& >(msg);
    line 638:    TestRc            rc;
    line 639:    auto&             pmsg = static_cast< const PotsMessage& >(msg);
    line 641:    id_t              index;
    line 642:    word              sid, ind;
    line 744:    word           port;
    line 746:    auto&          pmsg = static_cast< PotsMessage& >(msg);
    line 771:    TestRc          rc;
    line 772:    auto&           pmsg = static_cast< const PotsMessage& >(msg);
    line 773:    word            port;
    line 865:    TestRc        rc;
    line 866:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
    line 868:    bool          ring = false;
    line 869:    auto          exists = false;
    line 953:    TestRc        rc;
    line 954:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
    line 956:    string        scan;
    line 957:    auto          digits = false;
    line 958:    auto          flash = false;
    line 959:    auto          exists = false;
  W098 Function does not invoke Debug::ft
    line 341: CliText* PotsAlertingSignal::CreateText() const
    line 355: CliText* PotsDigitsSignal::CreateText() const
    line 369: CliText* PotsFacilitySignal::CreateText() const
    line 383: CliText* PotsFlashSignal::CreateText() const
    line 397: CliText* PotsLockoutSignal::CreateText() const
    line 411: CliText* PotsOffhookSignal::CreateText() const
    line 425: CliText* PotsOnhookSignal::CreateText() const
    line 439: CliText* PotsProgressSignal::CreateText() const
    line 453: CliText* PotsReleaseSignal::CreateText() const
    line 467: CliText* PotsSuperviseSignal::CreateText() const
    line 510: CliParm* PotsDigitsParameter::CreateCliParm(Usage use) const
    line 552: CliParm* PotsFacilityParameter::CreateCliParm(Usage use) const
    line 722: CliParm* PotsHeaderParameter::CreateCliParm(Usage use) const
    line 843: CliParm* PotsRingParameter::CreateCliParm(Usage use) const
    line 931: CliParm* PotsScanParameter::CreateCliParm(Usage use) const
C:/Users/gregu/Documents/tsf/tsf/pb/PotsProtocol.h:
  W017 Using statement in header
    line 30: using namespace NodeBase;
    line 31: using namespace SessionBase;
    line 32: using namespace MediaBase;
    line 33: using namespace CallBase;
  W021 Unused data
    line 90:    static const Id LastId    = NextId + 9;  // range constant
    line 118:    static const Id LastId   = NextId + 7;  // range constant
    line 210:    static const Ind MaxInd         = UINT8_MAX;
  W026 Unused function
    line 277:    MediaInfo* AddMedia(const MediaInfo& media);
    line 431:    virtual void InjectFinalMsg() override;
  W037 Member could be protected
    line 253:    explicit PotsMessage(SbIpBufferPtr& buff);
  W054 Base class constructor is public
    line 253:    explicit PotsMessage(SbIpBufferPtr& buff);
    line 257:    PotsMessage(ProtocolSM* psm, MsgSize size);
C:/Users/gregu/Documents/tsf/tsf/pb/PotsSusFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 59: CliText* PotsSusFeature::Attrs() const { return new PotsSusAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsSusFeature.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsTwcFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 70: CliText* PotsTwcFeature::Attrs() const { return new PotsTwcAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsTwcFeature.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/pb/PotsWmlFeature.cpp:
  W098 Function does not invoke Debug::ft
    line 81: CliText* PotsWmlFeature::Attrs() const { return new PotsWmlAttrs; }
C:/Users/gregu/Documents/tsf/tsf/pb/PotsWmlFeature.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
    line 17: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/rn/RnModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/sb/AnalyzeSapEvent.cpp:
  W098 Function does not invoke Debug::ft
    line 76: void AnalyzeSapEvent::Capture
C:/Users/gregu/Documents/tsf/tsf/sb/AnalyzeSnpEvent.cpp:
  W098 Function does not invoke Debug::ft
    line 72: void AnalyzeSnpEvent::Capture
C:/Users/gregu/Documents/tsf/tsf/sb/Context.cpp:
  W008 reinterpret_cast
    line 558:    auto fake = reinterpret_cast< const Context* >(&local);
    line 871:             auto toi = reinterpret_cast< TimeoutInfo* >(pptr->bytes);
  W009 Cast down the inheritance hierarchy
    line 748:                inv = static_cast< InvokerThread* >(Thread::RunningThread());
    line 866:          auto pptr = static_cast< TlvMessage* >
  W098 Function does not invoke Debug::ft
    line 314: void Context::Dump() const
    line 938: bool Context::TraceOn()
    line 948: bool Context::TraceOn(TransTrace*& trans)
  W099 Function does not invoke Debug::ft as first statement
    line 680:    Debug::ft(Context_ProcessWork);
C:/Users/gregu/Documents/tsf/tsf/sb/Context.h:
  W017 Using statement in header
    line 28: using namespace NodeBase;
  W019 Unused argument
    line 107/1:    static void Kill(fn_name_arg func, debug64_t errval, debug32_t offset);
  W026 Unused function
    line 102:    virtual void NextPort(MsgPort*& port) const { port = nullptr; }
    line 112:    static void Dump(fn_name_arg func, debug64_t errval, debug32_t offset);
    line 257:    size_t MsgCount(bool priority, bool standard) const;
  W032 Member hides inherited name
    line 152:    static ptrdiff_t LinkDiff();
  W047 Data could be const
    line 297:    Q2Link link_;
    line 321:    Faction faction_;
  W050 Default constructor invoked: POD members not initialized
    line 345:    MessageEntry trace_[TraceSize];
  W059 Base class virtual destructor is not public
    line 174:    virtual ~Context();
  W069 Virtual function is public
    line 86:    virtual ContextType Type() const = 0;
    line 90:    virtual RootServiceSM* RootSsm() const { return nullptr; }
    line 94:    virtual ProtocolSM* FirstPsm() const { return nullptr; }
    line 98:    virtual void NextPsm(ProtocolSM*& psm) const { psm = nullptr; }
    line 102:    virtual void NextPort(MsgPort*& port) const { port = nullptr; }
  W076 Adjacent arguments have the same type
    line 118:    void TraceMsg(ProtocolId prid, SignalId sid, MsgDirection dir);
  W080 Argument could be const
    line 276/1:    bool ProcessMsg(Q1Way< Message >& msgq, const InvokerThread* inv);
  W082 Function could be const
    line 144:    bool StopTimer(const Base& owner, TimerId tid);
  W084 Function could be free
    line 107:    static void Kill(fn_name_arg func, debug64_t errval, debug32_t offset);
    line 112:    static void Dump(fn_name_arg func, debug64_t errval, debug32_t offset);
C:/Users/gregu/Documents/tsf/tsf/sb/Event.cpp:
  W098 Function does not invoke Debug::ft
    line 123: void Event::Capture
C:/Users/gregu/Documents/tsf/tsf/sb/Event.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
  W036 Member could be private
    line 99:    virtual bool SaveContext();
    line 110:    virtual Event* RestoreContext(EventHandler::Rc& rc);
    line 116:    virtual void FreeContext(bool freeMsg);
    line 144:    virtual bool Save();
    line 148:    virtual Event* Restore(EventHandler::Rc& rc);
    line 152:    virtual void Free();
  W047 Data could be const
    line 199:    Id eid_;
  W069 Virtual function is public
    line 99:    virtual bool SaveContext();
    line 110:    virtual Event* RestoreContext(EventHandler::Rc& rc);
    line 116:    virtual void FreeContext(bool freeMsg);
  W084 Function could be free
    line 41:    static bool IsValidId(Id eid)
    line 57:    static bool AppCanHandle(Id eid)
C:/Users/gregu/Documents/tsf/tsf/sb/EventHandler.h:
  W017 Using statement in header
    line 25: using namespace NodeBase;
  W059 Base class virtual destructor is not public
    line 111:    virtual ~EventHandler();
  W069 Virtual function is public
    line 102:    virtual Rc ProcessEvent
  W084 Function could be free
    line 71:    static bool AppCanRegister(Id ehid)
    line 79:    static bool AppCanUse(Id ehid)
  W102 Override of Object.Patch not found
    line 35: class EventHandler : public Protected
C:/Users/gregu/Documents/tsf/tsf/sb/Factory.cpp:
  W008 reinterpret_cast
    line 187:    auto fake = reinterpret_cast< const Factory* >(&local);
  W091 Line contains adjacent spaces
    line 34:    CounterPtr       icMsgsIntra_;
    line 35:    CounterPtr       icMsgsInter_;
    line 37:    CounterPtr       ogMsgsIntra_;
    line 38:    CounterPtr       ogMsgsInter_;
    line 40:    CounterPtr       contexts_;
    line 41:    CounterPtr       msgsDeleted_;
    line 42:    CounterPtr       ctxsDeleted_;
  W098 Function does not invoke Debug::ft
    line 204: size_t Factory::DiscardedContextCount() const
    line 211: size_t Factory::DiscardedMessageCount() const
  W101 Override of Base.Display not found
    line 28: class FactoryStats : public Dynamic
C:/Users/gregu/Documents/tsf/tsf/sb/Factory.h:
  W007 Functional cast
    line 72:    Id Fid() const { return Id(fid_.GetId()); }
  W017 Using statement in header
    line 30: using namespace NodeBase;
  W019 Unused argument
    line 112/1:    virtual Message* AllocOgMsg(SignalId sid) const;
  W026 Unused function
    line 204:    void SetFaction(Faction faction) { faction_ = faction; }
  W047 Data could be const
    line 252:    ProtocolId prid_;
  W048 Data could be const pointer
    line 256:    const char* name_;
  W059 Base class virtual destructor is not public
    line 188:    virtual ~Factory();
  W069 Virtual function is public
    line 106:    virtual CliText* CreateText() const;
    line 112:    virtual Message* AllocOgMsg(SignalId sid) const;
    line 119:    virtual bool InjectMsg(Message& msg) const;
    line 125:    virtual Message* ReallocOgMsg(SbIpBufferPtr& buff) const;
    line 135:    virtual bool ScreenIcMsgs(Q1Way< Message >& msgq);
    line 157:    virtual void DisplayStats(std::ostream& stream) const;
  W071 Virtual function has no overrides
    line 157:    virtual void DisplayStats(std::ostream& stream) const;
  W076 Adjacent arguments have the same type
    line 142:    void RecordMsg(bool incoming, bool inter, size_t size) const;
  W080 Argument could be const
    line 135/1:    virtual bool ScreenIcMsgs(Q1Way< Message >& msgq);
  W082 Function could be const
    line 135:    virtual bool ScreenIcMsgs(Q1Way< Message >& msgq);
C:/Users/gregu/Documents/tsf/tsf/sb/FactoryRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 136: Factory* FactoryRegistry::GetFactory(FactoryId fid) const
C:/Users/gregu/Documents/tsf/tsf/sb/FactoryRegistry.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.cpp:
  W052 Default copy constructor invoked
    line 26: GlobalAddress::GlobalAddress() : sbAddr_(NilLocalAddress)
    line 37:    sbAddr_(NilLocalAddress)
    line 51:    sbAddr_(NilLocalAddress)
    line 65:    sbAddr_(sbAddr)
  W053 Default assignment operator invoked
    line 20: const GlobalAddress GlobalAddress::NilAddr = GlobalAddress();
C:/Users/gregu/Documents/tsf/tsf/sb/GlobalAddress.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W026 Unused function
    line 38:    GlobalAddress(const SysIpL3Addr& l3Addr, FactoryId fid);
    line 66:    bool operator!=(const GlobalAddress& that) const;
  W076 Adjacent arguments have the same type
    line 42:    GlobalAddress(const SysIpL2Addr& l2Addr, ipport_t port, FactoryId fid);
C:/Users/gregu/Documents/tsf/tsf/sb/InitiationReqEvent.cpp:
  W098 Function does not invoke Debug::ft
    line 74: void InitiationReqEvent::Capture
C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.cpp:
  W008 reinterpret_cast
    line 195:    auto fake = reinterpret_cast< const Initiator* >(&local);
C:/Users/gregu/Documents/tsf/tsf/sb/Initiator.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
  W047 Data could be const
    line 105:    ServiceId sid_;
    line 109:    ServiceId aid_;
    line 113:    TriggerId tid_;
    line 121:    Q1Link link_;
  W059 Base class virtual destructor is not public
    line 78:    virtual ~Initiator();
  W076 Adjacent arguments have the same type
    line 73:    Initiator(ServiceId sid, ServiceId aid, TriggerId tid, Priority prio);
  W080 Argument could be const
    line 92/2:       (const ServiceSM& parentSsm, Event& icEvent, Event*& ogEvent) const;
C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.cpp:
  W008 reinterpret_cast
    line 210:    auto fake = reinterpret_cast< const InvokerPool* >(&local);
  W009 Cast down the inheritance hierarchy
    line 166:    cfgInvokers_.reset(static_cast< CfgIntParm* >(reg->FindParm(parmKey)));
    line 518:       auto inv = static_cast< InvokerThread* >(Thread::RunningThread());
  W091 Line contains adjacent spaces
    line 49:    CounterPtr       requeues_;
    line 50:    CounterPtr       trojans_;
    line 51:    CounterPtr       lockouts_;
  W098 Function does not invoke Debug::ft
    line 683: void InvokerPool::RecordDelay(Message::Priority prio, msecs_t delay) const
    line 787: size_t InvokerPool::WorkQCurrLength(Message::Priority prio) const
    line 795: msecs_t InvokerPool::WorkQMaxDelay(Message::Priority prio) const
    line 803: size_t InvokerPool::WorkQMaxLength(Message::Priority prio) const
  W101 Override of Base.Display not found
    line 42: class InvokerPoolStats : public Dynamic
    line 56: class InvokerWork : public Dynamic
C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPool.h:
  W007 Functional cast
    line 55:    Faction GetFaction() const { return Faction(faction_.GetId()); }
  W017 Using statement in header
    line 29: using namespace NodeBase;
  W036 Member could be private
    line 77:    static ptrdiff_t CellDiff();
  W059 Base class virtual destructor is not public
    line 102:    virtual ~InvokerPool();
  W069 Virtual function is public
    line 73:    virtual void DisplayStats(std::ostream& stream) const;
  W071 Virtual function has no overrides
    line 73:    virtual void DisplayStats(std::ostream& stream) const;
  W082 Function could be const
    line 133:    void KickThread();
    line 137:    Context* FindWork();
    line 161:    void Requeue(Context& ctx);
    line 169:    void ScheduledOut();
  W084 Function could be free
    line 173:    static bool GenerateLog(Factory::Rc rc);
    line 185:    static TransTrace* TraceRxNet(Message& msg, const Factory& fac);
C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPoolRegistry.cpp:
  W007 Functional cast
    line 77:       auto p = reg->Pool(Faction(id));
  W098 Function does not invoke Debug::ft
    line 163: InvokerPool* InvokerPoolRegistry::Pool(Faction faction) const
C:/Users/gregu/Documents/tsf/tsf/sb/InvokerPoolRegistry.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.cpp:
  W008 reinterpret_cast
    line 109:    auto fake = reinterpret_cast< const InvokerThread* >(&local);
  W098 Function does not invoke Debug::ft
    line 98: TraceStatus InvokerThread::CalcStatus(bool dynamic) const
C:/Users/gregu/Documents/tsf/tsf/sb/InvokerThread.h:
  W017 Using statement in header
    line 25: using namespace NodeBase;
  W036 Member could be private
    line 48:    static word RtcYieldPercent() { return RtcYieldPercent_; }
    line 56:    static ptrdiff_t CellDiff2();
  W047 Data could be const
    line 119:    RegCell iid_;
    line 145:    static word RtcYieldPercent_;
C:/Users/gregu/Documents/tsf/tsf/sb/LocalAddress.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
  W026 Unused function
    line 38:    bool operator!=(const LocalAddress& that) const;
C:/Users/gregu/Documents/tsf/tsf/sb/Message.cpp:
  W098 Function does not invoke Debug::ft
    line 229: MsgDirection Message::Dir() const
    line 316: ProtocolId Message::GetProtocol() const
    line 351: SignalId Message::GetSignal() const
    line 407: MsgHeader* Message::Header() const
C:/Users/gregu/Documents/tsf/tsf/sb/Message.h:
  W017 Using statement in header
    line 30: using namespace NodeBase;
  W022 Unused enum
    line 72:    enum Location
  W023 Unused enumerator
    line 74:       NotQueued,     // being built by a factory
    line 75:       ContextQ,      // has arrived at a context
    line 76:       PsmIncomingQ,  // has arrived at a PSM
    line 77:       PsmOutgoingQ,  // has been sent by a PSM
    line 78:       PsmPendingQ    // being built by a PSM
    line 88:       IllegalSignal,   // illegal signal found              0000  sid
    line 89:       IllegalParm,     // illegal parameter found          index  pid
    line 90:       IncompleteParm,  // parameter too short              index  pid
    line 91:       MissingParm,     // mandatory parameter missing       0000  pid
    line 92:       Overflow,        // last parameter extends past end  index  pid
    line 93:       Trampled         // last parameter trampled fence    index  pid
  W026 Unused function
    line 181:    Message* FindSignal(SignalId sid) const;
  W036 Member could be private
    line 333:    virtual void Handled(bool retain);
    line 337:    virtual bool SendFailure(debug64_t errval, debug32_t offset);
  W037 Member could be protected
    line 132:    virtual InspectRc InspectMsg(debug32_t& errval) const;
    line 241:    MsgDirection Dir() const;
  W069 Virtual function is public
    line 132:    virtual InspectRc InspectMsg(debug32_t& errval) const;
    line 152:    virtual void Save();
    line 157:    virtual void Unsave();
    line 165:    virtual bool Retrieve(ProtocolSM* psm);
    line 172:    virtual bool Relay(ProtocolSM& ogPsm);
    line 176:    virtual bool SendToSelf();
    line 233:    virtual void SetReceiver(const GlobalAddress& receiver);
    line 237:    virtual void SetSender(const GlobalAddress& sender);
    line 262:    virtual bool Send(Route route);
    line 266:    virtual bool Restore();
  W071 Virtual function has no overrides
    line 152:    virtual void Save();
    line 157:    virtual void Unsave();
    line 165:    virtual bool Retrieve(ProtocolSM* psm);
    line 172:    virtual bool Relay(ProtocolSM& ogPsm);
    line 176:    virtual bool SendToSelf();
    line 233:    virtual void SetReceiver(const GlobalAddress& receiver);
    line 237:    virtual void SetSender(const GlobalAddress& sender);
    line 266:    virtual bool Restore();
    line 320:    virtual void Refresh();
    line 333:    virtual void Handled(bool retain);
    line 337:    virtual bool SendFailure(debug64_t errval, debug32_t offset);
    line 345:    virtual void ClearContext() const;
  W082 Function could be const
    line 110:    void SetSignal(SignalId sid);
    line 114:    void SetJoin(bool join);
    line 225:    void SetProtocol(ProtocolId prid);
    line 229:    void SetPriority(Priority prio);
    line 233:    virtual void SetReceiver(const GlobalAddress& receiver);
    line 237:    virtual void SetSender(const GlobalAddress& sender);
    line 362:    void SetRxAddr(const LocalAddress& rxaddr);
  W084 Function could be free
    line 274:    static const char* strPriority(Priority p);
C:/Users/gregu/Documents/tsf/tsf/sb/MsgContext.cpp:
  W009 Cast down the inheritance hierarchy
    line 67:    static_cast< MsgFactory* >(fac)->ProcessIcMsg(msg);
C:/Users/gregu/Documents/tsf/tsf/sb/MsgContext.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/MsgFactory.h:
  W036 Member could be private
    line 43:    static void CaptureMsg(Context& ctx, const Message& msg, TransTrace* tt);
  W084 Function could be free
    line 43:    static void CaptureMsg(Context& ctx, const Message& msg, TransTrace* tt);
C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.cpp:
  W052 Default copy constructor invoked
    line 28:    txAddr(NilLocalAddress),
    line 29:    rxAddr(NilLocalAddress),
C:/Users/gregu/Documents/tsf/tsf/sb/MsgHeader.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
  W036 Member could be private
    line 38:    uint8_t           spare    : 6;   // reserved for future use
  W091 Line contains adjacent spaces
    line 29:    LocalAddress      txAddr;         // source address
    line 30:    LocalAddress      rxAddr;         // destination address
    line 32:    bool              initial  : 1;   // true for initial message
    line 33:    bool              final    : 1;   // true for final message
    line 34:    bool              join     : 1;   // true to create PSM and join root SSM
    line 35:    bool              self     : 1;   // true for message to self
    line 36:    bool              injected : 1;   // true if sent by InjectCommand
    line 37:    bool              kill     : 1;   // true to kill context on arrival
    line 38:    uint8_t           spare    : 6;   // reserved for future use
    line 39:    Message::Route    route    : 2;   // the route that the message took
    line 40:    ProtocolId        protocol : 16;  // message's protocol
    line 41:    SignalId          signal   : 16;  // message's signal
    line 42:    MsgSize           length   : 16;  // total bytes in all parameters
C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.cpp:
  W009 Cast down the inheritance hierarchy
    line 65:    locAddr_.sbAddr_.fid = static_cast< ProtocolSM& >(upper).GetFactory();
    line 139:    return static_cast< PsmFactory* >(fac)->AllocIcPsm(msg, *this);
    line 205:    auto port = static_cast< MsgPort* >(pool->BidToObj(locAddr.bid));
    line 262:       static_cast< PsmFactory* >(fac)->PortAllocated(*this, msg);
  W010 Cast removes const qualification
    line 341:    return const_cast< MsgPort* >(this);
  W052 Default copy constructor invoked
    line 41:    locAddr_(msg.GetReceiver()),
    line 42:    remAddr_(msg.GetSender()),
    line 56:    locAddr_(GlobalAddress::NilAddr),
    line 57:    remAddr_(GlobalAddress::NilAddr),
  W053 Default assignment operator invoked
    line 189:    peerPort->remAddr_ = peerPrevRemAddr;
    line 190:    remAddr_ = GlobalAddress::NilAddr;
    line 302:    peerPrevRemAddr = peerPort->remAddr_;
    line 303:    locAddr_ = GlobalAddress(peerPort->locAddr_, locAddr_.sbAddr_);
    line 304:    remAddr_ = peerPort->locAddr_;
    line 305:    peerPort->remAddr_ = locAddr_;
    line 362:       remAddr_ = msg.GetSender();
    line 367:          locAddr_ = GlobalAddress(msg.RxIpAddr(), locAddr_.sbAddr_);
    line 406:       locAddr_ = GlobalAddress(txaddr, locAddr_.sbAddr_);
    line 407:       remAddr_ = msg.GetReceiver();
    line 466:       peer->remAddr_ = locAddr_;
C:/Users/gregu/Documents/tsf/tsf/sb/MsgPort.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
  W021 Unused data
    line 129:    static const PooledObjectId MaxId = 0x40000;  // 2^18 = 256K
  W084 Function could be free
    line 172:    static MsgPort* FindPeer(const GlobalAddress& remAddr);
C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.cpp:
  W008 reinterpret_cast
    line 87:    auto fake = reinterpret_cast< const Parameter* >(&local);
  W098 Function does not invoke Debug::ft
    line 179: Parameter::Usage Parameter::GetUsage(SignalId sid) const
C:/Users/gregu/Documents/tsf/tsf/sb/Parameter.h:
  W007 Functional cast
    line 64:    Id Pid() const { return Id(pid_.GetId()); }
  W017 Using statement in header
    line 25: using namespace NodeBase;
  W023 Unused enumerator
    line 100:       StreamContainsIllegalParm,
  W026 Unused function
    line 68:    ProtocolId Prid() const { return prid_; }
  W047 Data could be const
    line 172:    ProtocolId prid_;
  W059 Base class virtual destructor is not public
    line 158:    virtual ~Parameter();
  W069 Virtual function is public
    line 78:    virtual void DisplayMsg(std::ostream& stream,
    line 87:    virtual CliParm* CreateCliParm(Usage use) const;
    line 116:    virtual TestRc InjectMsg
    line 129:    virtual TestRc VerifyMsg
  W084 Function could be free
    line 134:    static const char* ExplainRc(TestRc rc);
C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.cpp:
  W008 reinterpret_cast
    line 77:    auto fake = reinterpret_cast< const Protocol* >(&local);
  W098 Function does not invoke Debug::ft
    line 120: Parameter* Protocol::FirstParm() const
    line 133: Signal* Protocol::FirstSignal() const
    line 146: Parameter* Protocol::GetParameter(ParameterId pid) const
    line 158: Signal* Protocol::GetSignal(SignalId sid) const
    line 170: void Protocol::NextParm(Parameter*& parm) const
    line 183: void Protocol::NextSignal(Signal*& sig) const
C:/Users/gregu/Documents/tsf/tsf/sb/Protocol.h:
  W007 Functional cast
    line 56:    Id Prid() const { return Id(prid_.GetId()); }
  W017 Using statement in header
    line 25: using namespace NodeBase;
  W026 Unused function
    line 65:    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const = 0;
  W036 Member could be private
    line 56:    Id Prid() const { return Id(prid_.GetId()); }
  W059 Base class virtual destructor is not public
    line 121:    virtual ~Protocol();
  W069 Virtual function is public
    line 65:    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const = 0;
    line 97:    virtual void DisplayMsg(std::ostream& stream,
C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolLayer.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
  W019 Unused argument
    line 158/1:    virtual ProtocolLayer* AllocLower(const Message* msg);
  W026 Unused function
    line 59:    bool IsLowermost() const { return lower_ == nullptr; }
  W036 Member could be private
    line 103:    virtual ProtocolLayer* JoinPeer
    line 110:    virtual bool DropPeer(const GlobalAddress& peerPrevRemAddr) = 0;
  W037 Member could be protected
    line 55:    bool IsUppermost() const { return upper_ == nullptr; }
    line 80:    virtual FactoryId GetFactory() const = 0;
  W059 Base class virtual destructor is not public
    line 134:    virtual ~ProtocolLayer();
  W069 Virtual function is public
    line 43:    virtual MsgPort* Port() const = 0;
    line 47:    virtual ProtocolSM* UppermostPsm() const = 0;
    line 80:    virtual FactoryId GetFactory() const = 0;
    line 84:    virtual Message::Route Route() const = 0;
    line 93:    virtual SysSocket* CreateAppSocket();
    line 103:    virtual ProtocolLayer* JoinPeer
    line 110:    virtual bool DropPeer(const GlobalAddress& peerPrevRemAddr) = 0;
C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 64: Protocol* ProtocolRegistry::GetProtocol(ProtocolId prid) const
C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolRegistry.h:
  W017 Using statement in header
    line 20: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.cpp:
  W009 Cast down the inheritance hierarchy
    line 419:       auto psm = static_cast< ProtocolSM* >(layer);
  W010 Cast removes const qualification
    line 683:    if(upper == nullptr) return const_cast< ProtocolSM* >(this);
C:/Users/gregu/Documents/tsf/tsf/sb/ProtocolSM.h:
  W017 Using statement in header
    line 22: using namespace NodeBase;
  W019 Unused argument
    line 287/1:    virtual void MsgHandled(Message& msg) { }
    line 293/1:    virtual void RestoreIcMsg(Message& msg) { }
    line 299/1:    virtual void RefreshMsg(Message& msg) { }
  W023 Unused enumerator
    line 82:       SignalUnknown,     // signal not recognized
    line 84:       ParameterUnknown,  // parameter not recognized
    line 85:       ParameterInvalid,  // parameter not valid for this signal
  W026 Unused function
    line 123:    Message* FirstSentMsg() const { return sentMsgq_.First(); }
    line 181:    virtual bool DropPeer(const GlobalAddress& peerPrevRemAddr) override;
    line 311:    virtual void InjectFinalMsg();
  W036 Member could be private
    line 54:    typedef uint8_t Priority;
    line 237:    virtual bool SendMsg(Message& msg) override;
  W037 Member could be protected
    line 62:    enum IncomingRc
    line 71:    enum OutgoingRc
    line 117:    Message* FirstOgMsg() const { return ogMsgq_.First(); }
  W047 Data could be const
    line 358:    FactoryId fid_;
  W071 Virtual function has no overrides
    line 227:    virtual void SetState(StateId stid);
    line 282:    virtual Priority GetPriority() const { return NormalPriority; }
    line 287:    virtual void MsgHandled(Message& msg) { }
    line 293:    virtual void RestoreIcMsg(Message& msg) { }
    line 299:    virtual void RefreshMsg(Message& msg) { }
  W082 Function could be const
    line 104:    void StopTimer(const Base& owner, TimerId tid);
C:/Users/gregu/Documents/tsf/tsf/sb/PsmContext.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W026 Unused function
    line 71:    virtual void NextPort(MsgPort*& port) const override { portq_.Next(port); }
C:/Users/gregu/Documents/tsf/tsf/sb/RootServiceSM.cpp:
  W009 Cast down the inheritance hierarchy
    line 33:    ctx_ = static_cast< SsmContext* >(Context::RunningContext());
C:/Users/gregu/Documents/tsf/tsf/sb/RootServiceSM.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
  W019 Unused argument
    line 37/1:    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
  W069 Virtual function is public
    line 37:    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
C:/Users/gregu/Documents/tsf/tsf/sb/SbCliParms.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/SbEvents.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
  W026 Unused function
    line 78:    StateId CurrState() const { return currState_; }
    line 91:    Message* SavedMsg() const { return savedMsg_; }
    line 200:    StateId CurrState() const { return currState_; }
    line 204:    StateId NextState() const { return nextState_; }
    line 345:    bool IsInitiation() const { return initiation_; }
    line 356:    Message* GetMessage() const { return message_; }
C:/Users/gregu/Documents/tsf/tsf/sb/SbExtInputHandler.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.cpp:
  W009 Cast down the inheritance hierarchy
    line 33:    auto pid = ssm.CalcPort(static_cast< const AnalyzeMsgEvent& >(currEvent));
    line 109:    auto& fte = static_cast< ForceTransitionEvent& >(currEvent);
    line 123:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
C:/Users/gregu/Documents/tsf/tsf/sb/SbHandlers.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
  W102 Override of Object.Patch not found
    line 27: class SbAnalyzeMessage : public EventHandler
    line 41: class SbAnalyzeSap : public EventHandler
    line 55: class SbAnalyzeSnp : public EventHandler
    line 69: class SbForceTransition : public EventHandler
    line 83: class SbInitiationReq : public EventHandler
C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.cpp:
  W006 C-style cast
    line 737:    ((ProtocolSM*) p)->Kill();
  W007 Functional cast
    line 686:       auto pool = reg->Pool(Faction(sc));
  W009 Cast down the inheritance hierarchy
    line 804:       auto msg = static_cast< Message* >(obj);
    line 891:       auto port = static_cast< MsgPort* >(obj);
    line 1103:       auto psm = static_cast< ProtocolSM* >(obj);
    line 1335:       auto ssm = static_cast< ServiceSM* >(obj);
    line 1548:       auto tmr = static_cast< Timer* >(obj);
C:/Users/gregu/Documents/tsf/tsf/sb/SbIncrement.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W021 Unused data
    line 42:    static const id_t LastSbIndex    = LastNwIndex + 9;
    line 71:    static const id_t LastSbIndex   = LastNwIndex + 6;
    line 100:    static const id_t LastSbIndex   = LastNwIndex + 5;
C:/Users/gregu/Documents/tsf/tsf/sb/SbInputHandler.cpp:
  W008 reinterpret_cast
    line 62:    auto header = reinterpret_cast< const MsgHeader* >(source);
  W009 Cast down the inheritance hierarchy
    line 93:    auto sbbuff = SbIpBufferPtr(static_cast< SbIpBuffer* >(buff.release()));
C:/Users/gregu/Documents/tsf/tsf/sb/SbInputHandler.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.cpp:
  W007 Functional cast
    line 112:    if(msgs->AvailCount() <= size_t(NoIngressMessageCount_)) return true;
    line 114:    return (WorkQCurrLength(Message::Ingress) >= size_t(NoIngressQueueLength_));
  W009 Cast down the inheritance hierarchy
    line 43:    noIngressQueueLength_.reset
    line 55:    noIngressMessageCount_.reset
C:/Users/gregu/Documents/tsf/tsf/sb/SbInvokerPools.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
  W069 Virtual function is public
    line 29:    virtual bool RejectIngressWork() const override;
C:/Users/gregu/Documents/tsf/tsf/sb/SbIpBuffer.h:
  W008 reinterpret_cast
    line 49:       { return reinterpret_cast< MsgHeader* >(HeaderPtr()); }
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W026 Unused function
    line 70:    static void operator delete(void* addr, SbPoolUser user);
C:/Users/gregu/Documents/tsf/tsf/sb/SbModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 51:    static bool Registered;
  W084 Function could be free
    line 47:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.cpp:
  W009 Cast down the inheritance hierarchy
    line 208:       auto port = static_cast< MsgPort* >(obj);
    line 269:    auto psm = static_cast< ProtocolSM* >(NextUsed(psmToAudit_));
    line 286:       psm = static_cast< ProtocolSM* >(NextUsed(psmToAudit_));
  W098 Function does not invoke Debug::ft
    line 391: void TimerPool::IncrTimeouts() const
C:/Users/gregu/Documents/tsf/tsf/sb/SbPools.h:
  W017 Using statement in header
    line 20: using namespace NodeBase;
  W101 Override of Base.Display not found
    line 179: class TimerPool : public ObjectPool
C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.cpp:
  W007 Functional cast
    line 128:          stream << strClass(reg->GetService(ServiceId(cid_)), false);
    line 133:          stream << strClass(reg->GetFactory(FactoryId(cid_)), false);
    line 447:    width -= col_t(label.size());
  W009 Cast down the inheritance hierarchy
    line 340:          bt = static_cast< BuffTrace* >(rec);
    line 842:       curr_ = static_cast< const AnalyzeSapEvent& >(sxp).CurrEvent()->Eid();
    line 844:       curr_ = static_cast< const AnalyzeSnpEvent& >(sxp).CurrEvent()->Eid();
    line 873:    mod_((static_cast< const InitiationReqEvent& >(sip)).GetModifier())
  W052 Default copy constructor invoked
    line 582:    locAddr_(NilLocalAddress),
    line 583:    remAddr_(NilLocalAddress),
C:/Users/gregu/Documents/tsf/tsf/sb/SbTrace.h:
  W017 Using statement in header
    line 22: using namespace NodeBase;
  W036 Member could be private
    line 520:    const StateId stid_;
  W044 Data is not private
    line 477:    ServiceId owner_;
    line 481:    const EventId eid_;
    line 516:    const ServiceId sid_;
    line 520:    const StateId stid_;
    line 524:    const EventHandler::Rc rc_;
  W054 Base class constructor is public
    line 453:    EventTrace(Id rid, const Event& evt);
    line 498:    HandlerTrace(ServiceId sid, const State& state, const Event& evt,
  W076 Adjacent arguments have the same type
    line 154:    static BuffTrace* NextIcMsg
    line 469:    static void DisplayEvent(std::ostream& stream, ServiceId sid, EventId eid);
  W084 Function could be free
    line 228:    static std::string OutputId(const std::string& label, id_t id);
    line 469:    static void DisplayEvent(std::ostream& stream, ServiceId sid, EventId eid);
C:/Users/gregu/Documents/tsf/tsf/sb/SbTracer.h:
  W017 Using statement in header
    line 21: using namespace NodeBase;
  W076 Adjacent arguments have the same type
    line 114:    TraceRc SelectSignal(ProtocolId prid, SignalId sid, TraceStatus status);
    line 166:       SignalFilter(ProtocolId p, SignalId s, TraceStatus ts);
  W101 Override of Base.Display not found
    line 100: class SbTracer : public Permanent
C:/Users/gregu/Documents/tsf/tsf/sb/SbTypes.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/Service.cpp:
  W008 reinterpret_cast
    line 268:    auto fake = reinterpret_cast< const Service* >(&local);
  W098 Function does not invoke Debug::ft
    line 356: Trigger* Service::GetTrigger(TriggerId tid) const
C:/Users/gregu/Documents/tsf/tsf/sb/Service.h:
  W007 Functional cast
    line 44:    Id Sid() const { return Id(sid_.GetId()); }
  W017 Using statement in header
    line 20: using namespace NodeBase;
  W026 Unused function
    line 110:    bool Disable();
    line 114:    bool Enable();
  W036 Member could be private
    line 58:    static bool IsValidPortId(PortId pid)
    line 100:    bool IsModifiable() const { return modifiable_; }
    line 104:    bool IsModifier() const { return modifier_; }
  W037 Member could be protected
    line 48:    typedef ServicePortId PortId;
    line 66:    virtual const char* PortName(PortId pid) const;
  W059 Base class virtual destructor is not public
    line 164:    virtual ~Service();
  W069 Virtual function is public
    line 66:    virtual const char* PortName(PortId pid) const;
    line 96:    virtual ServiceSM* AllocModifier() const;
  W076 Adjacent arguments have the same type
    line 159:    explicit Service(Id sid, bool modifiable = false, bool modifier = false);
  W084 Function could be free
    line 58:    static bool IsValidPortId(PortId pid)
C:/Users/gregu/Documents/tsf/tsf/sb/ServiceRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 64: Service* ServiceRegistry::GetService(ServiceId sid) const
C:/Users/gregu/Documents/tsf/tsf/sb/ServiceRegistry.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.cpp:
  W006 C-style cast
    line 756:             else if(((AnalyzeSapEvent*) ogEvent)->CurrInitiator() != nullptr)
    line 758:             else if(((AnalyzeSapEvent*) ogEvent)->CurrSsm() != nullptr)
  W009 Cast down the inheritance hierarchy
    line 442:             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
    line 446:          modifierSsm = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrSsm();
    line 447:          icEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
    line 497:             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
    line 503:          icEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
    line 504:          modifierInit = static_cast< AnalyzeSapEvent* >
    line 756:             else if(((AnalyzeSapEvent*) ogEvent)->CurrInitiator() != nullptr)
    line 758:             else if(((AnalyzeSapEvent*) ogEvent)->CurrSsm() != nullptr)
    line 862:          initEvent = static_cast< InitiationReqEvent* >(nextEvent);
    line 866:             initEvent->SetSapEvent(static_cast< AnalyzeSapEvent& >(sapEvent));
    line 928:             auto sibling = static_cast< InitiationReqEvent* >
    line 969:    auto& initEvent = static_cast< InitiationReqEvent& >(icEvent);
  W098 Function does not invoke Debug::ft
    line 297: Service* ServiceSM::GetService() const
C:/Users/gregu/Documents/tsf/tsf/sb/ServiceSM.h:
  W017 Using statement in header
    line 23: using namespace NodeBase;
  W019 Unused argument
    line 66/2:    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
    line 174/1:       (Event& currEvent, Event*& nextEvent);
    line 174/2:       (Event& currEvent, Event*& nextEvent);
  W026 Unused function
    line 119:    bool HasTriggered(TriggerId tid) const;
  W036 Member could be private
    line 82:    StateId NextState() const { return nextState_; }
  W059 Base class virtual destructor is not public
    line 154:    virtual ~ServiceSM();
  W069 Virtual function is public
    line 54:    virtual ServicePortId CalcPort(const AnalyzeMsgEvent& ame) = 0;
    line 60:    virtual EventHandler::Rc ProcessSap(Event& currEvent, Event*& nextEvent);
    line 66:    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
    line 87:    virtual void SetNextState(StateId stid);
    line 94:    virtual void PsmDeleted(ProtocolSM& exPsm);
    line 108:    virtual void SetNextSap(TriggerId sap);
    line 114:    virtual void SetNextSnp(TriggerId snp);
    line 126:    virtual void MorphToService(ServiceId sid);
  W071 Virtual function has no overrides
    line 126:    virtual void MorphToService(ServiceId sid);
  W082 Function could be const
    line 173:    virtual EventHandler::Rc ProcessInitNack
    line 223:    EventHandler::Rc ProcessSsmqSap
    line 234:    void ProcessSsmqSnp(ServiceSM* modifier, Event& snpEvent);
C:/Users/gregu/Documents/tsf/tsf/sb/Signal.cpp:
  W008 reinterpret_cast
    line 62:    auto fake = reinterpret_cast< const Signal* >(&local);
C:/Users/gregu/Documents/tsf/tsf/sb/Signal.h:
  W007 Functional cast
    line 60:    Id Sid() const { return Id(sid_.GetId()); }
  W017 Using statement in header
    line 21: using namespace NodeBase;
  W026 Unused function
    line 64:    ProtocolId Prid() const { return prid_; }
  W047 Data could be const
    line 103:    ProtocolId prid_;
  W059 Base class virtual destructor is not public
    line 94:    virtual ~Signal();
  W069 Virtual function is public
    line 71:    virtual CliText* CreateText() const;
  W084 Function could be free
    line 45:    static bool IsValidId(Id sid)
C:/Users/gregu/Documents/tsf/tsf/sb/SsmContext.cpp:
  W009 Cast down the inheritance hierarchy
    line 82:    return static_cast< SsmFactory* >(fac)->AllocRoot(msg, psm);
C:/Users/gregu/Documents/tsf/tsf/sb/SsmContext.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
  W084 Function could be free
    line 73:    static RootServiceSM* AllocRoot(const Message& msg, ProtocolSM& psm);
C:/Users/gregu/Documents/tsf/tsf/sb/SsmFactory.h:
  W019 Unused argument
    line 32/1:    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  W069 Virtual function is public
    line 26:    virtual RootServiceSM* AllocRoot(const Message& msg, ProtocolSM& psm) const;
    line 32:    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  W076 Adjacent arguments have the same type
    line 40:    SsmFactory(Id fid, ProtocolId prid, const char* name);
C:/Users/gregu/Documents/tsf/tsf/sb/State.cpp:
  W008 reinterpret_cast
    line 175:    auto fake = reinterpret_cast< const State* >(&local);
  W098 Function does not invoke Debug::ft
    line 110: bool State::BindEventHandler(EventHandlerId ehid, EventId eid)
    line 142: bool State::BindMsgAnalyzer(EventHandlerId ehid, ServicePortId pid)
    line 222: EventHandlerId State::GetHandler(EventId eid) const
    line 230: EventHandlerId State::MsgAnalyzer(ServicePortId pid) const
C:/Users/gregu/Documents/tsf/tsf/sb/State.h:
  W007 Functional cast
    line 39:    Id Stid() const { return Id(stid_.GetId()); }
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W026 Unused function
    line 43:    ServiceId Sid() const { return sid_; }
  W047 Data could be const
    line 102:    ServiceId sid_;
  W059 Base class virtual destructor is not public
    line 76:    virtual ~State();
C:/Users/gregu/Documents/tsf/tsf/sb/TextTlvMessage.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
  W026 Unused function
    line 45:    explicit TextTlvMessage(SbIpBufferPtr& text);
    line 49:    TextTlvMessage(ProtocolSM* psm, MsgSize size);
    line 55:    bool Receive();
  W071 Virtual function has no overrides
    line 64:    virtual SbIpBufferPtr Parse() = 0;
    line 71:    virtual SbIpBufferPtr Build() = 0;
  W082 Function could be const
    line 64:    virtual SbIpBufferPtr Parse() = 0;
    line 71:    virtual SbIpBufferPtr Build() = 0;
C:/Users/gregu/Documents/tsf/tsf/sb/Timer.cpp:
  W008 reinterpret_cast
    line 176:    auto fake = reinterpret_cast< const Timer* >(&local);
C:/Users/gregu/Documents/tsf/tsf/sb/Timer.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
  W032 Member hides inherited name
    line 39:    static ptrdiff_t LinkDiff();
  W036 Member could be private
    line 39:    static ptrdiff_t LinkDiff();
  W047 Data could be const
    line 121:    TimerId tid_;
    line 133:    Q2Link link_;
C:/Users/gregu/Documents/tsf/tsf/sb/TimerProtocol.cpp:
  W008 reinterpret_cast
    line 104:    auto toi = reinterpret_cast< const TimeoutInfo* >(bytes);
C:/Users/gregu/Documents/tsf/tsf/sb/TimerProtocol.h:
  W017 Using statement in header
    line 18: using namespace NodeBase;
  W102 Override of Object.Patch not found
    line 75: class TimeoutParameter : public TlvParameter
C:/Users/gregu/Documents/tsf/tsf/sb/TimerRegistry.cpp:
  W008 reinterpret_cast
    line 127:          auto psm = reinterpret_cast< const Base* >(t->Psm());
    line 139:          auto psm = reinterpret_cast< const Base* >(t->Psm());
C:/Users/gregu/Documents/tsf/tsf/sb/TimerRegistry.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/TimerThread.cpp:
  W098 Function does not invoke Debug::ft
    line 45: TraceStatus TimerThread::CalcStatus(bool dynamic) const
C:/Users/gregu/Documents/tsf/tsf/sb/TimerThread.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/TlvIntParameter.h:
  W017 Using statement in header
    line 21: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.cpp:
  W006 C-style cast
    line 161:    auto pptr = (TlvParmPtr) (layout->bytes + layout->header.length);
    line 270:    return (Fence*) fence;
    line 428:    pit.pptr = (TlvParmPtr) &pit.mptr->bytes[nextIndex];
  W008 reinterpret_cast
    line 51:    auto encap = reinterpret_cast< const TlvMsgLayout* >(parm.bytes);
    line 496:    auto encap = reinterpret_cast< TlvMsgLayout* >(pptr->bytes);
  W050 Default constructor invoked: POD members not initialized
    line 178:    ParmIterator pit;
    line 301:    ParmIterator pit;
    line 321:    ParmIterator pit;
    line 382:    ParmIterator locpit;
C:/Users/gregu/Documents/tsf/tsf/sb/TlvMessage.h:
  W007 Functional cast
    line 212:       return MsgSize(Memory::Align(size, Log2Align));
  W008 reinterpret_cast
    line 253:       { return reinterpret_cast< TlvMsgLayout* >(Buffer()->HeaderPtr()); }
  W017 Using statement in header
    line 22: using namespace NodeBase;
  W026 Unused function
    line 49:    TlvMessage(const TlvParmLayout& parm, ProtocolSM* psm);
    line 54:    TlvMessage(const Message& msg, ProtocolSM* psm);
    line 63:    virtual TlvParmPtr Wrap(const TlvMessage& msg, ParameterId pid);
    line 154:    size_t AllParms(TlvParmArray ptab, size_t size) const;
    line 160:    size_t FindParms(ParameterId pid, TlvParmArray ptab, size_t size) const;
    line 174:    TlvParmPtr AddBytes(const byte_t* src, MsgSize size, ParameterId pid);
    line 180:    TlvParmPtr CopyParm(const TlvParmLayout& src, ParameterId pid = NIL_ID);
    line 184:    virtual TlvParmPtr ExpandParm(TlvParmLayout& parm, MsgSize plen);
    line 236:    byte_t* FindBytes(MsgSize& size, ParameterId pid) const;
    line 243:    virtual bool MatchParm(TlvParmPtr pptr, ParmIterator& pit, bool& last) const;
    line 258:    int ParmOffset(ParmIterator& pit) const;
  W036 Member could be private
    line 143:    TlvParmPtr FirstParm(ParmIterator& pit) const;
    line 148:    TlvParmPtr NextParm(ParmIterator& pit) const;
    line 169:    virtual TlvParmPtr AddParm(ParameterId pid, MsgSize plen);
    line 230:    typedef uint16_t Fence;
    line 248:    virtual void AddFence();
    line 252:    TlvMsgLayout* TlvLayout() const
    line 263:    Fence* FencePtr() const;
    line 267:    void CheckFence() const;
  W054 Base class constructor is public
    line 37:    explicit TlvMessage(SbIpBufferPtr& buff);
    line 41:    TlvMessage(ProtocolSM* psm, MsgSize size);
    line 49:    TlvMessage(const TlvParmLayout& parm, ProtocolSM* psm);
    line 54:    TlvMessage(const Message& msg, ProtocolSM* psm);
  W069 Virtual function is public
    line 63:    virtual TlvParmPtr Wrap(const TlvMessage& msg, ParameterId pid);
    line 169:    virtual TlvParmPtr AddParm(ParameterId pid, MsgSize plen);
    line 184:    virtual TlvParmPtr ExpandParm(TlvParmLayout& parm, MsgSize plen);
    line 188:    virtual void DeleteParm(TlvParmLayout& parm);
  W071 Virtual function has no overrides
    line 63:    virtual TlvParmPtr Wrap(const TlvMessage& msg, ParameterId pid);
    line 169:    virtual TlvParmPtr AddParm(ParameterId pid, MsgSize plen);
    line 184:    virtual TlvParmPtr ExpandParm(TlvParmLayout& parm, MsgSize plen);
    line 188:    virtual void DeleteParm(TlvParmLayout& parm);
    line 243:    virtual bool MatchParm(TlvParmPtr pptr, ParmIterator& pit, bool& last) const;
    line 248:    virtual void AddFence();
  W076 Adjacent arguments have the same type
    line 100:    template< typename T > T* CopyType
  W080 Argument could be const
    line 188/1:    virtual void DeleteParm(TlvParmLayout& parm);
  W084 Function could be free
    line 210:    static MsgSize Pad(MsgSize size)
    line 287:    inline static fn_name TlvMessage_FindType()
    line 289:    inline static fn_name TlvMessage_AddType()
    line 291:    inline static fn_name TlvMessage_CopyType()
    line 293:    inline static fn_name TlvMessage_VerifyParm()
C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.cpp:
  W009 Cast down the inheritance hierarchy
    line 58:    auto& tmsg = static_cast< const TlvMessage& >(msg);
C:/Users/gregu/Documents/tsf/tsf/sb/TlvParameter.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
  W026 Unused function
    line 57:    static Id ExtractPid(const TlvParmLayout& parm);
  W038 Typedef of pointer type
    line 44: typedef TlvParmLayout* TlvParmPtr;  // pointer to a parameter
    line 45: typedef TlvParmPtr* TlvParmArray;   // array of pointers to parameters
  W084 Function could be free
    line 57:    static Id ExtractPid(const TlvParmLayout& parm);
C:/Users/gregu/Documents/tsf/tsf/sb/TlvProtocol.cpp:
  W008 reinterpret_cast
    line 55:       auto pptr = reinterpret_cast< TlvParmPtr >(&bytes[index]);
C:/Users/gregu/Documents/tsf/tsf/sb/TlvProtocol.h:
  W026 Unused function
    line 24:    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const override;
C:/Users/gregu/Documents/tsf/tsf/sb/Trigger.h:
  W017 Using statement in header
    line 21: using namespace NodeBase;
  W036 Member could be private
    line 59:    static bool IsValidId(Id tid)
  W047 Data could be const
    line 103:    Id tid_;
  W059 Base class virtual destructor is not public
    line 84:    virtual ~Trigger();
  W084 Function could be free
    line 59:    static bool IsValidId(Id tid)
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.cpp:
  W009 Cast down the inheritance hierarchy
    line 45:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 48:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 85:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 101:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 103:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 123:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 138:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 139:    auto& ode = static_cast< BcOriginationDeniedEvent& >(currEvent);
    line 154:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 156:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 162:          auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    line 183:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 210:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 240:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 257:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 281:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 296:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 310:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 325:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 340:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 342:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 361:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 382:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 397:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 413:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 430:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 431:    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
    line 448:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 462:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 464:    auto cmsg = static_cast< CipMessage* >(npsm->FirstRcvdMsg());
    line 494:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 509:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 510:    auto& tde = static_cast< BcTerminationDeniedEvent& >(currEvent);
    line 525:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 526:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 547:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 566:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 581:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 583:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 608:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 637:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 652:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 668:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 684:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 686:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 707:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 722:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 738:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 740:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 757:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 783:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 802:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 817:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 836:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 851:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 867:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 869:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 878:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 905:    auto& ate = static_cast< BcApplyTreatmentEvent& >(currEvent);
    line 906:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 944:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 960:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 976:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 977:    auto& lre = static_cast< BcLocalReleaseEvent& >(currEvent);
    line 992:    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
    line 993:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 1027:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 1048:    auto& rue = static_cast< ProxyBcReleaseUserEvent& >(currEvent);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcHandlers.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
    line 14: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBcSsm.cpp:
  W009 Cast down the inheritance hierarchy
    line 58:          auto& ppsm = static_cast< PotsCallPsm& >(psm);
    line 63:          auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
    line 71:       SetNPsm(static_cast< CipPsm& >(psm));
    line 75:       SetUPsm(static_cast< MediaPsm& >(psm));
    line 115:    auto pmsg = static_cast< PotsMessage* >(ame.Msg());
  W098 Function does not invoke Debug::ft
    line 370: PotsProfile* PotsBcSsm::Profile() const
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBicService.cpp:
  W009 Cast down the inheritance hierarchy
    line 67:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBicService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBocService.cpp:
  W009 Cast down the inheritance hierarchy
    line 67:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsBocService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallFactory.cpp:
  W009 Cast down the inheritance hierarchy
    line 99:    auto& pmsg = static_cast< const Pots_UN_Message& >(msg);
    line 180:       auto pmsg = static_cast< const PotsMessage* >(msg);
    line 182:       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
    line 186:       auto ppsm = static_cast < const PotsCallPsm* >(port.Upper());
    line 187:       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(ppsm->TsPort()));
    line 250:    auto& icmsg = static_cast< const PotsMessage& >(msg1);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallHandler.cpp:
  W008 reinterpret_cast
    line 81:    auto pptr = reinterpret_cast< TlvParmPtr >(sbuff->PayloadPtr());
    line 82:    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  W009 Cast down the inheritance hierarchy
    line 79:    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
    line 100:    auto prof = static_cast< PotsCircuit* >(cct)->Profile();
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallIpService.cpp:
  W007 Functional cast
    line 93: ipport_t PotsCallIpService::Port() const { return ipport_t(port_); }
  W098 Function does not invoke Debug::ft
    line 83: Faction PotsCallIpService::GetFaction() const { return PayloadFaction; }
    line 93: ipport_t PotsCallIpService::Port() const { return ipport_t(port_); }
    line 97: size_t PotsCallIpService::RxSize() const { return IoThread::MaxRxBuffSize; }
    line 101: size_t PotsCallIpService::TxSize() const { return IoThread::MaxTxBuffSize; }
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCallPsm.cpp:
  W009 Cast down the inheritance hierarchy
    line 90:       return static_cast< PotsCallPsm* >(psm);
    line 162:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    line 197:    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.cpp:
  W009 Cast down the inheritance hierarchy
    line 188:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 248:       auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    line 271:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 287:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCcwService.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
    line 14: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfbService.cpp:
  W009 Cast down the inheritance hierarchy
    line 41:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    line 43:    auto cfbp = static_cast< PotsCfbFeatureProfile* >(prof->FindFeature(CFB));
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfbService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfnService.cpp:
  W009 Cast down the inheritance hierarchy
    line 41:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    line 43:    auto cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfnService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfuService.cpp:
  W009 Cast down the inheritance hierarchy
    line 41:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    line 43:    auto cfup = static_cast< PotsCfuFeatureProfile* >(prof->FindFeature(CFU));
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfuService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.cpp:
  W009 Cast down the inheritance hierarchy
    line 277:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 282:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 284:       auto& cssm = static_cast< PotsCfxSsm& >(ssm);
    line 305:    auto& cssm = static_cast< PotsCfxSsm& >(ssm);
    line 306:    auto& pssm = static_cast< PotsBcSsm& >(*cssm.Parent());
    line 358:       auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 385:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 467:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    line 469:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 482:          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
    line 504:          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
    line 518:       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
    line 524:       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFB));
    line 530:       cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
    line 564:    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
    line 567:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 622:       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 629:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    line 644:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 652:       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
    line 670:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCfxService.h:
  W017 Using statement in header
    line 27: using namespace NodeBase;
    line 28: using namespace SessionBase;
    line 29: using namespace CallBase;
  W019 Unused argument
    line 46/1:    explicit PotsCfxSsm(ServiceId sid);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwmService.cpp:
  W008 reinterpret_cast
    line 1451:          auto ring = reinterpret_cast< PotsRingInfo* >(pptr->bytes);
  W009 Cast down the inheritance hierarchy
    line 433:    PotsMuxSsm* Mux() const { return static_cast< PotsMuxSsm* >(Parent()); }
    line 1152:    auto hldNPsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
    line 1189:          auto bcUPsm = static_cast< PotsCallPsm* >(psm);
    line 1259:    auto msg = static_cast< PotsMessage* >(Context::ContextMsg());
    line 1286:    auto npsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
    line 1300:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    line 1366:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    line 1410:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    line 1959:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 1960:    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
    line 1990:    auto& mux = static_cast< PotsCwmSsm& >(ssm);
    line 2005:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 2007:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2014:          auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 2111:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2113:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 2114:    auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    line 2115:    auto npsm = static_cast< PotsMuxPsm* >(pmsg->Psm());
    line 2210:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2224:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2238:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2252:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2268:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2283:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2297:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2312:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2327:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2328:    auto& are = static_cast< PotsCwmActiveReleaseEvent& >(currEvent);
    line 2343:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2344:    auto& ire = static_cast< PotsCwmInactiveReleaseEvent& >(currEvent);
    line 2358:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    line 2380:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  W019 Unused argument
    line 420/2:    EventHandler::Rc ReleaseInactive(Cause::Ind cause, Event*& nextEvent);
  W047 Data could be const
    line 171:    Cause::Ind cause_;
  W084 Function could be free
    line 440:    static EventHandler::Rc SendFacilityNack
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.cpp:
  W009 Cast down the inheritance hierarchy
    line 275:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    line 602:    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
    line 607:       auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 608:       auto ate = static_cast< BcApplyTreatmentEvent* >(sap.CurrEvent());
    line 625:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 633:       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
    line 671:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 701:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 796:    auto& init = static_cast< InitiationReqEvent& >(currEvent);
    line 798:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 893:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 915:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 946:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 948:    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
    line 954:          auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    line 978:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 1003:    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
    line 1004:    auto& pssm = static_cast< PotsBcSsm& >(*ssm.Parent());
    line 1024:    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
    line 1025:    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
    line 1029:       auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
    line 1048:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 1050:    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
    line 1054:       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    line 1094:    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
    line 1095:    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
    line 1097:    auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
    line 1142:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  W036 Member could be private
    line 237:    void StartTimer(TimerId tid, secs_t duration);
  W047 Data could be const
    line 132:    Facility::Ind ind_;
  W069 Virtual function is public
    line 242:    virtual void Cancel() override;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsCwtService.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
    line 16: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsDiscService.cpp:
  W009 Cast down the inheritance hierarchy
    line 118:    auto& pssm = static_cast< BcSsm& >(*Parent());
    line 120:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.cpp:
  W009 Cast down the inheritance hierarchy
    line 68:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    line 158:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 164:       auto htlp = static_cast< PotsHtlFeatureProfile* >(prof->FindFeature(HTL));
C:/Users/gregu/Documents/tsf/tsf/sn/PotsHtlService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.cpp:
  W009 Cast down the inheritance hierarchy
    line 181:    auto& pmsg = static_cast< const PotsMessage& >(msg);
    line 232:    auto& pmsg = static_cast< const PotsMessage& >(msg);
    line 235:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
    line 347:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    line 400:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    line 733:    auto& npsm = static_cast< PotsMuxPsm& >(psm);
    line 736:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
    line 809:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    line 877:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    line 984:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 985:    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
    line 1007:    auto& mux = static_cast< PotsMuxSsm& >(ssm);
    line 1038:    auto& mux = static_cast< PotsMuxSsm& >(ssm);
    line 1039:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 1062:    auto& mux = static_cast< PotsMuxSsm& >(ssm);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsMultiplexer.h:
  W017 Using statement in header
    line 30: using namespace NodeBase;
    line 31: using namespace SessionBase;
    line 32: using namespace MediaBase;
    line 33: using namespace CallBase;
  W019 Unused argument
    line 144/1:    PotsMuxSsm(const Message& msg, ProtocolSM& psm);
  W026 Unused function
    line 63:    PotsMuxPsm(ProtocolLayer& adj, bool upper, Switch::PortId port);
  W036 Member could be private
    line 146:    void SetProfile(PotsProfile* prof) { prof_ = prof; }
C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.cpp:
  W009 Cast down the inheritance hierarchy
    line 39:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 40:    auto msg = static_cast< CipMessage* >(ame.Msg());
    line 42:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 75:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 92:    auto msg = static_cast< CipMessage* >(Context::ContextMsg());
    line 94:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 118:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 119:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 121:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 158:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 168:    auto upsm = static_cast< ProxyBcPsm* >(pssm.UPsm());
    line 192:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 210:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 229:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 230:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 232:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 279:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 297:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 298:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 300:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 342:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 343:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 345:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 395:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 413:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 431:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 449:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 467:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 500:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 501:    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
    line 531:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 550:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 551:    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
    line 581:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    line 601:    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
    line 602:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  W091 Line contains adjacent spaces
    line 118:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 119:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 120:    auto          sid = msg->GetSignal();
    line 121:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 123:    CauseInfo*    cci;
    line 229:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 230:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 231:    auto          sid = msg->GetSignal();
    line 232:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 234:    CauseInfo*    cci;
    line 297:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 298:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 299:    auto          sid = msg->GetSignal();
    line 300:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 302:    CauseInfo*    cci;
    line 342:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 343:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    line 344:    auto          sid = msg->GetSignal();
    line 345:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    line 347:    CauseInfo*    cci;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxyHandlers.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
    line 14: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsProxySessions.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
    line 14: using namespace CallBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsSessions.h:
  W017 Using statement in header
    line 29: using namespace NodeBase;
    line 30: using namespace SessionBase;
    line 31: using namespace CallBase;
  W026 Unused function
    line 61:    virtual CliText* CreateText() const override;
  W036 Member could be private
    line 406:    ProtocolSM* TimerPsm(TimerId tid) const;
  W084 Function could be free
    line 122:    static void SendRelease(const Message& msg1);
  W101 Override of Base.Display not found
    line 39: class PotsCallIpService : public UdpIpService
C:/Users/gregu/Documents/tsf/tsf/sn/PotsStatistics.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
    line 16: using namespace CallBase;
  W036 Member could be private
    line 30:    typedef uint8_t Id;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsSusService.cpp:
  W009 Cast down the inheritance hierarchy
    line 66:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsSusService.h:
  W017 Using statement in header
    line 15: using namespace NodeBase;
    line 16: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.cpp:
  W098 Function does not invoke Debug::ft
    line 103: void PotsTreatmentRegistry::SetCauseToTreatmentQ
    line 185: PotsTreatmentQueue* PotsTreatmentRegistry::TreatmentQ
C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatmentRegistry.h:
  W017 Using statement in header
    line 16: using namespace NodeBase;
    line 17: using namespace CallBase;
  W036 Member could be private
    line 42:    void SetCauseToTreatmentQ(Cause::Ind cause, PotsTreatmentQueue::QId qid);
C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.cpp:
  W008 reinterpret_cast
    line 70:    auto fake = reinterpret_cast< const PotsTreatmentQueue* >(&local);
    line 191:    auto fake = reinterpret_cast< const PotsTreatment* >(&local);
  W009 Cast down the inheritance hierarchy
    line 240:    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
    line 284:    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
    line 314:    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
C:/Users/gregu/Documents/tsf/tsf/sn/PotsTreatments.h:
  W017 Using statement in header
    line 30: using namespace NodeBase;
    line 31: using namespace SessionBase;
    line 32: using namespace MediaBase;
    line 33: using namespace CallBase;
  W047 Data could be const
    line 146:    PotsTreatmentQueue::QId qid_;
    line 150:    Q1Link link_;
    line 179:    Tone::Id tone_;
    line 183:    secs_t duration_;
  W069 Virtual function is public
    line 122:    virtual EventHandler::Rc ApplyTreatment
C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.cpp:
  W009 Cast down the inheritance hierarchy
    line 176:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    line 178:    auto wmlp = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
    line 421:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 448:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    line 450:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 455:    wmlp_ = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
    line 527:    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
    line 530:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 590:       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    line 610:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    line 647:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 652:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    line 654:       auto& wssm = static_cast< PotsWmlSsm& >(ssm);
    line 675:    auto& wssm = static_cast< PotsWmlSsm& >(ssm);
    line 676:    auto& pssm = static_cast< PotsBcSsm& >(*wssm.Parent());
C:/Users/gregu/Documents/tsf/tsf/sn/PotsWmlService.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/sn/SnIncrement.h:
  W017 Using statement in header
    line 12: using namespace NodeBase;
C:/Users/gregu/Documents/tsf/tsf/sn/SnModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.cpp:
  W008 reinterpret_cast
    line 74:    auto fake = reinterpret_cast< const MscAddress* >(&local);
  W052 Default copy constructor invoked
    line 26:    locAddr_(mt.LocAddr()),
    line 27:    remAddr_(NilLocalAddress),
  W098 Function does not invoke Debug::ft
    line 62: bool MscAddress::ExternalFid(FactoryId& fid) const
C:/Users/gregu/Documents/tsf/tsf/st/MscAddress.h:
  W017 Using statement in header
    line 26: using namespace NodeBase;
    line 27: using namespace SessionBase;
  W047 Data could be const
    line 113:    Q1Link link_;
C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.cpp:
  W007 Functional cast
    line 327:       if(rows_[row].size() > size_t(end))
  W009 Cast down the inheritance hierarchy
    line 136:          tt = static_cast< const TransTrace* >(rec);
    line 144:          auto mt = static_cast< const MsgTrace* >(rec);
    line 697:    auto rxnet = static_cast< const TransTrace* >(events_[index]);
    line 714:             trans = static_cast< const TransTrace* >(rec);
    line 726:             return static_cast< const MsgTrace* >(rec);
    line 743:    auto txmsg = static_cast< const MsgTrace* >(events_[index]);
    line 764:             trans = static_cast< const TransTrace* >(rec);
    line 771:             auto rxmsg = static_cast< const MsgTrace* >(rec);
    line 932:          tt = static_cast< const TransTrace* >(rec);
    line 968:             mt = static_cast< const MsgTrace* >(rec);
C:/Users/gregu/Documents/tsf/tsf/st/MscBuilder.h:
  W017 Using statement in header
    line 39: using namespace NodeBase;
    line 40: using namespace SessionBase;
C:/Users/gregu/Documents/tsf/tsf/st/MscContext.cpp:
  W008 reinterpret_cast
    line 85:    auto fake = reinterpret_cast< const MscContext* >(&local);
  W098 Function does not invoke Debug::ft
    line 74: bool MscContext::IsEqualTo(const void* rcvr, uint16_t cid) const
C:/Users/gregu/Documents/tsf/tsf/st/MscContext.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
    line 18: using namespace SessionBase;
  W047 Data could be const
    line 129:    Q1Link link_;
C:/Users/gregu/Documents/tsf/tsf/st/MscContextPair.cpp:
  W008 reinterpret_cast
    line 77:    auto fake = reinterpret_cast< const MscContextPair* >(&local);
  W098 Function does not invoke Debug::ft
    line 41: void MscContextPair::Contexts(MscContext*& ctx1, MscContext*& ctx2) const
C:/Users/gregu/Documents/tsf/tsf/st/MscContextPair.h:
  W017 Using statement in header
    line 19: using namespace NodeBase;
  W047 Data could be const
    line 70:    Q1Link link_;
C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.cpp:
  W009 Cast down the inheritance hierarchy
    line 124:    auto ctx = static_cast< Context* >(pool->FirstUsed(bid));
  W041 Data is init-only
    line 439:    FunctionGuard guard(FunctionGuard::MakePreemptable, yield);
C:/Users/gregu/Documents/tsf/tsf/st/StIncrement.h:
  W017 Using statement in header
    line 14: using namespace NodeBase;
    line 15: using namespace NodeTools;
  W054 Base class constructor is public
    line 26:    StSizesCommand() { }
C:/Users/gregu/Documents/tsf/tsf/st/StModule.h:
  W017 Using statement in header
    line 13: using namespace NodeBase;
  W041 Data is init-only
    line 47:    static bool Registered;
  W084 Function could be free
    line 43:    static bool Register();
C:/Users/gregu/Documents/tsf/tsf/st/StTestData.cpp:
  W009 Cast down the inheritance hierarchy
    line 54:    return static_cast< StTestData* >(data);
C:/Users/gregu/Documents/tsf/tsf/st/StTestData.h:
  W017 Using statement in header
    line 17: using namespace NodeBase;
    line 18: using namespace SessionBase;
  W076 Adjacent arguments have the same type
    line 55:    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
  W084 Function could be free
    line 32:    static StTestData* Access(CliThread& cli);
C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.cpp:
  W009 Cast down the inheritance hierarchy
    line 494:    auto tpsm = static_cast< TestPsm* >(Psm());
    line 511:    auto tssm = static_cast< TestSsm* >(RootSsm());
    line 565:       if(p->GetFactory() == TestFactoryId) return static_cast< TestPsm* >(p);
    line 843:       SetTestPsm(static_cast< TestPsm* >(&psm));
    line 971:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    line 972:    auto tmsg = static_cast< TestMessage* >(ame.Msg());
    line 1010:    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
    line 1019:    auto apsm = static_cast< SsmFactory* >(afac)->AllocOgPsm(*amsg);
    line 1030:    auto& tssm = static_cast< TestSsm& >(ssm);
    line 1048:    auto& tssm = static_cast< TestSsm& >(ssm);
    line 1067:    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
    line 1068:    auto& tssm = static_cast< TestSsm& >(ssm);
  W053 Default assignment operator invoked
    line 404:       addr = GlobalAddress(addr, dest->EnsurePort()->LocAddr().SbAddr());
C:/Users/gregu/Documents/tsf/tsf/st/TestSessions.h:
  W017 Using statement in header
    line 28: using namespace NodeBase;
    line 29: using namespace SessionBase;
  W036 Member could be private
    line 250:    void UpdateTestPsm();
    line 326:    TestPsm* GetTestPsm() const { return testPsm_; }
  W076 Adjacent arguments have the same type
    line 332:    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
  W082 Function could be const
    line 250:    void UpdateTestPsm();
C:/Users/gregu/Documents/tsf/tsf/tsf/main.cpp:
  W015 #include not sorted in standard order
    line 79: #include "AnModule.h"
  W026 Unused function
    line 116: main_t main(int argc, char* argv[])
