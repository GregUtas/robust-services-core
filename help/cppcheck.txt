/ Documentation for warnings generated by >check
/ displayed by >ct explain <warning-number>
/
? W1
Use of NULL
  Use nullptr instead of NULL.
? W2
Pointer tag ('*') detached from type
  Attach the pointer tag to the type instead of the name:
<type>* <name> instead of <type> *<name>.
? W3
Reference tag ('&') detached from type
  Attach the reference tag to the type instead of the name:
<type>& <name> instead of <type> &<name>.
? W4
C-style cast
  Avoid the C=style cast (<type>) <expr>. Use dynamic_cast,
static_cast, reinterpret_cast, or const_cast.
? W5
Functional cast
  Avoid the functional cast <type>(<expr>). Use dynamic_cast,
static_cast, reinterpret_cast, or const_cast. A functional
cast is equivalent to a C-style cast, but RSC uses it for
safe type conversions, such as int(char) so that the char
will be displayed as a numeric rather than as a character.
? W6
reinterpret_cast
  Use dynamic_cast or static_cast where possible.
? W7
Cast down the inheritance hierarchy
  Use dynamic_cast if there is any doubt. The POTS code uses
static_cast extensively, but the subclass is certain.
? W8
Cast removes const qualification
  Casting away constness usually means that an interface is not
const correct or that something naughty is about to happen.
? W9
Pointer arithmetic
  This requires careful inspection. A common error is forgetting that
pType + offset adds offset * sizeof(Type), not just offset, to pType.
? W10
Semicolon not required
  This semicolon can be removed.
? W11
Redundant const in type specification
  Remove one (or more) consts from this type specification.
? W12
#define appears within a class or function
  Define constants using const or constexpr. A #define, if
used, is always at file scope, no matter where it occurs.
? W13
No #include guard found
  This header does not have an #include guard. Note that >check
does not understand #pragma once, although maybe it should.
? W14
#include appears outside of global namespace
  Importing a header into the middle of a file is contemptible.
? W15
#include not sorted in standard order
  Defining a standard order for #include directives precludes the use
of a customized order to resolve an interface design deficiency. The
order within RSC is
  1. header(s) that declare something that this .cpp defines
  2. headers that define base classes of classes defined in this file
  3. external headers (#include <filename>)
  4. internal headers (#include "filename.h")
And alphabetical order within each of these groups.
? W16
#include duplicated
  This file contains more than one #include for the same header.
? W17
Add #include directive
  This header should be #included because it contains something
used in this file. It is currently #included transitively, but
nothing guarantees that this should happen.
? W18
Remove #include directive
  This #include can be safely removed. This file either uses nothing
in that header, or it is guaranteed to be #included transitively.
? W19
Remove override tag: function is final
  A function should only use one tag out of {virtual, override, final}.
? W20
Using statement in header
  A header should qualify all names so that it does not promote one
and cause a conflict when that name is also used in another scope.
? W21
Using statement duplicated
  This file contains more than one using statement for the same name.
? W22
Add using statement
  A using statement should be added for this unqualified name, which is
currently resolved by a using statement in another file. But because a
header should not contain using statements, nothing guarantees that
this will continue.
? W23
Remove using statement
  Nothing in this file relies on this using statement.
? W24
Add forward declaration
  By adding a forward declaration for this item, it will be
possible to remove an #include, which speeds up compilation.
? W25
Remove forward declaration
  Nothing in this file relies on this forward declaration.
? W26
Unused argument
  This argument is not used by this function or any overrides,
so it can be removed.
? W27
Unused class
  This class has no users and can be removed.
? W28
Unused data
  This data has no users and can be removed.
? W29
Unused enum
  This enumeration has no users and can be removed.
? W30
Unused enumerator
  This enumerator has no users and can be removed.
? W31
Unused friend declaration
  This friend declaration is not needed and can be removed.
? W32
Unused function
  This function is not invoked and can be removed.
? W33
Unused typedef
  This typedef is unused and can be removed.
? W34
No referent for forward declaration
  This forward declaration is not defined and can be removed.
? W35
No referent for friend declaration
  This friend declaration is not defined and can be removed.
? W36
Indirect reference relies on friend, not forward, declaration
  This file relies on a friend declaration to make a function or
class name visible. Use an actual forward declaration instead.
? W37
Member hides inherited name
  This member has the same name as a member in a base class and
therefore makes the base class name invisible.
? W38
Class could be namespace
  This class could be defined as a namespace without compromising
encapsulation.
? W39
Class could be struct
  Although there is no difference between a class and a struct,
a class without private members is usually defined as a struct.
? W40
Struct could be class
  Although there is no difference between a struct and a class,
a struct with private members is usually defined as a class.
? W41
Redundant access control
  This public, protected, or private tag can be removed.
? W42
Member could be private
  This member could be declared as private.
? W43
Member could be protected
  This member could be declared as protected.
? W44
Typedef of pointer type
  When a typedef defines a pointer type, prefixing const to the
pointer type makes the pointer const, not the underlying type.
This can be confusing.
? W45
Anonymous enum
  This enumeration has no type name, only enumerators.
? W46
Global data initialization not found
  This data, which is declared at file scope, is not initialized.
? W47
Data is init-only
This data is initialized but never read or written.
? W48
  Data is write-only
This data is initialized and written but never read.
? W49
Global static data
  This data is defined at file scope in a header and is neither
extern nor a constexpr. It will therefore have an instance in
*each translation unit* that #includes it, which was probably
not intended.
? W50
Data is not private
  This class data is public or protected rather than private.
? W51
DATA CANNOT BE CONST
  If the code compiles, this error means that >parse or >check
has a bug when determining whether data could be const.
? W52
DATA CANNOT BE CONST POINTER
  If the code compiles, this error means that >parse or >check
has a bug when determining whether a pointer could be const.
? W53
Data could be const
  This data could be declared as const.
? W54
Data could be const pointer
  This pointer could be declared as const.
? W55
Data need not be mutable
  This data does not need to be declared as mutable.
? W56
Default constructor invoked: POD members not initialized
  This class relies on the constructor provided by the compiler
but has POD (plain ordinary data) members. Those members will
*not* be initialized when an instance of the class is created.
? W57
Default constructor invoked
  Instances of this class are created, but it does not declare
a constructor.
? W58
Default copy constructor invoked
  Instances of this class are created by copying, but it does
not declare a copy constructor.
? W59
Default copy (assignment) operator invoked
  Instances of this class are copied by assignment, but it does
not declare a copy operator.
? W60
Base class constructor is public
  This class is used as a base but its constructor is public,
which allows stand-alone instances of it to be created.
? W61
Single-argument constructor is not explicit
  This constructor takes one argument, so its class can be created
as the result of type conversion. If this is not intended, declare
the constructor as explicit.
? W62
Member not included in member initialization list
  A constructor's member initialization list omits this member.
? W63
Member not sorted in standard order in member initialization list
  A constructor's member initialization list includes this member,
but not in the order in which the class declared it. The compiler
initializes it in that order, so it should appear in that order.
? W64
Default destructor invoked
  Instances of this class are deleted, but it does not declare a
destructor.
? W65
Base class virtual destructor is not public
  This class is used as a base. Its destructor is virtual but needs
to be declared as public to properly destruct a class that derives
from it.
? W66
Base class non-virtual destructor is public
  This class is used as a base. Its destructor must be declared
as virtual to properly destruct a class that derives from it. If
the intention is to force another function to be used to destruct
instances, the destructor should not be public.
? W67
Virtual function in own class invoked by constructor or destructor
  This is dangerous because an object's class changes as the chain
of constructors or destructors is invoked. If a virtual function
is invoked during this time, it may not be the intended one, and
it might even be pure virtual, resulting in an exception.
? W68
Destructor defined, but not copy constructor
  If a class defines a destructor, it probably owns something that
it needs to delete. Whatever that is, it also needs to be handled
correctly when creating a copy of an instance, so the class also
needs a copy constructor.
? W69
Destructor defined, but not copy operator
  If a class defines a destructor, it probably owns something that
it needs to delete. Whatever that is, it also needs to be handled
correctly when copying one instance to another, so the class also
needs a copy operator.
? W70
Copy constructor defined, but not copy operator
  If a class requires a copy constructor to properly create a copy
of an instance, it also needs a copy operator to copy one instance
to another.
? W71
Copy operator defined, but not copy constructor
  If a class requires a copy operator to properly copy one instance
to another, it also needs a copy constructor to create a copy of an
instance.
? W72
Overloading operator && or ||
  Overloading either of these operators is dangerous because it is
impossible to preserve the compiler's short-circuiting semantics.
? W73
Function not implemented
  This function is declared but not defined.
? W74
Pure virtual function not implemented
  This function is declared as pure virtual but is not defined.
Although this is common practice, RSC implements a pure virtual
function so that a stack trace will be included in the exception
that is thrown if the function is invoked.
? W75
Virtual function is public
  Although RSC currently violates this guideline frequently, Herb
Sutter's article "Virtuality" makes strong arguments that
  o Public functions (except destructors) should be non-virtual.
  o Virtual functions should be protected or private.
? W76
Expression mixes bool with numeric
  A boolean was used as a numeric, or a numeric was used as a boolean.
? W77
Virtual function has no overrides
  This class declares a virtual function that no derived class overrides.
? W78
Remove virtual tag: function is an override or final
  An override should either be tagged override or final, but not virtual.
? W79
Function should be tagged as override
  This function is an override but does not use the override tag.
? W80
(void) as function argument
  This serves no purpose and can be abbreviated to ().
? W81
Anonymous argument
  This function declares an argument with no name. A name should be
included for documentation purposes.
? W82
Adjacent arguments have the same type
  Separating arguments that have the same type reduces the risk of an
invoker inadvertently swapping the values passed to those arguments.
? W83
Definition renames argument in declaration
  This function's declaration and definition use different names
for the same argument.
? W84
Override renames argument in direct base class
  This override does not use the same name for an argument as its 
direct base class.
? W85
Virtual function defines default argument
  Providing a default value for an argument to a virtual function is
inappropriate because it may not be suitable for a derived class,
which might then decide to provide its *own* default. The result is
highly error prone software.
? W86
ARGUMENT CANNOT BE CONST
  If the code compiles, this error means that >parse or >check
has a bug when determining whether an argument could be const.
? W87
Object could be passed by const reference
  This argument (an object) could be passed as a const reference.
? W88
Argument could be const
  This argument could be declared as const.
? W89
FUNCTION CANNOT BE CONST
  If the code compiles, this error means that >parse or >check
has a bug when determining whether a function could be const.
? W90
Function could be const
  This function could be declared as const.
? W91
Function could be static
  This function could be declared as static.
? W92
Function could be free
  This function does not need to be a class member.
? W93
Static function invoked via operator. or ->
  This function is static, so it can be invoked as Class::Function
rather than as instance.Function or instance->Function.
? W94
Non-boolean in conditional expression
  A conditional expression contains an implicit conversion to a bool.
This could be an inadvertent assignment such as if(i = 0), but it also
includes idioms like if(p) and if(!i) instead of if(p != nullptr) and
if(i == 0).
? W95
Arguments to binary operator have different enum types
  A binary operator is mixing items from two different enumerations.
? W96
Tab character in source code
  Replace tabs with spaces. This is automatic when using >fix.
? W97
Line indentation is not a multiple of the standard value
  This line is not indented by a multiple of 3, 4, 8, or whatever is
used as the standard. RSC uses 3, which is visually adequate without
wasting horizontal space.
? W98
Line contains trailing space
  Trailing space(s) can be removed. This is automatic when using >fix.
? W99
Line contains adjacent spaces
  Adjacent spaces can be compressed unless they serve to align columns.
? W100
Insertion of blank line recommended
  This would follow the style within RSC.
? W101
Deletion of blank line recommended
  This would follow the style within RSC and is automatic when using >fix.
? W102
Line length exceeds the standard maximum
  This line is longer than the standard, which is 80 characters in RSC.
? W103
Function not sorted in standard order
  Function definitions must appear in some order, so the convention
in RSC is to implement them alphabetically within a class, with the
constructor(s) and destructor first. This makes the definitions easy
to find, even outside the development environment.
? W104
File heading is not standard
  The comments at the top of each file should include the file's
name and the software's copyright and licensing information.
? W105
Name of #include guard is not standard
  The RSC convention is #define <filename>_H_INCLUDED.
? W106
Function does not invoke Debug::ft
  A function must invoke Debug::ft to be included in function traces.
This is usually desirable, so RSC usually omits this only for
  o inlines
  o simple "getters"
  o "streamers" (e.g. Base.Display and its overrides)
  o simple functions that would clutter a trace by appearing frequently
  o functions used while modifying the trace buffer
? W107
Function does not invoke Debug::ft as first statement
  The invocation of Debug::ft should almost always be a function's first
statement. The invocation is typically repeated in a thread loop.
? W108
Function name passed to Debug::ft is not standard
  RSC uses "<class>.<function>" or "<namespace>.<function>" to define
the fn_name passed to Debug::ft. Constructors and destructors use the
suffixes ".ctor" and ".dtor" rather than repeating the class name.
? W109
Function name passed to Debug::ft is used by another function
  More than one function passes the same fn_name to Debug::ft, which
could cause confusion.
? W110
Override of Base.Display not found
  This class ultimately derives from Base and has a data member, but
it does not override Base.Display.
? W111
Override of Object.Patch not found
  This class ultimately derives from Object, but it does not override
Object.Patch.
? W112
Function could be defaulted
  This function could be defined as "= default".
? W113
Initialization uses assignment operator
  Although the compiler might optimize it, auto item = Class(args)
constructs an instance of Class and then copies it to item. The
unambiguous alternative is to write Class item(args).
? W114
Function could be tagged noexcept
  This function could be tagged noexcept. Note that RSC uses noexcept
far more sparingly than what would be common practice elsewhere. The
reason is that even if a function does not throw or transitively use
anything that does, RSC handles signals such as SIGSEGV (falling off
a bad pointer) by throwing a SignalException. Consequently, almost
any non-trivial code could cause an exception, after which objects
on the stack need to be properly destructed when unwinding the stack
(until Thread.Start ultimately catches the exception).
? W115
Function should not be tagged noexcept
  This function is not trivial enough to be tagged noexcept.
? W116
C-style comment
  The use of /* <comment> */ should be replaced by // <comment>.
? W117
Line can merge with the next line and be under the length limit
  This line does does not need to be split for length reasons.
? W118
Copy/move constructor does not invoke base copy/move constructor
  If a copy or move constructor in a derived class does not invoke its
base equivalent, the compiler will invoke the base *constructor*, which
may not be what was intended.
? W119
Argument passed by value is modified
  Unless the intention was to pass the argument by reference, it is
usually advisable to preserve its original value.
? W120
Function returns non-const reference or pointer to member data
  Returning a non-const handle to member data is rarely appropriate.