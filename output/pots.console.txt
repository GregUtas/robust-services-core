
MODULE INITIALIZATION          msecs      invoked at
pre-Module.Startup               303    11:05:48.923
NodeBase.NbModule...                    11:05:49.226
...initialized                    87
NodeTools.NtModule...                   11:05:49.323
...initialized                    43
CodeTools.CtModule...                   11:05:49.376
...initialized                    23
NetworkBase.NwModule...                 11:05:49.409

    NET500 20-Dec-2020 11:05:49.424 on Reigi {1}
...initialized                    91
SessionBase.SbModule...                 11:05:49.509
...initialized                   104
ControlNode.CnModule...                 11:05:49.622
...initialized                     8
SessionTools.StModule...                11:05:49.641
...initialized                    19
MediaBase.MbModule...                   11:05:49.671
...initialized                    16
CallBase.CbModule...                    11:05:49.700
...initialized                    24
PotsBase.PbModule...                    11:05:49.738
...initialized                    29
OperationsNode.OnModule...              11:05:49.779
...initialized                    11
RoutingNode.RnModule...                 11:05:49.801
...initialized                    13
ServiceNode.SnModule...                 11:05:49.827
...initialized                    46
AccessNode.AnModule...                  11:05:49.884
...initialized                    23
                               -----
total initialization time        998

    NODE500 20-Dec-2020 11:05:49.932 on Reigi {2}
nb>read test.cp.all

nb>read test.cp.setup
nb>quit all
  Nothing to quit.
nb>nt
nt>sb
sb>st
st>pots
pots>read test.tools.setup
pots>stop
  OK.
pots>clear buffer
  OK.
pots>clear selections
  OK.
pots>clear tools
  OK.
pots>set tools f on
  f: OK.
  OK.
pots>/ set scope counts  / enables full function trace if commented out
pots>include all on
  OK.
pots>read test.cp.tools.setup
pots>set tools ntbc on
  n: OK.
  t: OK.
  b: OK.
  c: OK.
  OK.
pots>exclude faction &faction.watchdog
  OK.
pots>exclude faction &faction.system
  OK.
pots>exclude faction &faction.audit
  OK.
pots>exclude faction &faction.bkgd
  OK.
pots>exclude faction &faction.oper
  OK.
pots>/ exclude timers
pots>/ swflags set &flag.cipalwaysoverip on  / CIP messages can bypass IP stack if commented out
pots>symbols set dn.A 20000
  OK.
pots>symbols set dn.B 20001
  OK.
pots>symbols set dn.C 20002
  OK.
pots>symbols set dn.D 20003
  OK.
pots>symbols set dn.E 20004
  OK.
pots>symbols set dn.X 90000
  OK.
pots>symbols set dn.Y 90001
  OK.
pots>symbols set dn.Z 90002
  OK.
pots>register &dn.A
  OK.
pots>register &dn.B
  OK.
pots>register &dn.C
  OK.
pots>register &dn.D
  OK.
pots>register &dn.E
  OK.
pots>register &dn.X
  OK.
pots>register &dn.Y
  OK.
pots>register &dn.Z
  OK.
pots>symbols set port.A 11
  OK.
pots>symbols set port.B 12
  OK.
pots>symbols set port.C 13
  OK.
pots>symbols set port.D 14
  OK.
pots>symbols set port.E 15
  OK.
pots>symbols set port.X 16
  OK.
pots>symbols set port.Y 17
  OK.
pots>symbols set port.Z 18
  OK.
pots>tests prolog test.cp.prolog
  OK.
pots>tests epilog test.cp.epilog
  OK.
pots>delay 4
  OK.
pots>read test.cp.bc
pots>read bc.01
pots>tests begin bc.01
symbols set test.name bc.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A: NO DIGITS; ABANDON
pots>inject PS B &port.A
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.01 completed.
pots>read bc.02
pots>tests begin bc.02
symbols set test.name bc.02
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A: NO DIGITS; ADDRESS TIMEOUT
pots>inject PS B &port.A
pots>delay 12
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.reorder c=&cause.addresstimeout
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.02 completed.
pots>read bc.03
pots>tests begin bc.03
symbols set test.name bc.03
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A: PARTIAL DIGITS; ABANDON
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.03 completed.
pots>read bc.04
pots>tests begin bc.04
symbols set test.name bc.04
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A: PARTIAL DIGITS; ADDRESS TIMEOUT
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 12
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=x m=&port.reorder c=&cause.addresstimeout
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.04 completed.
pots>read bc.05
pots>tests begin bc.05
symbols set test.name bc.05
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A: INVALID ADDRESS
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2000#
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.reorder c=&cause.invalidaddress
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.05 completed.
pots>read bc.06
pots>tests begin bc.06
symbols set test.name bc.06
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A: UNALLOCATED NUMBER
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 20009
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence c=&cause.unallocnumber
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.06 completed.
pots>read bc.07
pots>tests begin bc.07
symbols set test.name bc.07
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: USER BUSY; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS B &port.B
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS E &port.A
pots>inject PS E &port.B
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.A m=&port.busy c=&cause.userbusy
pots>verify PS R &port.A &cause.normal
pots>verify PS R &port.B &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.07 completed.
pots>read bc.08
pots>tests begin bc.08
symbols set test.name bc.08
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS R &port.A &cause.normal
pots>verify PS R &port.B &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.08 completed.
pots>read bc.09
pots>tests begin bc.09
symbols set test.name bc.09
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER TIMEOUT
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>delay 62
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS R &port.B &cause.answertimeout
pots>verify PS S &port.A m=&port.reorder c=&cause.answertimeout
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.09 completed.
pots>read bc.10
pots>tests begin bc.10
symbols set test.name bc.10
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS D &port.A 001
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 2
pots>inject PS E &port.B
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=x
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>verify PS R &port.B &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.10 completed.
pots>read bc.11
pots>tests begin bc.11
symbols set test.name bc.11
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER; SUSPEND; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS D &port.A 001
pots>delay 2
pots>inject PS B &port.B
pots>delay 3
pots>inject PS E &port.B
pots>delay 3
pots>inject PS E &port.A
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=x
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>verify PS R &port.A &cause.normal
pots>verify PS R &port.B &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.11 completed.
pots>read bc.12
pots>tests begin bc.12
symbols set test.name bc.12
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER; SUSPEND; SUSPEND TIMEOUT
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS D &port.A 001
pots>delay 2
pots>inject PS B &port.B
pots>delay 3
pots>inject PS E &port.B
pots>delay 12
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=x
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>verify PS R &port.B &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.12 completed.
pots>read bc.13
pots>tests begin bc.13
symbols set test.name bc.13
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER; SUSPEND; RESUME; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS D &port.A 001
pots>delay 2
pots>inject PS B &port.B
pots>delay 5
pots>inject PS E &port.B
pots>delay 5
pots>inject PS B &port.B
pots>delay 5
pots>inject PS E &port.A
pots>delay 2
pots>inject PS E &port.B
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=x
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>verify PS R &port.B &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.13 completed.
pots>read bc.14
pots>tests begin bc.14
symbols set test.name bc.14
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER; RELEASE; LOCKOUT
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS D &port.A 001
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 74
pots>inject PS E &port.B
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=x
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>verify PS S &port.B m=&port.reorder
pots>verify PS S &port.B m=&port.roh
pots>verify PS L &port.B
pots>verify PS R &port.B &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.14 completed.
pots>read bc.15
pots>tests begin bc.15
symbols set test.name bc.15
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: IAM TIMEOUT
pots>/ caused by TBC purging CPG(EOS) and CPG(Alert) while ringing
pots>/ idle sent on IAM timeout; offhook response creates new call
pots>swflags set &flag.cipiamtimeout on
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 12
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS R &port.A &cause.protocoltimeout
pots>verify PS R &port.B &cause.protocoltimeout
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS R &port.A &cause.normal
pots>swflags set &flag.cipiamtimeout off
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.15 completed.
pots>read bc.16
pots>tests begin bc.16
symbols set test.name bc.16
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: ALERTING TIMEOUT
pots>swflags set &flag.cipalertingtimeout on
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 8
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS R &port.B &cause.alertingtimeout
pots>verify PS S &port.A c=&cause.alertingtimeout
pots>verify PS R &port.A &cause.normal
pots>swflags set &flag.cipalertingtimeout off
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.16 completed.
pots>read bc.17
pots>tests begin bc.17
symbols set test.name bc.17
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: RINGBACK; ANSWER; KILL CONTEXT
pots>swflags set &flag.calltrap on
pots>inject PS B &port.A
pots>delay 2
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.B
pots>
    THR902 20-Dec-2020 11:11:15.063 on Reigi {3}
    in SessionBase.InvokerThread (tid=11, nid=0x00001374): trap number 1
    type=SessionBase Exception
    errstr : trap recovery test
    offset : 0x0
    context : 04ACE6BC
    Function Traceback:
      SessionBase.SbException.SbException @ context.cpp + 111[22]
      SessionBase.Context.Kill @ context.cpp + 569[20]
      CallBase.BcOaAnalyzeRemoteMessage.ProcessEvent @ bchandlers.cpp + 131[33]
      SessionBase.SbAnalyzeMessage.ProcessEvent @ sbhandlers.cpp + 74[27]
      SessionBase.ServiceSM.ProcessEvent @ servicesm.cpp + 543[27]
      SessionBase.SsmContext.ProcessIcMsg @ ssmcontext.cpp + 195[22]
      SessionBase.Context.ProcessMsg @ context.cpp + 648[19]
      SessionBase.Context.ProcessWork @ context.cpp + 726[22]
      SessionBase.InvokerPool.ProcessWork @ invokerpool.cpp + 536[0]
      SessionBase.InvokerThread.Enter @ invokerthread.cpp + 170[0]
      NodeBase.Thread.Start @ thread.cpp + 3102[15]
      NodeBase.Thread.EnterThread @ thread.cpp + 1571[0]
      register_onexit_function @ <unknown file> (err=487)
      BaseThreadInitThunk @ <unknown file> (err=487)
      RtlGetAppContainerNamedObjectPath @ <unknown file> (err=487)
      RtlGetAppContainerNamedObjectPath @ <unknown file> (err=487)

    SESS900 20-Dec-2020 11:11:15.063 on Reigi {4}
    SessionBase.SsmContext
    this : 04ACE6BC
    patchArea : 0x0
    pid      : 5
    seq      : 1
    link     : 00000000
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    whichq  : 00000000
    link    : 
      next : 00000000
      prev : 00000000
    priMsgq : 
      tail : 00000000
      diff : 8
    stdMsgq : 
      tail : 00000000
      diff : 8
    enqTime : 1504000360983
    pool    : 01F67D00
    thread  : 03A5D200
    faction : 5
    state   : 3
    prio    : 2
    traceOn : true
    trans   : 03A9B608
    trace : 4,9> 4,9> 3,2> 4,9>
    portq : 
      tail : 04C593D0
      diff : 8
      [->]: 04C59364 SessionBase.MsgPort
      [->]: 04C593C8 SessionBase.MsgPort
    psmq  : 
      tail : 051E1B80
      diff : 8
      [->]: 051E1A44 PotsBase.PotsCallPsm
      [->]: 051E1B78 CallBase.CipPsm
    root : 0596A23C
    --------------------------------------------------------
    PotsBase.PotsCallPsm
    this : 051E1A44
    patchArea : 0x0
    pid      : 8
    seq      : 1
    link     : 051E1B80
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    ctx   : 04ACE6BC
    upper : 00000000
    lower : 04C59364
    rcvdMsgq : 
      tail : 00000000
      diff : 8
    ogMsgq   : 
      tail : 00000000
      diff : 8
    sentMsgq : 
      tail : 00000000
      diff : 8
    timerq   : 
      tail : 00000000
      diff : 8
    fid      : 7
    state    : 1
    ogMsg        : 00000000
    sendRing     : false
    sendScan     : false
    sendCause    : false
    sendFacility : false
    header : 
      signal : 0 (nullptr)
      port   : 11 (POTS 20000)
    ring : 
      on : false
    scan : 
      digits : false
      flash  : false
    cause : 
      cause : 0 (Invalid Cause)
    facility : 
      sid : 0 (nullptr)
      ind : 0
    --------------------------------------------------------
    CallBase.CipPsm
    this : 051E1B78
    patchArea : 0x0
    pid      : 8
    seq      : 1
    link     : 051E1A4C
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    ctx   : 04ACE6BC
    upper : 00000000
    lower : 04C593C8
    rcvdMsgq : 
      tail : 0503797C
      diff : 8
      [->]: 05037974 CallBase.CipMessage
    ogMsgq   : 
      tail : 00000000
      diff : 8
    sentMsgq : 
      tail : 00000000
      diff : 8
    timerq   : 
      tail : 00000000
      diff : 8
    fid      : 2
    state    : 8
    edge    : false
    ogPsm   : 051E1A44
    ogTone  : 255
    icTone  : 255
    icMedia : 
      rxFrom : 12 (POTS 20001)
    ogMediaSent : 
      rxFrom : 11 (POTS 20000)
    ogMediaCurr : 
      rxFrom : 11 (POTS 20000)
    mep : 00000000
    iamTimer : false
    --------------------------------------------------------
    CallBase.CipMessage
    this : 05037974
    patchArea : 0x0
    pid      : 6
    seq      : 1
    link     : 0503797C
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    buff    : 023A5C54
    bt      : 00000000
    handled : false
    saves   : 0
    psm     : 051E1B78
    whichq  : 051E1B94
    --------------------------------------------------------
    SessionBase.SbIpBuffer
    this : 023A5C54
    patchArea : 0x0
    pid      : 3
    seq      : 1
    link     : 00000000
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    rxTime : 1504000346380
    buff     : 02425B60
    hdrSize  : 24
    buffSize : 42
    txAddr   : 192.168.0.10: 40000
    rxAddr   : 192.168.0.10: 40000
    dir      : 0
    external : false
    queued   : false
    length   : 8
      00: 33 00 00 00 01 07 03 00 - 32 00 00 00 01 07 02 00  3.......2.......
      01: 02 80 03 00 04 00 08 00 - 00 00 04 00 0c 00 00 00  .€..............
    MsgHeader:
      txAddr : bid=51  seq=1  pid=7  fid=3
      rxAddr : bid=50  seq=1  pid=7  fid=2
      priority=2  initial=0  final=0  join=0  self=0
        injected=0  kill=0  route=2  length=8  spare=0x0
      protocol=3 (CipProtocol)  signal=4 (CipAnmSignal)
    Parameters:
      Deleted parameter: pid=0, length=4
    --------------------------------------------------------
    SessionBase.MsgPort
    this : 04C59364
    patchArea : 0x0
    pid      : 7
    seq      : 1
    link     : 04C593D0
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    ctx   : 04ACE6BC
    upper : 051E1A44
    lower : 00000000
    locAddr : 
      SessionBase.GlobalAddress
      this : 04C59380
      patchArea : 0x0
      v4Addr : 192.168.0.10: 40002
      port   : 40002
      proto  : UDP
      socket : 00000000
      sbAddr : bid=49  seq=1  pid=7  fid=7
    remAddr : 
      SessionBase.GlobalAddress
      this : 04C593A0
      patchArea : 0x0
      v4Addr : 192.168.0.10: 40001
      port   : 40001
      proto  : Any
      socket : 00000000
      sbAddr : bid=0  seq=0  pid=0  fid=6
    msgRcvd : true
    msgSent : true
    --------------------------------------------------------
    SessionBase.MsgPort
    this : 04C593C8
    patchArea : 0x0
    pid      : 7
    seq      : 1
    link     : 04C5936C
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    ctx   : 04ACE6BC
    upper : 051E1B78
    lower : 00000000
    locAddr : 
      SessionBase.GlobalAddress
      this : 04C593E4
      patchArea : 0x0
      v4Addr : 192.168.0.10: 40000
      port   : 40000
      proto  : Any
      socket : 00000000
      sbAddr : bid=50  seq=1  pid=7  fid=2
    remAddr : 
      SessionBase.GlobalAddress
      this : 04C59404
      patchArea : 0x0
      v4Addr : 192.168.0.10: 40000
      port   : 40000
      proto  : Any
      socket : 00000000
      sbAddr : bid=51  seq=1  pid=7  fid=3
    msgRcvd : true
    msgSent : true
    --------------------------------------------------------
    PotsBase.PotsBcSsm
    this : 0596A23C
    patchArea : 0x0
    pid      : 11
    seq      : 1
    link     : 00000000
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    sid       : 2
    currState : 8
    nextState : 8
    idled     : false
    nextSap   : 0
    nextSnp   : 0
    triggered : 
      1 2 4 5 7 8 9 12 13 15 16 18 19 20 23 24 
    ssmq : 
      tail : 00000000
      diff : 8
    parentSsm : 00000000
    eventq[Active] : 
      tail : 05856FF4
      diff : 8
      [->]: 05856FEC SessionBase.AnalyzeMsgEvent
    eventq[Pending] : 
      tail : 00000000
      diff : 8
    eventq[Saved] : 
      tail : 00000000
      diff : 8
    ctx : 04ACE6BC
    mgwPsm : 00000000
    model : 1
    upsm  : 051E1A44
    npsm  : 051E1B78
    dialed : 
      count  : 5
      digits : 20001
    analysis : 
      selector   : 1 (Directory Number)
      identifier : 20001
    route : 
      selector   : 7 (PotsCallFactory)
      identifier : 20001
    proxyCount : 0
    prof : 02149000
    tid  : 0
    trmt : 00000000
    --------------------------------------------------------
    SessionBase.AnalyzeMsgEvent
    this : 05856FEC
    patchArea : 0x0
    pid      : 10
    seq      : 1
    link     : 05856FF4
    assigned : true
    orphaned : 0
    corrupt  : false
    logged   : false
    eid      : 1
    owner    : 0596A23C
    location : 0
    msg : 05037974
delay 2
pots>inject PS E &port.A
pots>inject PS E &port.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS R &port.A &port.B
pots>verify PS R &port.B &port.B
pots>swflags set &flag.calltrap off
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bc.17 completed.
pots>read test.cp.cip
pots>read cip.01
pots>tests begin cip.01
symbols set test.name cip.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ INJECT IAM TO A; ANSWER; RELEASE
pots>inject CO 1 I r &factory.pots.call &dn.A &dn.X &dn.A m=&port.X
pots>delay 4
pots>verify PS S &port.A r=t
pots>verify CO 1 C &prog.eos
pots>verify CO 1 C &prog.alerting m=&port.ringback
pots>inject PS B &port.A
pots>delay 2
pots>verify PS S &port.A r=f m=&port.X
pots>verify CO 1 A m=&port.A
pots>inject CO 1 R &cause.normal m=&port.silence
pots>delay 2
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>inject PS E &port.A
pots>delay 2
pots>verify PS R &port.A &cause.normal
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cip.01 completed.
pots>read cip.02
pots>tests begin cip.02
symbols set test.name cip.02
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ CALL TEST DN
pots>inject PS B &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>inject PS D &port.A 90000
pots>delay 2
pots>verify PS S &port.A s=x m=&port.silence
pots>verify CT 2 I r &factory.call.test &dn.X &dn.A &dn.X m=&port.A
pots>inject CT 2 C &prog.eos
pots>delay 2
pots>inject CT 2 C &prog.alerting m=&port.ringback
pots>delay 2
pots>verify PS S &port.A m=&port.ringback
pots>inject CT 2 A m=&port.X
pots>delay 2
pots>verify PS S &port.A m=&port.X
pots>inject PS E &port.A
pots>delay 2
pots>verify PS R &port.A &cause.normal
pots>verify CT 2 R &cause.normal m=&port.silence
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cip.02 completed.
pots>read test.cp.ss
pots>read sus.01
pots>tests begin sus.01
symbols set test.name sus.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A sus
pots>/ A: SUS(OBC)
pots>inject PS B &port.A
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A m=&port.reorder c=&cause.facilityreject
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A sus
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test sus.01 completed.
pots>read sus.02
pots>tests begin sus.02
symbols set test.name sus.02
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.B sus
pots>/ A-B: SUS(TBC)
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.A c=&cause.destoutoforder
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.B sus
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test sus.02 completed.
pots>read boc.01
pots>tests begin boc.01
symbols set test.name boc.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A boc
pots>/ A: BOC
pots>inject PS B &port.A
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A m=&port.reorder c=&cause.incomingbarred
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A boc
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test boc.01 completed.
pots>read sus.03
pots>tests begin sus.03
symbols set test.name sus.03
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A sus
pots>subscribe &dn.A boc
pots>/ A: SUS(OBC) & BOC
pots>inject PS B &port.A
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A m=&port.reorder c=&cause.facilityreject
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A sus
pots>unsubscribe &dn.A boc
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test sus.03 completed.
pots>read bic.01
pots>tests begin bic.01
symbols set test.name bic.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.B bic
pots>/ A-B: BIC
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.A c=&cause.outgoingbarred
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.B bic
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test bic.01 completed.
pots>read sus.04
pots>tests begin sus.04
symbols set test.name sus.04
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.B bic
pots>subscribe &dn.B sus
pots>/ A-B: SUS(TBC) & BIC
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.A c=&cause.destoutoforder
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.B bic
pots>unsubscribe &dn.B sus
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test sus.04 completed.
pots>read htl.01
pots>tests begin htl.01
symbols set test.name htl.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A htl &dn.B
pots>/ A-B: HTL USAGE
pots>inject PS B &port.A
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>inject PS E &port.B
pots>delay 3
pots>inject PS E &port.A
pots>delay 2
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>verify PS R &port.A &cause.normal
pots>verify PS R &port.B &cause.normal
pots>unsubscribe &dn.A htl
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test htl.01 completed.
pots>read wml.01
pots>tests begin wml.01
symbols set test.name wml.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A: ABANDON (WML ACTIVATED)
pots>inject PS B &port.A
pots>delay 3
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.01 completed.
pots>read wml.02
pots>tests begin wml.02
symbols set test.name wml.02
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A: PARTIAL DIAL (WML ACTIVATED)
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A 2
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.02 completed.
pots>read wml.03
pots>tests begin wml.03
symbols set test.name wml.03
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A-B: WML USAGE; RINGBACK; RELEASE
pots>inject PS B &port.A
pots>delay 8
pots>inject PS E &port.A
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS R &port.A &cause.normal
pots>verify PS R &port.B &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.03 completed.
pots>read wml.04
pots>tests begin wml.04
symbols set test.name wml.04
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A: WML DEACTIVATION
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A *34
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A: ADDRESS TIMEOUT (WML DEACTIVATED)
pots>inject PS B &port.A
pots>delay 12
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.reorder c=&cause.addresstimeout
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.04 completed.
pots>read wml.05
pots>tests begin wml.05
symbols set test.name wml.05
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A: WML DEACTIVATION
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &sc.wml.deactivation
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A: WML ACTIVATION TO B
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &sc.wml.activation
pots>delay 2
pots>inject PS D &port.A #
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=d m=&port.stutter
pots>verify PS S &port.A s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A-B: WML USAGE; RINGBACK; RELEASE
pots>inject PS B &port.A
pots>delay 8
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS R &port.A &cause.normal
pots>verify PS R &port.B &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.05 completed.
pots>read wml.06
pots>tests begin wml.06
symbols set test.name wml.06
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A: WML DEACTIVATION
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &sc.wml.deactivation
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A: WML ACTIVATION TO SELF
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &sc.wml.activation
pots>delay 2
pots>inject PS D &port.A &dn.A
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=d m=&port.stutter
pots>verify PS S &port.A s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A-B: WML USAGE; USER BUSY
pots>inject PS B &port.A
pots>delay 8
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.A m=&port.busy c=&cause.userbusy
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.06 completed.
pots>read wml.07
pots>tests begin wml.07
symbols set test.name wml.07
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>subscribe &dn.A wml &dn.B 6
pots>/ A: WML DEACTIVATION
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &sc.wml.deactivation
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A: WML ACTIVATION ERROR
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &sc.wml.activation
pots>delay 2
pots>inject PS D &port.A &sc.wml.deactivation
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=d m=&port.stutter
pots>verify PS S &port.A s=x m=&port.reorder c=&cause.invalidaddress
pots>verify PS R &port.A &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A: ADDRESS TIMEOUT (WML DEACTIVATED)
pots>inject PS B &port.A
pots>delay 12
pots>inject PS E &port.A
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.reorder c=&cause.addresstimeout
pots>verify PS R &port.A &cause.normal
pots>unsubscribe &dn.A wml
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test wml.07 completed.
pots>read test.cp.cfx
pots>read cfx.01
pots>subscribe &dn.B cfu &dn.C
  OK.
pots>tests begin cfx.01
symbols set test.name cfx.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: VERIFY CFU INACTIVE
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>inject PS E &port.B
pots>delay 1
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>verify PS R &port.B &cause.normal
pots>delay 1
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ B: ACTIVATE CFU TO C (PROVISIONED)
pots>inject PS B &port.B
pots>delay 1
pots>inject PS D &port.B &sc.cfu.activation
pots>delay 2
pots>inject PS D &port.B #
pots>delay 2
pots>inject PS E &port.B
pots>delay 1
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.B s=d m=&port.stutter
pots>verify PS S &port.B s=x m=&port.conf c=&cause.confirmation
pots>verify PS R &port.B &cause.normal
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A-B(CFU)-C: RINGBACK, ANSWER, RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.C
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>inject PS E &port.C
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.C r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.C r=f m=&port.A
pots>verify PS S &port.A m=&port.C
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.C m=&port.silence c=&cause.normal
pots>verify PS R &port.C &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cfx.01 completed.
pots>unsubscribe &dn.B cfu
  OK.
pots>read cfx.02
pots>subscribe &dn.B cfb &dn.C
  OK.
pots>tests begin cfx.02
symbols set test.name cfx.02
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: VERIFY CFB INACTIVE
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>inject PS E &port.B
pots>delay 1
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>verify PS R &port.B &cause.normal
pots>delay 1
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A-B(CFB)-C: ANSWER; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS B &port.B
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.C
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>inject PS E &port.B
pots>inject PS E &port.C
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.C r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.C r=f m=&port.A
pots>verify PS S &port.A m=&port.C
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.C m=&port.silence c=&cause.normal
pots>verify PS R &port.B &cause.normal
pots>verify PS R &port.C &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cfx.02 completed.
pots>unsubscribe &dn.B cfb
  OK.
pots>read cfx.03
pots>subscribe &dn.B cfn &dn.C 12
  OK.
pots>tests begin cfx.03
symbols set test.name cfx.03
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: ANSWER (VERIFY CFN NOT TRIGGERED)
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>inject PS E &port.B
pots>delay 1
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>verify PS R &port.B &cause.normal
pots>delay 1
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>/ A-B(CFN)-C: ANSWER; RELEASE
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 15
pots>inject PS B &port.C
pots>delay 2
pots>inject PS E &port.A
pots>delay 1
pots>inject PS E &port.C
pots>delay 1
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS R &port.B &cause.callredirected
pots>verify PS S &port.C r=t
pots>verify PS S &port.C r=f m=&port.A
pots>verify PS S &port.A m=&port.C
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.C m=&port.silence c=&cause.normal
pots>verify PS R &port.C &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cfx.03 completed.
pots>unsubscribe &dn.B cfn
  OK.
pots>read cfx.04
pots>subscribe &dn.B cwt
  OK.
pots>subscribe &dn.B cfb &dn.E
  OK.
pots>tests begin cfx.04
symbols set test.name cfx.04
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B: ANSWER
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>delay 2
pots>/ D-B: CWT
pots>inject PS B &port.D
pots>delay 1
pots>inject PS D &port.D &dn.B
pots>delay 2
pots>verify PS S &port.D s=d m=&port.dial
pots>verify PS S &port.D s=x m=&port.silence
pots>verify PM F &port.B f &service.cwm &facility.req
pots>verify PC F &port.B f &service.cwa &facility.req
pots>verify PM F &port.B f &service.cwm &facility.ack
pots>verify PC F &port.B f &service.cwb &facility.ack
pots>verify PM S &port.B r=t
pots>verify PS S &port.B s=f m=&port.cwt
pots>verify PC A &port.B
pots>verify PS S &port.D m=&port.ringback
pots>/ C-B(CFB)-E: RINGBACK
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.B
pots>delay 5
pots>/ VERIFY C-E ALERTING AFTER B(CWT) FAILS
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.B f &service.cwm &facility.req
pots>verify PC F &port.B f &service.cwb &facility.nack
pots>verify PM R &port.B &cause.callredirected
pots>verify PS S &port.E r=t
pots>verify PS S &port.C m=&port.ringback
pots>/ VERIFY A-B RECONNECTED (END OF CWT TONE)
pots>verify PS S &port.B m=&port.A
pots>/ C-E ANSWER; RELEASE
pots>inject PS B &port.E
pots>delay 2
pots>inject PS E &port.C
pots>delay 2
pots>inject PS E &port.E
pots>delay 2
pots>/* ADD VERIFICATION
pots>/ RELEASE A, B, D
pots>inject PS E &port.A
pots>inject PS E &port.D
pots>inject PS E &port.B
pots>delay 2
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cfx.04 completed.
pots>unsubscribe &dn.B cfb
  OK.
pots>unsubscribe &dn.B cwt
  OK.
pots>read cfx.05
pots>subscribe &dn.A cwt
  OK.
pots>subscribe &dn.A cfn &dn.D 12
  OK.
pots>tests begin cfx.05
symbols set test.name cfx.05
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ B-A: ANSWER
pots>read bc.BA
pots>/ B-A: RINGBACK; ANSWER
pots>inject PS B &port.B
pots>delay 1
pots>inject PS D &port.B &dn.A
pots>delay 2
pots>inject PS B &port.A
pots>delay 2
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.B s=x m=&port.silence
pots>verify PS S &port.A r=t
pots>verify PS S &port.B m=&port.ringback
pots>verify PS S &port.A r=f m=&port.B
pots>verify PS S &port.B m=&port.A
pots>delay 2
pots>/ C-A(CWT)
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.A
pots>delay 2
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ CFN TIMEOUT: C-A(CFN)-D
pots>delay 15
pots>/ ANSWER D
pots>inject PS B &port.D
pots>delay 2
pots>/* ADD VERIFICATION
pots>/ IDLE B, A, C, D
pots>inject PS E &port.B
pots>inject PS E &port.C
pots>inject PS E &port.A
pots>inject PS E &port.D
pots>delay 2
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cfx.05 completed.
pots>unsubscribe &dn.A cfn
  OK.
pots>unsubscribe &dn.A cwt
  OK.
pots>read test.cp.cwt
pots>read cwt.01
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>tests verify on
  OK.
pots>tests begin cwt.01
symbols set test.name cwt.01
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.A
pots>delay 3
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
pots>verify PS S &port.A m=&port.B
pots>/ 1D
pots>read cwt.Nd2ExC
pots>/ NOTIFIED 2; IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A s=x c=&cause.normal
pots>verify PC F &port.A f &service.cwa &facility.cwt.released
pots>/ 1E
pots>read cwt.Nu1ExA
pots>/ NULL 1: EXIT A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.01 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.02
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>tests verify on
  OK.
pots>tests begin cwt.02
symbols set test.name cwt.02
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
pots>delay 2
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 2D
pots>read cwt.AdAFls
pots>/ FLASH (FLIP TO ORIGINAL)
pots>inject PS L &port.A
pots>delay 2
pots>verify PS S &port.A m=&port.B
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.C m=&port.held
pots>verify PS S &port.B m=&port.A
pots>/ 2E
pots>read cwt.AdHFls
pots>/ FLASH (FLIP TO WAITING)
pots>inject PS L &port.A
pots>delay 2
pots>verify PC P &port.A 5 m=&port.A
pots>verify PC P &port.A 5 m=&port.held
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 2F
pots>read cwt.MuxSus
pots>/ ONHOOK (SUSPEND)
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>/ 2G
pots>read cwt.MuxRes
pots>/ OFFHOOK (RESUME)
pots>inject PS B &port.A
pots>delay 2
pots>verify PC B &port.A
pots>/ 2D (REPEATED)
pots>read cwt.AdAFls
pots>/ FLASH (FLIP TO ORIGINAL)
pots>inject PS L &port.A
pots>delay 2
pots>verify PS S &port.A m=&port.B
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.C m=&port.held
pots>verify PS S &port.B m=&port.A
pots>/ 2H
pots>read cwt.AdHExA
pots>/ ORIGINAL ACTIVE: ONHOOK A (RERING)
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A r=t m=&port.silence
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ 2I
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>/ 2J
pots>read cwt.ReCOff
pots>/ C RERINGING: REANSWER
pots>inject PS B &port.A
pots>delay 2
pots>verify PS S &port.A r=f s=x m=&port.C
pots>verify PC F &port.A f &service.cwb &facility.cwt.reanswered m=&port.A
pots>verify PS S &port.C m=&port.A
pots>/ 2K
pots>read cwt.MuxSus
pots>/ ONHOOK (SUSPEND)
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>/ IDLE C (A SUSPENDED)
pots>inject PS E &port.C
pots>delay 1
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.02 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.03
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.BA
pots>/ B-A: RINGBACK; ANSWER
pots>inject PS B &port.B
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.B &dn.A
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.B s=x m=&port.silence
pots>verify PS S &port.A r=t
pots>verify PS S &port.B m=&port.ringback
pots>verify PS S &port.A r=f m=&port.B
pots>verify PS S &port.B m=&port.A
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>tests verify on
  OK.
pots>tests begin cwt.03
symbols set test.name cwt.03
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 3A
pots>read cwt.Nd2ExB
pots>/ NOTIFIED 2; IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 3B
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
pots>verify PS S &port.A m=&port.cwt
pots>/ 3C
pots>read cwt.Nf1Tmr
pots>/ NOTIFYING 1: STOP CWT TONE
pots>delay 4
pots>verify PS S &port.A m=&port.silence
pots>/ 3D & 3E
pots>read cwt.Rd1Fls
pots>/ RENOTIFIED 1: FLASH (ANSWER)
pots>inject PS L &port.A
pots>delay 2
pots>verify PC B &port.A m=&port.A
pots>/ RING OFF
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.A s=x
pots>verify PC F &port.A f &service.cwb &facility.cwt.answered
pots>verify PS S &port.C m=&port.A
pots>/ IDLE C
pots>inject PS E &port.C
pots>/ IDLE A
pots>inject PS E &port.A
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.03 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.04
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>tests verify on
  OK.
pots>tests begin cwt.04
symbols set test.name cwt.04
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 4A
pots>read cwt.Rd2Tmr
pots>/ RENOTIFIED 2: CWT ANSWER TIMEOUT
pots>delay 6
pots>verify PC F &port.A f &service.cwb &facility.cwt.unanswered
pots>verify PC F &port.A f &service.cwa &facility.cwt.unanswered
pots>verify PM R &port.A &cause.answertimeout
pots>verify PS S &port.A s=x c=&cause.answertimeout
pots>/ IDLE A
pots>read cwt.Nu1ExA
pots>/ NULL 1: EXIT A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>/ 4B
pots>read cwt.Nu0Tmr
pots>/ NULL 0: ANSWER TIMEOUT (C)
pots>delay 32
pots>verify PS S &port.C m=&port.reorder c=&cause.answertimeout
pots>/ 4C
pots>read cwt.Nu0ExC
pots>/ NULL 0: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.04 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.05
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>tests verify on
  OK.
pots>tests begin cwt.05
symbols set test.name cwt.05
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 5A
pots>read cwt.Nd2ExA
pots>/ RENOTIFIED 2: ONHOOK A (RING)
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A r=t m=&port.silence
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ verify PC A &port.A [sent by shelf, so marked injected]
pots>verify PS S &port.A s=x
pots>verify PC F &port.A f &service.cwb &facility.cwt.alerted
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>/ 5B
pots>read cwt.Nu1Off
pots>/ NULL: C RINGING A; ANSWER
pots>inject PS B &port.A
pots>delay 2
pots>verify PC B &port.A
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A r=f m=&port.C
pots>verify PS S &port.C m=&port.A
pots>/ 5C
pots>read cwt.Nu1ExC
pots>/ NULL 1: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM S &port.A m=&port.silence c=&cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 5D
pots>read cwt.Nu0ExA
pots>/ NULL 0: IDLE A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.05 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.06
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.BA
pots>/ B-A: RINGBACK; ANSWER
pots>inject PS B &port.B
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.B &dn.A
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.B s=x m=&port.silence
pots>verify PS S &port.A r=t
pots>verify PS S &port.B m=&port.ringback
pots>verify PS S &port.A r=f m=&port.B
pots>verify PS S &port.B m=&port.A
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 3A
pots>read cwt.Nd2ExB
pots>/ NOTIFIED 2; IDLE B
pots>inject PS E &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 3B
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 3C
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>tests verify on
  OK.
pots>tests begin cwt.06
symbols set test.name cwt.06
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 6A & 6B
pots>read cwt.Rd1Tmr
pots>/ RENOTIFIED 1: CWT ANSWER TIMEOUT
pots>delay 6
pots>verify PC F &port.A f &service.cwb &facility.cwt.unanswered
pots>verify PM R &port.A &cause.answertimeout
pots>verify PC F &port.A f &service.disc &facility.req c=&cause.answertimeout
pots>verify PS S &port.A s=x
pots>verify PM S &port.A m=&port.reorder c=&cause.answertimeout
pots>verify PS S &port.A m=&port.reorder c=&cause.answertimeout
pots>/ IDLE A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>/ IDLE C
pots>read cwt.Nu0ExC
pots>/ NULL 0: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.06 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.07
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>tests verify on
  OK.
pots>tests begin cwt.07
symbols set test.name cwt.07
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 7A
pots>read cwt.AdAExB
pots>/ ACTIVE ON WAITING CALL: IDLE B
pots>inject PS E &port.B
pots>delay 12
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A s=x c=&cause.normal
pots>verify PC F &port.A f &service.cwb &facility.cwt.released
pots>/ IDLE C
pots>read cwt.Nu1ExC
pots>/ NULL 1: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM S &port.A m=&port.silence c=&cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ IDLE A
pots>read cwt.Nu0ExA
pots>/ NULL 0: IDLE A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.07 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.08
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>tests verify on
  OK.
pots>tests begin cwt.08
symbols set test.name cwt.08
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 8A
pots>read cwt.AdAExC
pots>/ ACTIVE ON WAITING CALL: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 8B
pots>read cwt.Hg1ExA
pots>/ HOLDING 1: ONHOOK A (RERING)
pots>inject PS E &port.A
pots>delay 2
pots>verify PS S &port.A r=t
pots>/ 8C
pots>read cwt.ReBOff
pots>/ B RERINGING: OFFHOOK (REANSWER)
pots>inject PS B &port.A
pots>delay 2
pots>verify PS S &port.A r=f s=x m=&port.B
pots>verify PC F &port.A f &service.cwa &facility.cwt.reanswered m=&port.A
pots>verify PS S &port.B m=&port.A
pots>/ IDLE A
pots>read cwt.Nu1ExA
pots>/ NULL 1: EXIT A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.08 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.09
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.BA
pots>/ B-A: RINGBACK; ANSWER
pots>inject PS B &port.B
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.B &dn.A
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.B s=x m=&port.silence
pots>verify PS S &port.A r=t
pots>verify PS S &port.B m=&port.ringback
pots>verify PS S &port.A r=f m=&port.B
pots>verify PS S &port.B m=&port.A
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>tests verify on
  OK.
pots>tests begin cwt.09
symbols set test.name cwt.09
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 9A
pots>read cwt.Nf2ExB
pots>/ NOTIFYING 2; IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A c=&cause.normal
pots>/ 9B
pots>read cwt.Hg1Fls
pots>/ HOLDING 1: FLASH (ANSWER)
pots>inject PS L &port.A
pots>delay 2
pots>verify PS S &port.A m=&port.silence
pots>verify PC B &port.A m=&port.A
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.A s=x
pots>verify PC F &port.A f &service.cwb &facility.cwt.answered
pots>verify PS S &port.C m=&port.A
pots>/ IDLE C
pots>inject PS E &port.C
pots>/ IDLE A
pots>inject PS E &port.A
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.09 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.10
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>tests verify on
  OK.
pots>tests begin cwt.10
symbols set test.name cwt.10
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 10A
pots>read cwt.Rf2ExC
pots>/ RENOTIFYING 2: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A s=x m=&port.B c=&cause.normal
pots>verify PC F &port.A f &service.cwa &facility.cwt.released
pots>/ IDLE A
pots>read cwt.Nu1ExA
pots>/ NULL 1: EXIT A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.10 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.11
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 2D
pots>read cwt.AdAFls
pots>/ FLASH (FLIP TO ORIGINAL)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A m=&port.B
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.C m=&port.held
pots>verify PS S &port.B m=&port.A
pots>tests verify on
  OK.
pots>tests begin cwt.11
symbols set test.name cwt.11
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 11A
pots>read cwt.AdHExB
pots>/ WAITING CALL HELD: IDLE B
pots>inject PS E &port.B
pots>delay 12
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 11B
pots>read cwt.Hg1Tmr
pots>/ HOLDING 1: TIMEOUT (RECONNECT)
pots>delay 12
pots>verify PS S &port.A s=x m=&port.C
pots>verify PC F &port.A f &service.cwb &facility.cwt.reconnected m=&port.A
pots>verify PS S &port.C m=&port.A
pots>/ IDLE B
pots>read cwt.Nu1ExC
pots>/ NULL 1: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM S &port.A m=&port.silence c=&cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ IDLE A
pots>read cwt.Nu0ExA
pots>/ NULL 0: IDLE A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.11 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.12
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 2D
pots>read cwt.AdAFls
pots>/ FLASH (FLIP TO ORIGINAL)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A m=&port.B
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.C m=&port.held
pots>verify PS S &port.B m=&port.A
pots>/ 11A
pots>read cwt.AdHExB
pots>/ WAITING CALL HELD: IDLE B
pots>inject PS E &port.B
  OK.
pots>delay 12
  OK.
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>tests verify on
  OK.
pots>tests begin cwt.12
symbols set test.name cwt.12
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 12A
pots>read cwt.Hg1ExC
pots>/ HOLDING 1: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PC F &port.A f &service.disc &facility.req c=&cause.normal
pots>verify PS S &port.A s=x
pots>verify PM S &port.A c=&cause.normal
pots>verify PS S &port.A c=&cause.normal
pots>/ IDLE A
pots>inject PS E &port.A
pots>delay 1
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.12 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.13
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 8A
pots>read cwt.AdAExC
pots>/ ACTIVE ON WAITING CALL: IDLE C
pots>inject PS E &port.C
  OK.
pots>delay 2
  OK.
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 8B
pots>read cwt.Hg1ExA
pots>/ HOLDING 1: ONHOOK A (RERING)
pots>inject PS E &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A r=t
pots>tests verify on
  OK.
pots>tests begin cwt.13
symbols set test.name cwt.13
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 13A
pots>read cwt.Re1Tmr
pots>/ RERINGING: TIMEOUT
pots>delay 30
pots>verify PS R &port.A &cause.normal
pots>verify PC R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.13 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.14
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 8A
pots>read cwt.AdAExC
pots>/ ACTIVE ON WAITING CALL: IDLE C
pots>inject PS E &port.C
  OK.
pots>delay 2
  OK.
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>/ 8B
pots>read cwt.Hg1ExA
pots>/ HOLDING 1: ONHOOK A (RERING)
pots>inject PS E &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A r=t
pots>tests verify on
  OK.
pots>tests begin cwt.14
symbols set test.name cwt.14
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 14A
pots>read cwt.Re1ExB
pots>/ RERINGING: IDLE B
pots>inject PS E &port.B
pots>delay 12
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.14 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.15
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.BA
pots>/ B-A: RINGBACK; ANSWER
pots>inject PS B &port.B
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.B &dn.A
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.B s=d m=&port.dial
pots>verify PS S &port.B s=x m=&port.silence
pots>verify PS S &port.A r=t
pots>verify PS S &port.B m=&port.ringback
pots>verify PS S &port.A r=f m=&port.B
pots>verify PS S &port.B m=&port.A
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 3A
pots>read cwt.Nd2ExB
pots>/ NOTIFIED 2; IDLE B
pots>inject PS E &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>tests verify on
  OK.
pots>tests begin cwt.15
symbols set test.name cwt.15
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 15A
pots>inject PS E &port.A
pots>delay 2
pots>verify PS S &port.A r=t
pots>verify PC P &port.A &prog.media m=&port.A
pots>/ verify PC A &port.A [sent by shelf, so marked injected]
pots>verify PS S &port.A s=x
pots>verify PC F &port.A f &service.cwb &facility.cwt.alerted
pots>/ C RINGING: ANSWER
pots>read cwt.Nu1Off
pots>/ NULL: C RINGING A; ANSWER
pots>inject PS B &port.A
pots>delay 2
pots>verify PC B &port.A
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A r=f m=&port.C
pots>verify PS S &port.C m=&port.A
pots>/ IDLE C & A
pots>inject PS E &port.C
pots>inject PS E &port.A
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.15 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.16
pots>subscribe &dn.A cwt
  OK.
pots>/ A(CCW)-B (ANSWERED)
pots>tests begin cwt.16
symbols set test.name cwt.16
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A *7
pots>delay 1
pots>inject PS D &port.A 0
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>inject PS B &port.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A m=&port.silence
pots>verify PS S &port.A s=d m=&port.stutter
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ INITIATE CWT: DENIED BY CCW
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.A
pots>delay 3
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.nack
pots>verify PC F &port.A f &service.cwb &facility.nack
pots>verify PM R &port.A &cause.userbusy
pots>verify PS S &port.C m=&port.busy c=&cause.userbusy
pots>inject PS E &port.A
pots>inject PS E &port.B
pots>inject PS E &port.C
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.16 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.17
pots>subscribe &dn.A cwt
  OK.
pots>tests begin cwt.17
symbols set test.name cwt.17
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ A-B (ALERTING)
pots>inject PS B &port.A
pots>delay 1
pots>inject PS D &port.A &dn.B
pots>delay 2
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>/ INITIATE CWT: DENIED BECAUSE A-B NOT ANSWERED
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.A
pots>delay 3
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.nack
pots>verify PC F &port.A f &service.cwb &facility.nack
pots>verify PM R &port.A &cause.userbusy
pots>verify PS S &port.C m=&port.busy c=&cause.userbusy
pots>inject PS E &port.A
pots>inject PS E &port.C
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.17 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.18
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 2D
pots>read cwt.AdAFls
pots>/ FLASH (FLIP TO ORIGINAL)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A m=&port.B
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.C m=&port.held
pots>verify PS S &port.B m=&port.A
pots>/ 11A
pots>read cwt.AdHExB
pots>/ WAITING CALL HELD: IDLE B
pots>inject PS E &port.B
  OK.
pots>delay 12
  OK.
pots>verify PS R &port.B &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A m=&port.silence c=&cause.normal
pots>tests verify on
  OK.
pots>tests begin cwt.18
symbols set test.name cwt.18
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 12A
pots>read cwt.Hg1ExC
pots>/ HOLDING 1: IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PC F &port.A f &service.disc &facility.req c=&cause.normal
pots>verify PS S &port.A s=x
pots>verify PM S &port.A c=&cause.normal
pots>verify PS S &port.A c=&cause.normal
pots>/ DISC TREATMENT PROGRESSING TO LOCKOUT
pots>delay 74
pots>inject PS E &port.A
pots>delay 1
pots>verify PM S &port.A m=&port.reorder
pots>verify PS S &port.A m=&port.reorder
pots>verify PM S &port.A m=&port.roh
pots>verify PS S &port.A m=&port.roh
pots>verify PM L &port.A
pots>verify PS L &port.A
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.18 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.19
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 1D
pots>read cwt.Nd2ExC
pots>/ NOTIFIED 2; IDLE C
pots>inject PS E &port.C
  OK.
pots>delay 2
  OK.
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A s=x c=&cause.normal
pots>verify PC F &port.A f &service.cwa &facility.cwt.released
pots>tests verify on
  OK.
pots>/ RE-INITIATE CWT IN MUX PASSIVE STATE
pots>tests begin cwt.19
symbols set test.name cwt.19
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.A
pots>delay 3
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
pots>verify PS S &port.A m=&port.B
pots>/ 1D
pots>read cwt.Nd2ExC
pots>/ NOTIFIED 2; IDLE C
pots>inject PS E &port.C
pots>delay 2
pots>verify PS R &port.C &cause.normal
pots>verify PM R &port.A &cause.normal
pots>verify PS S &port.A s=x c=&cause.normal
pots>verify PC F &port.A f &service.cwa &facility.cwt.released
pots>/ 1E
pots>read cwt.Nu1ExA
pots>/ NULL 1: EXIT A
pots>inject PS E &port.A
pots>delay 2
pots>verify PC E &port.A
pots>verify PM R &port.A &cause.normal
pots>verify PS R &port.A &cause.normal
pots>verify PS S &port.B m=&port.silence c=&cause.normal
pots>/ IDLE B
pots>read cwt.Nu0ExB
pots>/ NULL 0: IDLE B
pots>inject PS E &port.B
pots>delay 2
pots>verify PS R &port.B &cause.normal
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.19 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.20
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>/ A-B (ALERTING)
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>/ INITIATE CWT: DENIED BECAUSE A-B NOT ANSWERED
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.nack
pots>verify PC F &port.A f &service.cwb &facility.nack
pots>verify PM R &port.A &cause.userbusy
pots>verify PS S &port.C m=&port.busy c=&cause.userbusy
pots>inject PS E &port.C
  OK.
pots>delay 3
  OK.
pots>tests verify on
  OK.
pots>tests begin cwt.20
symbols set test.name cwt.20
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ RE-INITIATE CWT IN MUX PASSIVE STATE: DENIED AGAIN
pots>inject PS B &port.C
pots>delay 1
pots>inject PS D &port.C &dn.A
pots>delay 3
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.nack
pots>verify PC F &port.A f &service.cwb &facility.nack
pots>verify PM R &port.A &cause.userbusy
pots>verify PS S &port.C m=&port.busy c=&cause.userbusy
pots>inject PS E &port.C
pots>delay 3
pots>inject PS E &port.A
pots>delay 2
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.20 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>read cwt.21
pots>subscribe &dn.A cwt
  OK.
pots>tests verify off
  OK.
pots>read bc.AB
pots>/ A-B: RINGBACK; ANSWER
pots>inject PS B &port.A
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.A &dn.B
  OK.
pots>delay 2
  OK.
pots>inject PS B &port.B
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A s=d m=&port.dial
pots>verify PS S &port.A s=x m=&port.silence
pots>verify PS S &port.B r=t
pots>verify PS S &port.A m=&port.ringback
pots>verify PS S &port.B r=f m=&port.A
pots>verify PS S &port.A m=&port.B
pots>/ 1A 1B
pots>read cwt.In2Ack
pots>/ INITIATE CWT
pots>inject PS B &port.C
  OK.
pots>delay 1
  OK.
pots>inject PS D &port.C &dn.A
  OK.
pots>delay 3
  OK.
pots>verify PS S &port.C s=d m=&port.dial
pots>verify PS S &port.C s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwa &facility.req
pots>verify PM F &port.A f &service.cwm &facility.ack
pots>verify PC F &port.A f &service.cwb &facility.ack
pots>verify PM S &port.A r=t
pots>verify PS S &port.A s=f m=&port.cwt
pots>verify PC A &port.A
pots>verify PS S &port.C m=&port.ringback
pots>/ 1C
pots>read cwt.Nf2Tmr
pots>/ NOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2A
pots>read cwt.Nd2Tmr
pots>/ NOTIFIED: RENOTIFY
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.cwt
pots>/ 2B
pots>read cwt.Rf2Tmr
pots>/ RENOTIFYING 2: STOP CWT TONE
pots>delay 6
  OK.
pots>verify PS S &port.A m=&port.B
pots>/ 2C
pots>read cwt.Rd2Fls
pots>/ RENOTIFIED 2: FLASH (ANSWER)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PC B &port.A m=&port.A
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PS S &port.A m=&port.silence
pots>verify PM S &port.A r=f m=&port.C
pots>verify PS S &port.A m=&port.C
pots>verify PS S &port.C m=&port.A
pots>verify PS S &port.B m=&port.held
pots>/ 2D
pots>read cwt.AdAFls
pots>/ FLASH (FLIP TO ORIGINAL)
pots>inject PS L &port.A
  OK.
pots>delay 2
  OK.
pots>verify PS S &port.A m=&port.B
pots>verify PC P &port.A &prog.media m=&port.held
pots>verify PC P &port.A &prog.media m=&port.A
pots>verify PS S &port.C m=&port.held
pots>verify PS S &port.B m=&port.A
pots>tests verify on
  OK.
pots>tests begin cwt.21
symbols set test.name cwt.21
  OK.
read test.cp.prolog
pots>send &test.name
  OK.
pots>start
pots>/ INITIATE CWT: DENIED BECAUSE CWT ALREADY ACTIVE
pots>inject PS B &port.D
pots>delay 1
pots>inject PS D &port.D &dn.A
pots>delay 3
pots>verify PS S &port.D s=d m=&port.dial
pots>verify PS S &port.D s=x m=&port.silence
pots>verify PM F &port.A f &service.cwm &facility.req
pots>verify PC F &port.A f &service.cwb &facility.nack
pots>verify PM R &port.A &cause.userbusy
pots>verify PS S &port.D m=&port.busy c=&cause.userbusy
pots>inject PS E &port.D
pots>delay 3
pots>inject PS E &port.A
pots>inject PS E &port.B
pots>inject PS E &port.C
pots>delay 3
pots>tests end
read test.cp.epilog
pots>stop
pots>contexts c
pots>if &cli.result != 0 tests failed &cli.result "Context(s) not idled"
pots>save funcs &test.name
pots>save trace &test.name
pots>save msc &test.name
pots>clear buffer
pots>send cout
pots>echo Test &test.name completed.
Test cwt.21 completed.
pots>unsubscribe &dn.A cwt
  OK.
pots>