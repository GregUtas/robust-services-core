LINE COUNTS
   81313   source code not in one of the categories below
   42248   blank line
   18854   blank comment
   10714   comment at the top of a file (e.g. for the file's name or license info)
    8190   comment followed by a repeated character to draw a rule (e.g. //---- ...)
   21781   comment not in one of the categories above (e.g. //  <text>)
   16584   bare left brace
   15012   bare right brace
    1573   bare right brace with semicolon
    1776   access control
    5156   invocation of Debug::ft
     667   definition of an fn_name
    6486   #include directive
    1179   preprocessor directive other than #include
     958   using statement
  232491   TOTAL

WARNING COUNTS (* if supported by >fix)
  W004   136  C-style cast
  W005    56  Functional cast
  W006   120  reinterpret_cast
  W007   653  Cast down the inheritance hierarchy
  W008    47  Cast removes const qualification
  W009    15  Pointer arithmetic
* W015     3  #include not sorted in standard order
* W020   170  Using statement in header
* W022   201  Add using statement
* W023     1  Remove using statement
  W026    66  Unused argument
  W027     7  Unused class
* W028    40  Unused data
* W029     1  Unused enum
* W030    20  Unused enumerator
* W032   131  Unused function
* W033     1  Unused typedef
  W037    15  Member hides inherited name
  W038     1  Class could be namespace
* W042   158  Member could be private
* W043    73  Member could be protected
  W044     8  Typedef of pointer type
* W047     2  Data is init-only
* W048     3  Data is write-only
  W050    26  Data is not private
* W053    58  Data could be const
* W054     1  Data could be const pointer
* W055     1  Data need not be mutable
  W056     5  Implicit constructor invoked: POD members not initialized
* W060    58  Base class constructor is public
* W065    10  Base class virtual destructor is not public
  W075   402  Virtual function is public
* W077    58  Virtual function has no overrides
  W082   116  Adjacent arguments have the same type
* W088    15  Argument could be const
* W090   101  Function could be const
* W092   122  Function could be free
* W099   293  Line contains adjacent spaces
  W102     3  Line length exceeds the standard maximum
* W106   650  Function does not invoke Debug::ft
  W107    16  Function does not invoke Debug::ft as first statement
  W110    38  Override of Base.Display not found
* W111    10  Override of Object.Patch not found
* W117    37  Line can merge with the next line and be under the length limit
  W119    92  Argument passed by value is modified
  W120     5  Function returns non-const reference or pointer to member data
  W121     2  Static member function has indirect argument for its class
  W125     1  Non-const cast is not a downcast
* W127    16  Data could be free
* W130     8  Redundant scope
  W131     2  C-style preprocessor directive
  W141     3  Function could be moved to a subclass
====================================================================================================================================
WARNINGS SORTED BY TYPE/FILE/LINE (i = informational)
W004 C-style cast
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(493):    Singleton< TrafficCallPool >::Extant()->Enq((TrafficCall*) addr);
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(1053):    timewheel_ = (Q1Way< TrafficCall >*) Memory::Alloc(size, MemDynamic);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(606):    LibrarySet* nbSet = (LibrarySet*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(634):    LibrarySet* nsSet = (LibrarySet*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(529):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(894):    CxxScope* GetTemplateInstance() const override { return (CxxScope*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1247):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1455):    CxxToken* RootType() const override { return (CxxToken*) Referent(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4638):    if(tmplt_ != nullptr) return (CxxScope*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(392):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1875):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2105):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2908):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3002):    return (CxxScoped*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3015):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(206):    CxxScoped* Referent() const override { return (CxxScoped*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(605):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1532):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1629):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(375):    CodeFile* itemFile = (CodeFile*) UINTPTR_MAX;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(43):    return (void*) ((const_ptr_t) ptr2 - diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(43):    return (void*) ((const_ptr_t) ptr2 - diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(50):    return (void*) ((const_ptr_t) ptr1 + diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(50):    return (void*) ((const_ptr_t) ptr1 + diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(108):    return ((const_ptr_t) ptr1 - (const_ptr_t) ptr2);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(108):    return ((const_ptr_t) ptr1 - (const_ptr_t) ptr2);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.cpp(227):    return (Object*) addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliPtrParm.cpp(91):          p = (void*) n;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.cpp(161):       auto base = (const Base*) obj;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(314):    auto after = (ptr_t) next_ + size;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(327):       if(wrap && (after > (const_ptr_t) first)) return nullptr;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(334):       if(wrap || (after > (const_ptr_t) first)) return nullptr;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(508):       used = (const_ptr_t) next_ - (const_ptr_t) first;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(508):       used = (const_ptr_t) next_ - (const_ptr_t) first;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(510):       used = size_ - ((const_ptr_t) first - (const_ptr_t) next_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(510):       used = size_ - ((const_ptr_t) first - (const_ptr_t) next_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(332):       auto child = (HeapBlock*) (uintptr_t(block) + LevelToSize(level + 1));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(377):    auto block = (const HeapBlock*) addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(485):    heap_ = (HeapPriv*) SysMemory::Alloc(nullptr, size_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(525):    heap_->state = (uint8_t*) (heapAddr + infoSize);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(557):          ReleaseBlock((HeapBlock*) addr, level);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(568):       ReserveBlock((HeapBlock*) addr);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(677):                   if(block < (HeapBlock*) heap_)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(679):                   else if(block < (HeapBlock*) heap_->minAddr)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(748):    FreeBlock((HeapBlock*) addr, level);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(796):    return (HeapBlock*) (heap_->leftAddr + (offset << Log2Size(level)));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(883):       auto size = BlockToSize((const HeapBlock*) addr);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(886):       auto index = BlockToIndex((const HeapBlock*) addr, level);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(938):       if((HeapBlock*) block->link.prev->next != block)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(940):       if((HeapBlock*) block->link.next->prev != block)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(87):    return (ObjectBlock*) getptr1(obj, BlockHeaderSize);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(311):       blocks_[currSegments_] = (uword*) Memory::Alloc(size, mem_, std::nothrow);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(335):          auto b = (ObjectBlock*) &seg[j];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(385):             auto b = (ObjectBlock*) &seg[j];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(421):             auto curr = (Pooled*) getptr1(item, diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(857):       return (ObjectBlock*) &blocks_[0][0];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(925):       return (ObjectBlock*) &blocks_[i][j];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(950):             auto b = (ObjectBlock*) &seg[j];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(981):    auto block = (const_ptr_t) ObjToBlock(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(982):    auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(986):       auto b0 = (const_ptr_t) &blocks_[i][0];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(1049):          auto b = (ObjectBlock*) &seg[j];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Pooled.cpp(136):    auto obj = (Pooled*) addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(143):       auto ante = (Q1Link*)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(166):       return (T*) getptr1(item, diff_);  // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(212):       return (T*) getptr1(item, diff_);     // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(233):          item = (Q1Link*)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(247):       elem = (T*) getptr1(item, diff_);     // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(260):       return (T*) getptr1(item, diff_);       // location of next item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(332):          tail_.next = (Q1Link*) BAD_POINTER;  // corrupt queue header
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(340):       auto item = (Q1Link*)                   // start at the current item
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(342):       item->next = (Q1Link*) BAD_POINTER;     // corrupt ELEM's next pointer
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(360):       return (Q1Link*) getptr2(&elem, diff_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(145):       return (T*) getptr1(item, diff_);    // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(174):       return (T*) getptr1(item, diff_);     // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(191):          item = (Q2Link*)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(197):          elem = (T*) getptr1(item, diff_);  // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(208):       return (T*) getptr1(item, diff_);       // location of next item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(218):       return (T*) getptr1(item, diff_);     // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(235):          item = (Q2Link*)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(241):          elem = (T*) getptr1(item, diff_);  // location of item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(252):       return (T*) getptr1(item, diff_);       // location of next item's vptr
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(336):       return (Q2Link*) getptr2(&elem, diff_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(116):       registry_ = (T**) Memory::Alloc(size, mem);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(506):                auto cell = (RegCell*) getptr2(item, diff_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(564):       return (RegCell*) getptr2(&item, diff_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(579):       auto table = (T**) Memory::Alloc(size, mem_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Singleton.h(85):       reg->BindInstance((const Base**) &Instance_, type);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Singleton.h(104):       reg->UnbindInstance((const Base**) &Instance_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(185):       (nullptr, size, EnterThread, (void*) client, 0, &id);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(193):    SetThreadPriorityBoost((HANDLE) nthread_, true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(205):       CloseHandle((HANDLE) nthread_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(239):    if(!SetThreadPriority((HANDLE) nthread_, PriorityMap[prio]))
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(274):    _set_se_translator((_se_translator_function) SE_Handler);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(165):    Symbols = (SYMBOL_INFO*) Memory::Alloc(size, MemPermanent, std::nothrow);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(217):    buff_ = (TraceRecord**)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(221):    funcs_ = (FunctionTrace*)
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.cpp(93):    functionq_ = (Q2Way< FunctionStats >*) Memory::Alloc(size, MemTemporary);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.cpp(78):    buffer_ = (byte_t*) Memory::Alloc(SysSocket::MaxMsgSize, MemDynamic);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp(158):    bytes_ = (byte_t*) newbytes;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.win.cpp(66):                auto netaddr = (sockaddr_in*) curr->ai_addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.win.cpp(74):                auto netaddr = (sockaddr_in6*) curr->ai_addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(65):          auto netaddr = (sockaddr_in*) info->ai_addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(88):          auto netaddr = (sockaddr_in6*) info->ai_addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(138):       HostToNetwork((IPv4Addr&) ipv4addr.sin_addr.s_addr, ipv4addr.sin_port);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(139):       addrinfo = (sockaddr*) &ipv4addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(148):       addrinfo = (sockaddr*) &ipv6addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(109):          (const char*)&dual, sizeof(dual)) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(135):       addr = (sockaddr*) &ipv4addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(145):       addr = (sockaddr*) &ipv6addr;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(276):       (const char*) &rxSize, sizeof(rxSize)) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(283):       (char*) &max, &maxsize) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(295):       (const char*) &txSize, sizeof(txSize)) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(302):       (char*) &max, &maxsize) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(56):       peer = (sockaddr*) &ipv6peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(61):       peer = (sockaddr*) &ipv4peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(111):       peer = (sockaddr*) &ipv6peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(118):          ((IPv4Addr&) ipv4peer.sin_addr.s_addr, ipv4peer.sin_port);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(119):       peer = (sockaddr*) &ipv4peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(200):       self = (sockaddr*) &ipv6self;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(205):       self = (sockaddr*) &ipv4self;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(338):       peer = (sockaddr*) &ipv6peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(343):       peer = (sockaddr*) &ipv4peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(409):       (char*) &linger_opts, sizeof(linger)) != SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(435):       (const char*) &alive, sizeof(alive)) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(445):       (char*) &val, &valsize) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(58):          (char*) &max, &maxsize) == SOCKET_ERROR)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(99):       peer = (sockaddr*) &ipv6peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(104):       peer = (sockaddr*) &ipv4peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(185):       peer = (sockaddr*) &ipv6peer;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(192):          ((IPv4Addr&) ipv4peer.sin_addr.s_addr, ipv4peer.sin_port);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(193):       peer = (sockaddr*) &ipv4peer;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(697):    ((ProtocolSM*) p)->Kill();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(166):    auto pptr = (TlvParm*) (layout->bytes + layout->header.length);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(250):    return (Fence*) fence;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(395):    pit.pptr = (TlvParm*) &pit.mptr->bytes[nextIndex];
W005 Functional cast
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(508):    if(route->identifier != RouteResult::Id(rid)) return ParmValueMismatch;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\DigitString.cpp(137):       auto rc = AddDigit(Digit(ds.digits_[i]));
  C:\Users\Greg\Documents\rsc\rsc\src\cb\DigitString.cpp(148):    if(i < Size()) return Digit(digits_[i]);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(225):          << spaces(3) << LineType(t) << CRLF;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(236):          *stream << (Attrs_.at(Warning(w)).fixable_ ? '*' : SPACE);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(237):          *stream << setw(5) << WarningCode(Warning(w)) << setw(6)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(238):             << WarningCounts_[w] << spaces(2) << Warning(w) << CRLF;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(297):          *stream << (Attrs_.at(Warning(w)).fixable_ ? '*' : SPACE);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CtIncrement.cpp(1321):       Context::EraseTracepoint(file, line - 1, Tracepoint::Action(mode));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CtIncrement.cpp(1336):    Context::InsertTracepoint(file, line - 1, Tracepoint::Action(mode));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(575):       if(Attrs[i].symbol.compare(sym) == 0) return Cxx::Operator(i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(623):          oper = Cxx::Operator(i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(672):       Attrs[ValidIntDigits[i]].intValue = int8_t(i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(678):       Attrs[ValidHexDigits[i]].hexValue = int8_t(h);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(683):       Attrs[ValidOctDigits[i]].octValue = int8_t(i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1769):             return TypeMatch(match - 1);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2199):    if(item_->GetTypeSpec()->Tags()->PtrCount(false) >= TagCount(ptrs))
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4365):    if(TagCount(n) >= ptrs_) return false;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4383):    if(TagCount(n) >= ptrs_) return false;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4454):       if(TagCount(n) >= ptrs_) ptrs_ = n + 1;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1107):       if(int(begin) < info->depth) begin = info->depth;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2150):    *Cli_->obuf << ": " << Warning(log.warning_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(147):          type = LibTokenType(i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2305):          fp *= std::pow(10.0, int(num));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2412):          oper = Cxx::Operator(match->second);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.h(73):    Id Tid() const { return Id(tid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(312):       heaps.push_back(AccessHeap(MemoryType(m)));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(783):    return BlockState(state);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(594):       rc = nbt->SelectFaction(Faction(id), TraceDefault);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(975):       rc = nbt->SelectFaction(Faction(id), TraceExcluded);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1162):          auto type = MemoryType(memtype);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1193):          auto type = MemoryType(m);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1204):          *cli.obuf << setw(13) << MemoryType(m) << ": " << status << CRLF;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1214):          auto type = MemoryType(memtype);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1227):          auto type = MemoryType(memtype);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1593):       rc = nbt->SelectFaction(Faction(id), TraceIncluded);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(3200):       auto heap = Memory::AccessHeap(MemoryType(m));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTracer.cpp(228):             stream << Faction(f) << CRLF;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(97):    ObjectPoolId Pid() const { return ObjectPoolId(pid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(594):    stream << indent << "buffsize : " << int(std::log2(size_));
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(3481):    auto test = RecoveryThread::Test(index);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.cpp(64):    byte = uint8_t(value);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.cpp(101):    quartet = uint16_t(value);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.cpp(64):    port = ipport_t(value);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(72):    Id Fid() const { return Id(fid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(91):    Id Fid() const { return Id(fid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(72):       { return NodeBase::Faction(faction_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPoolRegistry.cpp(87):       auto p = reg->Pool(Faction(id));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(85):    Id Pid() const { return Id(pid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(655):       auto pool = reg->Pool(Faction(sc));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(102):    width -= col_t(label.size());
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(192):          stream << strClass(reg->GetService(ServiceId(cid_)), false);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(197):          stream << strClass(reg->GetFactory(FactoryId(cid_)), false);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(65):    Id Sid() const { return Id(sid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Signal.h(81):    Id Sid() const { return Id(sid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.h(60):    Id Stid() const { return Id(stid_.GetId()); }
W006 reinterpret_cast
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(68):    auto pptr = reinterpret_cast< TlvParm* >(sbuff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(69):    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(483):    auto fake = reinterpret_cast< const TrafficCall* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.cpp(90):    reinterpret_cast< const DigitString* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.cpp(112):    reinterpret_cast< const CauseInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.cpp(98):    reinterpret_cast< const ProgressInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(451):    reinterpret_cast< const RouteResult* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(214):    auto em = reinterpret_cast< EM_Message* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(513):    auto& dm = reinterpret_cast< const DM_Message& >(message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(514):    auto tokens = reinterpret_cast< const Token* >(&dm.tokens);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(640):    auto& em = reinterpret_cast< const EM_Message& >(message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(1293):       auto& rm = reinterpret_cast< const RM_Message& >(message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(2082):    auto bm = reinterpret_cast< DipMessage* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(2154):    auto im = reinterpret_cast< IM_Message* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(2295):    auto dm = reinterpret_cast< DM_Message* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(2299):    message.get_tokens(reinterpret_cast< Token* >(&dm->tokens), count);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.cpp(187):    auto msg = reinterpret_cast< BM_Message* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.cpp(216):    auto message = reinterpret_cast< const DipMessage* >(ipb->HeaderPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.cpp(100):       auto message = reinterpret_cast< const DipMessage* >(buff_->HeaderPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.cpp(129):    return reinterpret_cast< DipHeader* >(buff_->HeaderPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(62):       reinterpret_cast< const IM_Message* >(this)->Display(stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(65):       reinterpret_cast< const RM_Message* >(this)->Display(stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(68):       reinterpret_cast< const DM_Message* >(this)->Display(stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(71):       reinterpret_cast< const FM_Message* >(this)->Display(stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(74):       reinterpret_cast< const EM_Message* >(this)->Display(stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(77):       reinterpret_cast< const BM_Message* >(this)->Display(stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(198):       auto header = reinterpret_cast< const DipHeader* >(source);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(208):       auto header = reinterpret_cast< const DipHeader* >(payload);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(227):    auto msg = reinterpret_cast< DipHeader* >(buff.PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(233):       auto im = reinterpret_cast< IM_Message* >(src);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(241):       auto dm = reinterpret_cast< DM_Message* >(src);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(252):       auto em = reinterpret_cast< EM_Message* >(src);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(279):    auto msg = reinterpret_cast< DipHeader* >(buff.PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(288):       auto rm = reinterpret_cast< RM_Message* >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(299):       auto dm = reinterpret_cast< DM_Message* >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(310):       auto em = reinterpret_cast< EM_Message* >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(331):    auto header = reinterpret_cast< const DipHeader* >(payload);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(356):    auto msg = reinterpret_cast< BM_Message* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.cpp(58):    auto fake = reinterpret_cast< const Circuit* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.cpp(97):    reinterpret_cast< const MediaInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.cpp(529):       auto cxi = reinterpret_cast< MediaInfo* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.cpp(61):    auto fake = reinterpret_cast< const Tone* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.cpp(118):    auto fake = reinterpret_cast< const Alarm* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp(95):    auto obj = reinterpret_cast< ObjectStruct* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp(158):    auto obj = reinterpret_cast< const ObjectStruct* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.cpp(135):    auto fake = reinterpret_cast< const CfgParm* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.cpp(90):    auto fake = reinterpret_cast< const CfgTuple* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.cpp(93):    auto fake = reinterpret_cast< const Class* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.cpp(73):    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.cpp(173):    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.cpp(102):    auto fake = reinterpret_cast< const CliIncrement* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.cpp(113):    auto fake = reinterpret_cast< const CliParm* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Daemon.cpp(75):    auto fake = reinterpret_cast< const Daemon* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.cpp(99):    auto fake = reinterpret_cast<const Deferred*>(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.cpp(136):    auto fake = reinterpret_cast< const Log* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(124):    SetNext(reinterpret_cast< Entry* >(buff_));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(341):       where = reinterpret_cast< Entry* >(buff_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(349):    SetNext(reinterpret_cast< Entry* >(after));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(386):          SetNext(reinterpret_cast< Entry* >(buff_));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.cpp(123):    auto fake = reinterpret_cast< const LogGroup* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Module.cpp(65):    auto fake = reinterpret_cast< const Module* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.cpp(114):    auto obj = reinterpret_cast< ObjectStruct* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(557):    auto fake = reinterpret_cast< const ObjectPool* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Pooled.cpp(114):    auto fake = reinterpret_cast< const Pooled* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(71):    auto fake = reinterpret_cast< const PosixSignal* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.cpp(89):    auto fake = reinterpret_cast< const Statistic* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.cpp(87):    auto fake = reinterpret_cast< const StatisticsGroup* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Symbol.cpp(96):    auto fake = reinterpret_cast< const Symbol* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMutex.cpp(105):    auto fake = reinterpret_cast<const SysMutex*>(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.cpp(40):    auto bytes = reinterpret_cast< uint8_t* >(&value);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1264):    auto p = reinterpret_cast< char* >(BAD_POINTER);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Tool.cpp(67):    auto fake = reinterpret_cast< const Tool* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.cpp(77):    auto fake = reinterpret_cast< const FunctionStats* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1499):    auto fake = reinterpret_cast< const Q1WayItem* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1993):    auto fake = reinterpret_cast< const Q2WayItem* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(2504):    auto fake = reinterpret_cast< const RegistryItem* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(307):    auto fake = reinterpret_cast< const IpPort* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.cpp(72):    auto fake = reinterpret_cast< const IpService* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.cpp(243):       auto payload = reinterpret_cast< SysIpL3Addr* >(buff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(311):    auto rcvd = recv(Socket(), reinterpret_cast< char* >(buff), size, 0);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(382):    auto sent = send(Socket(), reinterpret_cast< const char* >(data), size, 0);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(109):       reinterpret_cast< char* >(buff), size, 0, peer, &peersize);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(198):       reinterpret_cast< const char* >(data), size, 0, peer, peersize);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.cpp(84):    auto fake = reinterpret_cast< const PotsFeature* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.cpp(94):    auto fake = reinterpret_cast< const PotsFeatureProfile* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.cpp(84):    auto fake = reinterpret_cast< const PotsProfile* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(453):    reinterpret_cast< const PotsFacilityInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(635):    reinterpret_cast< const PotsHeaderInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(748):    reinterpret_cast< const PotsRingInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(830):    reinterpret_cast< const PotsScanInfo* >(bytes)->Display(stream, prefix);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(576):    auto fake = reinterpret_cast< const Context* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(866):             auto toi = reinterpret_cast< TimeoutInfo* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(201):    auto fake = reinterpret_cast< const Factory* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.cpp(217):    auto fake = reinterpret_cast< const Initiator* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(283):    auto fake = reinterpret_cast< const InvokerPool* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.cpp(130):    auto fake = reinterpret_cast< const InvokerThread* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.cpp(108):    auto fake = reinterpret_cast< const Parameter* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(88):    auto fake = reinterpret_cast< const Protocol* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbInputHandler.cpp(75):    auto header = reinterpret_cast< const MsgHeader* >(source);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIpBuffer.h(62):       { return reinterpret_cast< MsgHeader* >(HeaderPtr()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.cpp(287):    auto fake = reinterpret_cast< const Service* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Signal.cpp(81):    auto fake = reinterpret_cast< const Signal* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.cpp(197):    auto fake = reinterpret_cast< const State* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Timer.cpp(188):    auto fake = reinterpret_cast< const Timer* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerProtocol.cpp(106):    auto toi = reinterpret_cast< const TimeoutInfo* >(bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(64):    auto encap = reinterpret_cast< const TlvMsgLayout* >(parm.bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(459):    auto encap = reinterpret_cast< TlvMsgLayout* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(79):       return reinterpret_cast< T* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(93):       auto dest = reinterpret_cast< T* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(128):       parm = (pptr == nullptr ? nullptr : reinterpret_cast< T* >(pptr->bytes));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(281):       { return reinterpret_cast< TlvMsgLayout* >(Buffer()->HeaderPtr()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvProtocol.cpp(67):       auto pptr = reinterpret_cast< TlvParm* >(&bytes[index]);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(89):    auto pptr = reinterpret_cast< TlvParm* >(sbuff->PayloadPtr());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(90):    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1381):          auto ring = reinterpret_cast< PotsRingInfo* >(pptr->bytes);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(79):    auto fake = reinterpret_cast< const PotsTreatmentQueue* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(188):    auto fake = reinterpret_cast< const PotsTreatment* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.cpp(85):    auto fake = reinterpret_cast< const MscAddress* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.cpp(91):    auto fake = reinterpret_cast< const MscContext* >(&local);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.cpp(87):    auto fake = reinterpret_cast< const MscContextPair* >(&local);
W007 Cast down the inheritance hierarchy
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(124):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(137):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(157):    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(167):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(66):    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.cpp(107):    auto& tlvmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.cpp(155):    auto& tlvmsg = static_cast< const TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(41):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(43):    auto& bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(65):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(66):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(68):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(120):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(121):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(123):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(161):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(162):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(164):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(191):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(192):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(194):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(464):    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(492):    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(759):       if(m->GetSignal() == sid) return static_cast< CipMessage* >(m);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(789):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(919):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(1257):    auto& tmsg = static_cast< const CipMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(1262):    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp(384):    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp(825):       auto fac = static_cast< BcFactory* >(reg->GetFactory(route_.selector));
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(359):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(360):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(362):    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(391):    auto& ppe = static_cast< ProxyBcProgressEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(400):       auto& pssm = static_cast< ProxyBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(426):    auto& pssm = static_cast< ProxyBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(427):    auto ppsm = static_cast< ProxyBcPsm* >(Context::ContextPsm());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(531):    auto pssm = static_cast< ProxyBcSsm* >(RootSsm());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(672):          return static_cast< ProxyBcPsm* >(p);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(704):          ppsm = static_cast< ProxyBcPsm* >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(909):    auto& tmsg = static_cast< const CipMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(914):    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDir.cpp(69):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDir.cpp(126):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDir.cpp(143):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.cpp(94):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.cpp(121):       auto dir = static_cast< CodeDir* >(*d);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.cpp(130):       auto dir = static_cast< CodeDir* >(*d);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(80):          auto base = static_cast< const Class* >(*b);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(236):       auto base = static_cast< const Class* >(*b);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(266):                auto type = static_cast< const Typedef* >(*item2);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(289):          auto type = static_cast< const Typedef* >(*item1);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1022):       auto f = static_cast< const CodeFile* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1030):       auto f = static_cast< const CodeFile* >(*u);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1422):       auto file = static_cast< const CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1624):          auto file = static_cast< const CodeFile* >(*d);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(2043):       auto file = static_cast< const CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(2207):       const auto& name = static_cast< const CodeFile* >(*f)->Name();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(2389):                auto incl = static_cast< const CodeFile* >(*a);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(2497):          auto file = static_cast< const CodeFile* >(*d);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(2526):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(2557):       auto base = static_cast< const Class* >(*b);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(80):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(193):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(252):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(277):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(308):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(334):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(362):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(405):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(459):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(485):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(511):    auto& dirSet = static_cast< const CodeDirSet* >(that)->Items();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(518):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(558):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(585):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(739):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(767):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(876):       files.push_back(static_cast<CodeFile*>(*f));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(903):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(983):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(1010):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(1040):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(122):       auto item = static_cast< CxxNamed* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(148):       auto item = static_cast< CxxNamed* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(176):       auto item = static_cast< CxxNamed* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(198):       auto item = static_cast< CxxNamed* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(217):       auto item = static_cast< CxxScoped* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(238):       auto item = static_cast< CxxScoped* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(260):       auto item = static_cast< CxxNamed* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(206):       auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1005):       auto name = static_cast<const Friend*>(item_)->ScopedName(true);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1027):       auto data = static_cast< const Data* >(item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1069):       auto func = static_cast< Function* >(item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1149):       auto cls = static_cast< const Class* >(item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1173):       auto cls = static_cast< const Class* >(item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1204):          auto func = static_cast< const Function* >(item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CtIncrement.cpp(1083):          auto dir = static_cast< CodeDir* >(*d);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CtIncrement.cpp(1106):          auto file = static_cast< CodeFile* >(*f);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(108):       auto cls = static_cast< Class* >(call->Via()->Root());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(281):          static_cast< const Function* >(item)->IsInline())
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1241):       return static_cast< ClassInst* >(list.front());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1251):    auto area = static_cast<CxxArea*>(GetScope());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1262):          auto c = static_cast< Class* >(*s);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(2671):       auto func = static_cast< const Function* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(2713):       auto func = static_cast< const Function* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(2722):       return tmplt_->FindFriend(static_cast< const CxxScope* >(ref));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(987):       const { return static_cast< Namespace* >(GetScope()); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(1018):       auto macro = static_cast< Macro* >(ref_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(1031):       auto macro = static_cast< Macro* >(ref_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1723):          auto derived = static_cast< const Class* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1834):       auto thisClass = static_cast< Class* >(thisRoot);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1842):             auto thatClass = static_cast< Class* >(thatRoot);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1999):    if(AutoType_.SetAutoTypeOn(*static_cast< FuncData* >(item_)))
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2053):       auto type = static_cast< TypeSpec* >(item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2063):       spec->SetReferent(static_cast< CxxScoped* >(item_), nullptr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2249):          static_cast< Class* >(root)->BlockCopied(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(100):             static_cast< Function* >(tfunc)->SetTemplateParm();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(474):          space = static_cast< Namespace* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(498):          cls = static_cast< Class* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(552):          item = static_cast< Enum* >(item)->FindEnumerator(name);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(563):          auto tdef = static_cast< Typedef* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(568):          item = static_cast< CxxScoped* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(855):    return static_cast< Class* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1301):    return (static_cast< Class* >(root)->FindCtor(nullptr) == nullptr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2190):    auto cls = (type == Cxx::Class ? static_cast< Class* >(inner) : nullptr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2423):       auto func = static_cast< Function* >(ref);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2852):       TypeSpecPtr spec(static_cast< TypeSpec* >(spec_->Clone()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2857):       ExprPtr expr(static_cast<Expression*>(expr_->Clone()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3352):          TemplateArgPtr arg(static_cast< TemplateArg* >((*a)->Clone()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3657):          auto e = static_cast<const Enum*>(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(89):             auto farg = static_cast< Function* >(a->item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(904):       auto cls = static_cast<const Class*>(scope);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1693):          auto op = static_cast< Operation* >(expr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1834):    auto item = static_cast< Data* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1848):    auto item = static_cast< Data* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1889):    auto item = static_cast< Data* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1904):    auto item = static_cast< Data* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1988):          static_cast< Block* >(GetScope())->EraseItem(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2004):          static_cast< Block* >(GetScope())->ReplaceItem(this, next_.release());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(3667):    else if(!static_cast< Function* >(item)->virtual_)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4435):       func = static_cast< Function* >(inst->FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4448):       auto i = FindArg(static_cast< const Argument* >(item), false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4495):    return static_cast< Function* >((*cti)->FindInstanceAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5201):    auto that = static_cast< const Argument* >(FindTemplateAnalog(arg));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5656):    auto func = static_cast< Function* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5668):    auto func = static_cast< Function* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5887):                auto item = static_cast< CxxNamed* >(args.front().item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(6076):       auto func = static_cast< Function* >(cls->FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(93):          auto func = static_cast< Function* >(GetScope());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(201):       auto& fname = static_cast< Function* >(GetScope())->Name();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(217):    auto cls = static_cast< Class* >(ref);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(241):    auto func = static_cast< Function* >(GetScope());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(305):       auto item = static_cast< Argument* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(344):    auto item = static_cast< Argument* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(356):    auto item = static_cast< Argument* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(392):    GetClass()->EraseSubclass(static_cast< Class* >(GetScope()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(422):    GetClass()->AddSubclass(static_cast< Class* >(Context::Scope()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(456):    return static_cast< Class* >(name_->GetReferent());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1177):          ref = static_cast< const Function* >(ref)->FindRootFunc();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1529):    auto item = static_cast< Enum* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1799):    auto item = static_cast< Enumerator* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1835):    auto item = static_cast< Enumerator* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2030):    auto item = static_cast< Forward* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2152):    static_cast< Class* >(grantor_)->EraseFriend(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2251):          space = static_cast< Namespace* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2264):          cls = static_cast< Class* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2303):          auto tdef = static_cast< Typedef* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2308):          item = static_cast< CxxScoped* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2496):    auto item = static_cast< Friend* >(grantor_->FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2641):       static_cast< CxxArea* >(scope)->AddFunc(func);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2763):    auto func = static_cast< Function* >(GetScope());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2847):    ref_ = static_cast< ClassData* >(cls->FindData(name_));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3577):    auto item = static_cast< Typedef* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3768):          auto item = static_cast< Using* >(FindTemplateAnalog(this));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.cpp(371):    static_cast< Block* >(GetScope())->EraseItem(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.cpp(1153):             static_cast< Class* >(result.item_)->InvokeCopyCtor();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(543):    return static_cast< Macro* >(macros.front());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(580):       if((*s)->ScopedName(false) == name) return static_cast< CxxScope* >(*s);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(588):       if((*c)->ScopedName(false) == name) return static_cast< CxxScope* >(*c);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(596):       if(pos != string::npos) return static_cast< CxxScope* >(*s);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(602):       if(pos != string::npos) return static_cast< CxxScope* >(*c);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(949):    auto oper = static_cast< Operation* >(item.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(975):          auto ante = static_cast< Operation* >(prev.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1034):       auto oper = static_cast< Operation* >(item.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1067):    auto oper = static_cast< Operation* >(prev.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1094):    auto oper = static_cast< Operation* >(item.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1152):    auto oper = static_cast< Operation* >(item.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1175):       auto ante = static_cast< Operation* >(prev.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1336):    Context::PushOp(static_cast< Operation* >(StartOfExpr.get()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1884):       inClass = static_cast< Class* >(inRoot);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1889):       outClass = static_cast< Class* >(outRoot);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1930):    auto call = static_cast< Operation* >(args_.front().get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2325):       func = static_cast< Function* >(proc.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2339):       cls = static_cast< Class* >(proc.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2440):    auto cls = static_cast< Class* >(arg.item_->Root());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2478):       auto newCall = static_cast< Operation* >(args_.front().get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2499):    auto cls = static_cast< Class* >(spec.item_->Root());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2520):       auto ctorCall = static_cast< Operation* >(args_[2].get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2544):       cls = static_cast< Class* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2746):       area = static_cast< Class* >(targ);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(3116):    auto cls = static_cast< Class* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(3183):          mem = static_cast< Function* >(mem)->InstantiateFunction(tmplt);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(266):       auto func = static_cast< const Function* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(735):    return static_cast< Namespace* >(scope);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(807):    auto defn = static_cast< Data* >(data->GetMate());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(900):    auto defn = static_cast< Function* >(func->GetMate());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(928):    auto func = static_cast< const Function* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1166):    auto oper = static_cast< const Operation* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1447):    static_cast< Class* >(log.item_)->SetClassTag(Cxx::StructType);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1496):          static_cast< Forward* >(*f)->SetClassTag(to);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1538):    auto decl = static_cast< CxxScope* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1700):    auto item = static_cast< CxxScope* >(ParseFileItem(pos, space));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1713):          auto tname = static_cast< const TypeName* >(*r);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1727):       UpdateDebugFt(static_cast< Function* >(item));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1763):    auto func = static_cast< const Function* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1833):    static_cast< Class* >(log.item_)->SetClassTag(Cxx::ClassType);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2092):    auto decl = static_cast< Function* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2477):    static_cast< Function* >(log.item_)->SetExplicit(false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2573):    static_cast< ClassData* >(log.item_)->SetMutable(false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2609):    static_cast< Function* >(log.item_)->SetOverride(false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2630):    auto qname = static_cast< const QualName* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2694):    static_cast< Function* >(log.item_)->SetVirtual(false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2764):       usages.directs.erase(static_cast< CxxNamed* >(*i));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2765):       usages.indirects.erase(static_cast< CxxNamed* >(*i));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2837):          auto data = static_cast< const Data* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2851):             auto func = static_cast< const Function* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(2865):             auto data = static_cast< const Data* >(*i);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(3015):    return FindSigEnd(static_cast< const Function* >(log.item_));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(3329):    auto data = static_cast< Data* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(3396):    auto func = static_cast< Function* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(3487):    auto data = static_cast< const Data* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4067):    auto data = static_cast< Data* >(aref);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4074):    ReplaceImpl(static_cast< Function* >(log.item_));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4225):    auto func = static_cast< Function* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4576):    auto cls = static_cast< Class* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4877):    auto cls = static_cast< Class* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5318):       ns = static_cast< Namespace* >(ref)->OuterSpace();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5394):    auto func = static_cast< const Function* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5475):    auto func = static_cast<const Function*>(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5485):       auto slit = static_cast< StrLiteral* >(arg);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5499):    auto data = static_cast< SpaceData* >(arg->Referent());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5506):    auto slit = static_cast< StrLiteral* >(file_->PosToItem(lpos));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5533):    static_cast< Ifndef* >(log.item_)->ChangeName(guard);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5598):    auto type = static_cast< TypeName* >(log.item_);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(6165):    static_cast< Function* >(log.item_)->SetExplicit(true);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(6214):    static_cast< Function* >(log.item_)->SetOverride(true);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(6318):    static_cast< Function* >(log.item_)->SetVirtual(true);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(6606):       auto items = GetItemsForDefn(static_cast< const CxxScope* >(next));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3194):          auto def = static_cast< Define* >(item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.cpp(668):             auto f = static_cast< const Function* >(elem);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(455):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(491):    auto op = static_cast< Operation* >(call.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(793):    auto brace = static_cast<BraceInit*>(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(860):    auto cast = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(897):    auto c = static_cast< Catch* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1026):    static_cast< ClassData* >(data.get())->SetMutable(mute);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1027):    static_cast< ClassData* >(data.get())->SetWidth(width);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1185):    auto cond = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1458):    auto cast = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1619):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1643):    auto delOp = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1669):    auto d = static_cast< Do* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1867):    auto f = static_cast< For* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1969):       static_cast< FuncData* >(data.get())->SetExpression(expr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1988):          typeSpec.reset(static_cast< TypeSpec* >(prev->GetTypeSpec()->Clone()));
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2021):          curr = static_cast< FuncData* >(data.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2298):             static_cast< If* >(first)->SetElseIf();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2304):    auto i = static_cast< If* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2466):    auto inner = static_cast< Namespace* >(outer)->EnsureNamespace(name);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2508):    auto newOp = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2527):    static_cast< Operation* >(token.get())->SetNew();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2579):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2993):    static_cast< Return* >(statement.get())->AddExpr(expr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3038):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3279):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3303):    auto s = static_cast< Switch* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3417):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3449):    auto t = static_cast< Try* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3507):    auto op = static_cast< Operation* >(token.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(3797):    auto w = static_cast< While* >(statement.get());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(4156):          auto op = static_cast< Operation* >(token)->Op();
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.cpp(203):    DipIpBufferPtr ipb(static_cast< DipIpBuffer* >(msg));
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(274):    auto dipbuff = static_cast< DipIpBuffer* >(&buff);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(327):    DipIpBufferPtr dipbuff(static_cast< DipIpBuffer* >(buff.release()));
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.cpp(228):    if(root->Sid() != TestServiceId) return static_cast< MediaSsm* >(root);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.cpp(86):       auto mpsm = static_cast< MediaPsm* >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.cpp(108):       auto mpsm = static_cast< MediaPsm* >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.cpp(73):    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.cpp(173):    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CoutThread.cpp(87):       auto req = static_cast< StreamRequest* >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.cpp(212):       auto req = static_cast< FileRequest* >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(569):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(583):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(602):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(630):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(677):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(796):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(818):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(836):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(909):       auto curr = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogThread.cpp(86):       (static_cast< CfgIntParm* >(reg->FindParm("NoSpoolingMessageCount")));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MemoryTrace.cpp(88):       auto curr = static_cast< MemoryTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(448):          auto ft = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(479):          auto ft = static_cast< FunctionTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.cpp(203):             auto ft = static_cast<FunctionTrace*>(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtTestData.cpp(62):    return static_cast< NtTestData* >(data);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.cpp(261):       (this, static_cast< const TcpIpService* >(service), port);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.cpp(272):    auto daemon = static_cast< TcpIoDaemon* >(reg->FindDaemon(name.c_str()));
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.cpp(321):       (this, static_cast<const UdpIpService*>(service), port);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.cpp(332):    auto daemon = static_cast< UdpIoDaemon* >(reg->FindDaemon(name.c_str()));
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(432):    bool alive = static_cast< const TcpIpService* >(service)->Keepalive();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.cpp(215):    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.cpp(225):    auto svc = static_cast< const TcpIpService* >(ipPort_->GetService());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.cpp(310):    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.cpp(472):    auto sock = static_cast< SysTcpSocket* >(socket);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpPort.cpp(61):    auto thread = static_cast< TcpIoThread* >(GetThread());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpPort.cpp(67):       thread = static_cast< TcpIoThread* >(CreateThread());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpPort.cpp(73):    auto svc = static_cast< const TcpIpService* >(GetService());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpPort.cpp(93):    auto svc = static_cast< const TcpIpService* >(GetService());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.cpp(96):    auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.cpp(100):       auto svc = static_cast< const UdpIpService* >(ipPort_->GetService());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.cpp(201):       auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIpPort.cpp(53):    auto svc = static_cast< const UdpIpService* >(GetService());
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsIncrement.cpp(398):       auto mep = static_cast< MediaEndpt* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(466):    auto&            pmsg = static_cast< PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(523):    auto&             pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(647):    auto&          pmsg = static_cast< PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(671):    auto&           pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(759):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(841):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(756):                inv = static_cast< InvokerThread* >(Thread::RunningThread());
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(861):          auto pptr = static_cast< TlvMessage* >
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(240):    invokersCfg_.reset(static_cast< CfgIntParm* >(reg->FindParm(parmKey)));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(567):       auto inv = static_cast< InvokerThread* >(Thread::RunningThread());
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgContext.cpp(75):    static_cast< MsgFactory* >(fac)->ProcessIcMsg(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.cpp(74):    locAddr_.sbAddr_.fid = static_cast< ProtocolSM& >(upper).GetFactory();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.cpp(146):    return static_cast< PsmFactory* >(fac)->AllocIcPsm(msg, *this);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.cpp(204):    auto port = static_cast< MsgPort* >(pool->BidToObj(locAddr.bid));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.cpp(259):       static_cast< PsmFactory* >(fac)->PortAllocated(*this, msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.cpp(404):       auto psm = static_cast< ProtocolSM* >(layer);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\RootServiceSM.cpp(47):    ctx_ = static_cast< SsmContext* >(Context::RunningContext());
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbDaemons.cpp(119):    auto daemon = static_cast< InvokerDaemon* >(reg->FindDaemon(name.c_str()));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbHandlers.cpp(50):    auto pid = ssm.CalcPort(static_cast< const AnalyzeMsgEvent& >(currEvent));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbHandlers.cpp(120):    auto& fte = static_cast< ForceTransitionEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbHandlers.cpp(134):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(762):       auto msg = static_cast< Message* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(847):       auto port = static_cast< MsgPort* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(1053):       auto psm = static_cast< ProtocolSM* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(1277):       auto ssm = static_cast< ServiceSM* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp(1484):       auto tmr = static_cast< Timer* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbInputHandler.cpp(103):    SbIpBufferPtr sbbuff(static_cast< SbIpBuffer* >(buff.release()));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbInvokerPools.cpp(62):       (static_cast< CfgIntParm* >(reg->FindParm("NoIngressQueueLength")));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbInvokerPools.cpp(73):       (static_cast< CfgIntParm* >(reg->FindParm("NoIngressMessageCount")));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.cpp(204):       auto port = static_cast< MsgPort* >(obj);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.cpp(261):    auto psm = static_cast< ProtocolSM* >(NextUsed(PsmToAudit_));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.cpp(278):       psm = static_cast< ProtocolSM* >(NextUsed(PsmToAudit_));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(402):          bt = static_cast< BuffTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(855):       curr_ = static_cast< const AnalyzeSapEvent& >(sxp).CurrEvent()->Eid();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(858):       curr_ = static_cast< const AnalyzeSnpEvent& >(sxp).CurrEvent()->Eid();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(885):    mod_((static_cast< const InitiationReqEvent& >(sip)).GetModifier())
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(447):             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(451):          modifierSsm = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrSsm();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(452):          currEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(503):             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(509):          currEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(510):          modifierInit = static_cast< AnalyzeSapEvent* >
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(763):             else if(static_cast< AnalyzeSapEvent* >(nextEvent)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(766):             else if(static_cast< AnalyzeSapEvent* >(nextEvent)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(864):          initEvent = static_cast< InitiationReqEvent* >(nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(868):             initEvent->SetSapEvent(static_cast< AnalyzeSapEvent& >(sapEvent));
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(930):             auto sibling = static_cast< InitiationReqEvent* >
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(971):    auto& initEvent = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmContext.cpp(81):    return static_cast< SsmFactory* >(fac)->AllocRoot(msg, psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvIntParameter.h(69):       auto& tlvmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvIntParameter.h(101):       auto& tlvmsg = static_cast< const TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvParameter.cpp(67):    auto& tmsg = static_cast< const TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(58):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(61):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(96):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(109):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(111):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(128):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(140):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(141):    auto& ode = static_cast< BcOriginationDeniedEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(156):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(158):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(164):       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(185):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(210):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(237):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(251):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(272):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(284):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(296):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(308):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(320):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(322):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(339):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(358):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(370):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(383):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(397):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(398):    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(412):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(424):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(426):    auto cmsg = static_cast< CipMessage* >(npsm->FirstRcvdMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(453):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(465):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(466):    auto& tde = static_cast< BcTerminationDeniedEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(478):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(479):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(497):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(514):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(526):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(528):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(551):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(577):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(589):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(602):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(615):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(617):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(635):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(647):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(663):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(665):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(682):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(707):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(723):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(736):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(752):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(765):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(781):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(783):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(792):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(817):    auto& ate = static_cast< BcApplyTreatmentEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(818):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(854):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(868):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(882):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(883):    auto& lre = static_cast< BcLocalReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(896):    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(897):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(929):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(950):    auto& rue = static_cast< ProxyBcReleaseUserEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(75):       auto& ppsm = static_cast< PotsCallPsm& >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(80):       auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(88):       SetNPsm(static_cast< CipPsm& >(psm));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(92):       SetUPsm(static_cast< MediaPsm& >(psm));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(128):    auto pmsg = static_cast< PotsMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.cpp(80):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.cpp(80):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(49):    auto& icmsg = static_cast< const PotsMessage& >(msg1);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(116):    auto& pmsg = static_cast< const Pots_UN_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(194):       auto pmsg = static_cast< const PotsMessage* >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(196):       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(200):       auto ppsm = static_cast< const PotsCallPsm* >(port.Upper());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(201):       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(ppsm->TsPort()));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(87):    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(108):    auto prof = static_cast< PotsCircuit* >(cct)->Profile();
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(96):       return static_cast< PotsCallPsm* >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(162):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(197):    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp(186):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp(244):       auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp(265):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp(278):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.cpp(53):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.cpp(55):    auto cfbp = static_cast< PotsCfbFeatureProfile* >(prof->FindFeature(CFB));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.cpp(53):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.cpp(55):    auto cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.cpp(53):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.cpp(55):    auto cfup = static_cast< PotsCfuFeatureProfile* >(prof->FindFeature(CFU));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(264):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(269):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(271):       auto& cssm = static_cast< PotsCfxSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(290):    auto& cssm = static_cast< PotsCfxSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(291):    auto& pssm = static_cast< PotsBcSsm& >(*cssm.Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(335):       auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(360):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(437):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(439):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(452):          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(474):          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(488):       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(494):       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFB));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(500):       cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(529):    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(532):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(587):       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(594):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(608):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(616):       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(632):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(468):    PotsMuxSsm* Mux() const { return static_cast< PotsMuxSsm* >(Parent()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1094):    auto hldNPsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1131):          auto bcUPsm = static_cast< PotsCallPsm* >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1201):    auto msg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1226):    auto npsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1238):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1298):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1340):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1860):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1861):    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1888):    auto& mux = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1900):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1902):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(1909):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2003):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2005):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2006):    auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2007):    auto npsm = static_cast< PotsMuxPsm* >(pmsg->Psm());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2100):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2112):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2124):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2136):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2150):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2162):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2174):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2186):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2198):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2199):    auto& are = static_cast< PotsCwmActiveReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2211):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2212):    auto& ire = static_cast< PotsCwmInactiveReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2224):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(2244):    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(297):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(569):    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(574):       auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(575):       auto ate = static_cast< BcApplyTreatmentEvent* >(sap.CurrEvent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(590):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(598):       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(629):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(657):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(743):    auto& init = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(745):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(838):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(860):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(880):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(882):    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(888):       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(911):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(934):    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(935):    auto& pssm = static_cast< PotsBcSsm& >(*ssm.Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(953):    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(954):    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(958):       auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(977):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(979):    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(983):       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(1024):    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(1025):    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(1027):    auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(1072):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsDiscService.cpp(115):    auto& pssm = static_cast< BcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsDiscService.cpp(117):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.cpp(81):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.cpp(154):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.cpp(160):       auto htlp = static_cast< PotsHtlFeatureProfile* >(prof->FindFeature(HTL));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(183):    auto& pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(229):    auto& pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(232):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(332):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(385):    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(684):    auto& npsm = static_cast< PotsMuxPsm& >(psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(687):    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(752):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(814):    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(910):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(911):    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(931):    auto& mux = static_cast< PotsMuxSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(956):    auto& mux = static_cast< PotsMuxSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(957):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(978):    auto& mux = static_cast< PotsMuxSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(56):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(57):    auto msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(59):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(91):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(105):    auto msg = static_cast< CipMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(107):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(132):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(133):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(135):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(171):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(181):    auto upsm = static_cast< ProxyBcPsm* >(pssm.UPsm());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(202):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(217):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(236):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(237):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(239):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(282):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(300):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(301):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(303):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(346):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(347):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(349):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(398):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(413):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(428):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(443):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(458):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(489):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(490):    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(517):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(533):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(534):    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(561):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(579):    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(580):    auto& pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.cpp(79):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(235):    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(274):    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(300):    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(193):    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(195):    auto wmlp = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(391):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(415):    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(417):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(422):    wmlp_ = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(489):    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(492):    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(552):       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(570):    auto pssm = static_cast< PotsBcSsm* >(Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(593):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(598):       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(600):       auto& wssm = static_cast< PotsWmlSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(619):    auto& wssm = static_cast< PotsWmlSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(620):    auto& pssm = static_cast< PotsBcSsm& >(*wssm.Parent());
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(139):          tt = static_cast< const TransTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(147):          auto mt = static_cast< const MsgTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(674):    auto rxnet = static_cast< const TransTrace* >(events_[index]);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(691):             trans = static_cast< const TransTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(703):             return static_cast< const MsgTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(718):    auto txmsg = static_cast< const MsgTrace* >(events_[index]);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(739):             trans = static_cast< const TransTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(746):             auto rxmsg = static_cast< const MsgTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(899):          tt = static_cast< const TransTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(935):             mt = static_cast< const MsgTrace* >(rec);
  C:\Users\Greg\Documents\rsc\rsc\src\st\StIncrement.cpp(112):    auto ctx = static_cast< Context* >(pool->FirstUsed(bid));
  C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.cpp(63):    return static_cast< StTestData* >(data);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(480):    auto tpsm = static_cast< TestPsm* >(Psm());
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(495):    auto tssm = static_cast< TestSsm* >(RootSsm());
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(543):       if(p->GetFactory() == TestFactoryId) return static_cast< TestPsm* >(p);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(785):       SetTestPsm(static_cast< TestPsm* >(&psm));
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(890):    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(891):    auto tmsg = static_cast< TestMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(924):    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(933):    auto apsm = static_cast< SsmFactory* >(afac)->AllocOgPsm(*amsg);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(944):    auto& tssm = static_cast< TestSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(960):    auto& tssm = static_cast< TestSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(975):    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(976):    auto& tssm = static_cast< TestSsm& >(ssm);
W008 Cast removes const qualification
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(606):    LibrarySet* nbSet = (LibrarySet*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(634):    LibrarySet* nsSet = (LibrarySet*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(95):    item_(const_cast< CxxToken* >(item)),
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1363):       auto self = const_cast< Class* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1561):    return const_cast< Class* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1725):    return const_cast< Class* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(2667):       return const_cast< ClassInst* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(137):    CxxArea* GetArea() const override { return const_cast< CxxArea* >(this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(529):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(574):    Class* GetClass() const override { return const_cast< Class* >(this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(894):    CxxScope* GetTemplateInstance() const override { return (CxxScope*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(1031):       { return const_cast< Namespace* >(this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1090):    return const_cast< DataSpec* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1656):    const_cast< DataSpec* >(this)->FindReferent();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3546):    return const_cast< TypeName* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(738):       { return const_cast< QualName* >(this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1247):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(3033):    return FoundFunc(const_cast< Function* >(this), args);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4404):    auto prev = const_cast< Function* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4628):    if(IsTemplate()) return const_cast< Function* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4638):    if(tmplt_ != nullptr) return (CxxScope*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(392):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1418):       { return const_cast< Function* >(this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(728):    if(n == 0) return const_cast< CxxScoped* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1875):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2105):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2542):    const_cast< Friend* >(this)->FindReferent();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2568):    const_cast< Friend* >(this)->SetScope(decl->GetSpace());
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2579):    const_cast< Friend* >(this)->SetScope(scope);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2908):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3002):    return (CxxScoped*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3015):    return (CxxToken*) this;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(206):    CxxScoped* Referent() const override { return (CxxScoped*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(605):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1532):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1629):    CxxToken* AutoType() const override { return (CxxToken*) this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(779):       const_cast< CxxToken* >(this) : nullptr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(824):    CxxToken* prev = const_cast< CxxToken* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(515):    virtual CxxToken* RootType() const { return const_cast< CxxToken* >(this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(4417):       func->SetTemplate(const_cast< Function* >(tmplt));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(43):    return (void*) ((const_ptr_t) ptr2 - diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(50):    return (void*) ((const_ptr_t) ptr1 + diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp(67):    objects.push_back(const_cast< Base* >(this));
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(185):       (nullptr, size, EnterThread, (void*) client, 0, &id);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.cpp(334):    return const_cast< MsgPort* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.cpp(637):    if(upper == nullptr) return const_cast< ProtocolSM* >(this);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(395):    pit.pptr = (TlvParm*) &pit.mptr->bytes[nextIndex];
W009 Pointer arithmetic
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp(211):       dest = payload + received;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(43):    return (void*) ((const_ptr_t) ptr2 - diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(50):    return (void*) ((const_ptr_t) ptr1 + diff);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(314):    auto after = (ptr_t) next_ + size;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(315):    auto wrap = after >= (buff_ + size_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(342):       after = buff_ + size;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2996):    ptrdiff_t stacksize = &local - priv_->stackBase_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.cpp(187):       source += rcvd;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp(134):       Memory::Copy((bytes_ + hdrSize_ + paySize), source, size);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp(134):       Memory::Copy((bytes_ + hdrSize_ + paySize), source, size);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp(238):       bytes = bytes_ + hdrSize_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp(262):    bytes += hdrSize_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(111):    NodeBase::byte_t* PayloadPtr() const { return bytes_ + hdrSize_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(166):    auto pptr = (TlvParm*) (layout->bytes + layout->header.length);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(249):    auto fence = layout->bytes + layout->header.length;
W015 #include not sorted in standard order
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(31): #include <Windows.h>
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(28): #include <WinSock2.h>
  C:\Users\Greg\Documents\rsc\rsc\src\rsc\main.cpp(31): #include "SysTypes.h"
W020 Using statement in header
  C:\Users\Greg\Documents\rsc\rsc\src\an\AnIncrement.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\an\AnModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelf.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelf.h(32): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelf.h(33): using namespace NetworkBase;
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.h(35): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.h(36): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(33): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(34): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.h(33): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.h(33): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(50): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(51): using namespace NetworkBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(52): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(53): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcRouting.h(31): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(53): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(54): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(55): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\CbModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(33): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(34): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(35): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.h(31): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\cn\CnModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.h(38): using NodeBase::word;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxCharLiteral.h(35): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStrLiteral.h(41): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(47): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(48): using std::string;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(46): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(39): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.h(38): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.h(35): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTracer.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipModule.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(39): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(40): using namespace NetworkBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipTypes.h(26): using namespace NetworkBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipTypes.h(27): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(35): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\StartupParameters.h(21): using namespace NetworkBase;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(27): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.h(33): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MbModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MbPools.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(34): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(35): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.h(33): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.h(34): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.h(32): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(37): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(38): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.h(37): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\ToneRegistry.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.h(37): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtTestData.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(38): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceCfg.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.h(33): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\on\OnModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PbModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBicFeature.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBocFeature.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.h(30): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.h(31): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.h(30): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(40): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(41): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(42): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(43): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCliParms.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCwtFeature.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCxfFeature.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(39): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureRegistry.h(36): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.h(29): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.h(31): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsIncrement.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h(36): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h(37): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h(38): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.h(35): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.h(36): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(45): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(46): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(47): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(48): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsSusFeature.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsTwcFeature.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.h(31): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\rn\RnModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.h(29): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.h(29): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.h(42): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.h(43): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.h(44): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.h(31): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(45): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(46): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(47): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(48): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.h(29): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxySessions.h(28): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxySessions.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSessions.h(44): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSessions.h(45): using namespace NetworkBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSessions.h(46): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSessions.h(47): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsStatistics.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsStatistics.h(31): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.h(30): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.h(31): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.h(31): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.h(32): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(45): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(46): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(47): using namespace MediaBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(48): using namespace CallBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.h(29): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.h(30): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\SnIncrement.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\SnModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.h(41): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.h(42): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.h(54): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.h(55): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.h(33): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.h(34): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.h(34): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\StIncrement.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\StModule.h(28): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.h(32): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.h(33): using namespace SessionBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(43): using namespace NodeBase;
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(44): using namespace SessionBase;
W022 Add using statement
  C:\Users\Greg\Documents\rsc\rsc\src\an\AnIncrement.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\AnModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(0):  // namespace NetworkBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfIpService.cpp(0):  // namespace NetworkBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfIpService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcEvents.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcEvents.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcFactory.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcFactory.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(0):  // namespace NetworkBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcRouting.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcStates.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcStates.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcTriggers.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\CbModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\DigitString.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(0):  // namespace NetworkBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\TestCallFactory.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\cb\TestCallFactory.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\cn\CnModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\dip\WinterOrders.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MbModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MbPools.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\ToneRegistry.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtTestData.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\on\OnModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PbModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBicFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBocFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCliParms.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCwtFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCxfFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureRegistry.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsIncrement.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsMessages.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsMessages.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsMessages.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsMessages.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsSusFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsTwcFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\rn\RnModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcService.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcStates.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(0):  // namespace NetworkBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallIpService.cpp(0):  // namespace NetworkBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallIpService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsDiscService.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsDiscService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsDiscService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxySessions.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxySessions.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsStatistics.cpp(0):  // namespace CallBase::Cause
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsStatistics.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.cpp(0):  // namespace CallBase::Cause
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(0):  // namespace CallBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(0):  // namespace MediaBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\SnIncrement.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\sn\SnModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\StIncrement.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\StModule.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.cpp(0):  // namespace SessionBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(0):  // namespace NodeBase
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(0):  // namespace SessionBase
W023 Remove using statement
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIpBuffer.cpp(36): using namespace NetworkBase;
W026 Unused argument
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(420/3):       const CxxNamed* item, const CxxScope* scope) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(935/1):    static void Shutdown(NodeBase::RestartLevel level);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(939/1):    static void Startup(NodeBase::RestartLevel level) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(84/3):       const CxxNamed* item, const CxxScope* scope) const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1798/3):       (const std::string& fqName, size_t prefix, const CxxScope* scope) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(170/1):    word ChangeCast(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(171/1):    word ChangeClassToNamespace(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(174/1):    word ChangeOperator(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(179/1):    word EraseCast(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(180/1):    word EraseClass(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(193/1):    word InsertCopyCtorCall(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(194/1):    word InsertDataInit(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(196/1):    word InsertDisplay(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(197/1):    word InsertEnumName(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(198/1):    word InsertFallthrough(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(203/1):    word InsertMemberInit(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(205/1):    word InsertPODCtor(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(206/1):    word InsertPureVirtual(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(208/1):    word MoveDefine(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(209/1):    word MoveMemberInit(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(213/1):    word ReplaceHeading(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(214/1):    word ReplaceName(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(418/1):    word FixInvokers(const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(427/1):    word ChangeFunctionToMember(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(427/2):    word ChangeFunctionToMember(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(428/1):    word ChangeInvokerToMember(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(428/2):    word ChangeInvokerToMember(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(429/1):    word EraseArgument(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(429/2):    word EraseArgument(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(430/1):    word EraseDefaultValue(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(430/2):    word EraseDefaultValue(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(431/1):    word EraseParameter(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(431/2):    word EraseParameter(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(433/1):    word InsertArgument(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(433/2):    word InsertArgument(const Function* func, word offset);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(434/1):    word SplitVirtualFunction(const Function* func);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(109/1):    virtual void ProcessIcMsg(Message& msg);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.h(117/1):    static void noop(debug64_t info = 0);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(89/1):    virtual void EventHasOccurred(Event event) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(77/3):       const std::string& prefix, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(79/3):       const std::string& prefix, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.h(45/2):    bool Free(void* addr, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.h(38/1):    void Startup(RestartLevel level);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(329/2):       (BlockingReason why, fn_name_arg func) { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(338/1):    virtual void ScheduledIn(fn_name_arg func) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.h(152/1):    TraceRc StartTracing(const std::string& opts);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(138/3):       (IpBuffer& buff, NodeBase::byte_t* src, size_t size) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(143/1):    virtual void SocketFailed(SysSocket* socket) const { }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(95/1):       (PotsProfile& profile, CliThread& cli) const = 0;  //d
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(63/1):    virtual bool Deactivate(PotsProfile& profile);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(87/1):    virtual bool Unsubscribe(PotsProfile& profile);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(131/1):    virtual Message* AllocOgMsg(SignalId sid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(151/1):    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(151/2):    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(150/1):    virtual ProtocolLayer* AllocLower(const Message* msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(286/1):    virtual void MsgHandled(Message& msg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(292/1):    virtual void RestoreIcMsg(Message& msg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(298/1):    virtual void RefreshMsg(Message& msg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\RootServiceSM.h(50/1):    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(79/2):    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(187/1):       (Event& currEvent, Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(187/2):       (Event& currEvent, Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmFactory.h(48/1):    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.h(61/1):    explicit PotsCfxSsm(ServiceId sid);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(455/2):    EventHandler::Rc ReleaseInactive(Cause::Ind cause, Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(158/1):    PotsMuxSsm(const Message& msg, ProtocolSM& psm);
W027 Unused class
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(192): class ProxyBcDisconnecting : public BcDisconnecting
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.h(77): struct LibItemSort
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipModule.h(38): class DipModule : public Module
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.h(42): class MediaFailureEvent : public Event
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PooledClass.h(39): class PooledClass : public Class
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(44): class SysLock
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(37): class TextTlvMessage : public TlvMessage
W028 Unused data
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(63):    static const ServicePortId NextPortId = FirstPortId + 1;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(219):    static const Id NextId        = FirstId + 4;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(303):    static const Id NextId              = FirstId + 7;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(387):    constexpr TriggerId NextId = FirstId + 3;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(448):    constexpr char Unchecked = ' ';  // spacing not determined
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(162): constexpr ProtocolError IM_TIMEOUT = 0x01;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(163): constexpr ProtocolError IM_EXPECTED = 0x02;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(164): constexpr ProtocolError IM_WRONG_ENDIAN = 0x03;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(165): constexpr ProtocolError IM_WRONG_MAGIC_NUMBER = 0x04;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(166): constexpr ProtocolError IM_INCOMPATIBLE_VERSION = 0x05;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(167): constexpr ProtocolError IM_REPEATED = 0x06;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(168): constexpr ProtocolError IM_FROM_SERVER = 0x07;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(169): constexpr ProtocolError INVALID_MESSAGE_TYPE = 0x08;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(170): constexpr ProtocolError MESSAGE_TOO_SHORT = 0x09;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(171): constexpr ProtocolError DM_BEFORE_RM = 0x0A;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(172): constexpr ProtocolError RM_EXPECTED = 0x0B;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(173): constexpr ProtocolError RM_REPEATED = 0x0C;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(174): constexpr ProtocolError RM_FROM_CLIENT = 0x0D;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(175): constexpr ProtocolError DM_INVALID_TOKEN = 0x0E;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(197): constexpr BotEvent FIRST_BOT_BM_EVENT = 2;  // start of subclass events
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(208): constexpr category_t CATEGORY_NUMBER_MIN = 0x00;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(209): constexpr category_t CATEGORY_NUMBER_MAX = 0x3F;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(210): constexpr category_t CATEGORY_BRACKET = 0x40;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(213): constexpr category_t CATEGORY_ORDER = 0x43;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(215): constexpr category_t CATEGORY_RESULT = 0x45;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(218): constexpr category_t CATEGORY_COMMAND = 0x48;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(219): constexpr category_t CATEGORY_PARAMETER = 0x49;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(220): constexpr category_t CATEGORY_PRESS = 0x4A;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Duration.h(59): constexpr uint32_t NS_TO_SECS = std::nano::den;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbAppIds.h(72): constexpr FlagId FirstAppDebugFlag = 10;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(195):    static const id_t LastNbIndex = 3;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(50): constexpr uword UWORD_MAX = (sizeof(word) == 8 ? UINT64_MAX : UINT32_MAX);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(80):    static const id_t LastNtIndex = FuncTraceScope;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTypes.h(108): constexpr ipport_t FirstAppIpPort = 1024;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTypes.h(114): constexpr ipport_t LastAppIpPort = MaxIpPort;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(105):    static const Id LastId    = NextId + 9;  // range constant
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(133):    static const Id LastId   = NextId + 7;  // range constant
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.h(55):    static const NodeBase::id_t LastSbIndex    = LastNwIndex + 9;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.h(85):    static const NodeBase::id_t LastSbIndex   = LastNwIndex + 6;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.h(115):    static const NodeBase::id_t LastSbIndex   = LastNwIndex + 5;
W029 Unused enum
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(72):    enum Location
W030 Unused enumerator
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(147):       Multiple   // two statements or more
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(61):       FIRST_BOT_SPECIFIC_ERROR
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.h(44):    DispOption_N  // number of reasons; can be used to extend this enum
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.h(74):    IdleFaction,         // idle thread (not used)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(194):    MemInaccessible = 0,      // ---
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(195):    MemExecuteOnly = 1,       // --x
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(197):    MemReadExecute = 5,       // r-x
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(199):    MemReadWriteExecute = 7,  // rwx
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ToolTypes.h(66):    TraceFailed,        // operation failed for some other reason
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(85):       PortAllocFailed,      // failed to create PSM for context
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(88):       IllegalSignal,   // illegal signal found              0000  sid
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(89):       IllegalParm,     // illegal parameter found          index  pid
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(90):       IncompleteParm,  // parameter too short              index  pid
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(91):       MissingParm,     // mandatory parameter missing       0000  pid
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(92):       Overflow,        // last parameter extends past end  index  pid
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(93):       Trampled         // last parameter trampled fence    index  pid
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(121):       StreamContainsIllegalParm,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(95):       SignalUnknown,     // signal not recognized
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(97):       ParameterUnknown,  // parameter not recognized
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(98):       ParameterInvalid,  // parameter not valid for this signal
W032 Unused function
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(213):    Digit At(DigitCount i) const;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(182):    MediaInfo* AddMedia(const MediaInfo& media);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(195):    explicit ProxyBcDisconnecting(ServiceId sid);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(160):    size_t Arrays() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(850):    static bool ParsingTemplate();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1212):    bool IsFinal() const { return GetDecl()->final_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.h(46):    size_t rfind_first_of
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.h(114):    std::string& Prefix(std::string&& scope,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(422):    word FixInvoker(const Function* func, const CodeWarning& log);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(448):    size_t LineFindFirstOf(size_t pos, const std::string& chars) const;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.h(72):    DipHeader* Header() const;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.h(48):    explicit TokenMessage(const Token* stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.h(141):    void set_as_ascii(const std::string& text);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\WinterOrders.h(52):    size_t get_number_of_results() const;
  C:\Users\Greg\Documents\rsc\rsc\src\launcher\RscLauncher.cpp(143): int main()
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(58):    StateId GetState() const { return state_; }
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(62):    virtual void SetState(StateId stid);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(72):    ProtocolSM* MgwPsm() const;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(78):    virtual void Deallocate();
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(92):    explicit MediaEndpt(MediaPsm& psm);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.h(48):    MediaFailureEvent(ServiceSM& owner, MediaEndpt& mep);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.h(56):    MediaEndpt* Mep() const { return mep_; }
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(120):    MediaEndpt* Mep() const { return mep_; }
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.h(48):    virtual bool SetMgwPsm(ProtocolSM* psm);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.h(73):    Id Tid() const { return Id(tid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(144):    const T& Back() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(152):    T& Back()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(160):    const T& At(size_t index) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(168):    T& At(size_t index)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(192):    const T* Data() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgStrParm.h(61):    c_string NextValue() const { return next_.c_str(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(71):    virtual void Initialize();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(80):    virtual Object* Create();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(84):    virtual Object* GetQuasiSingleton();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(88):    virtual void FreeQuasiSingleton(Object* obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(143):    bool SetVptr(const Object& obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(150):    bool SetTemplate(Object& obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(158):    bool SetQuasiSingleton(Object& obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(142):    word Result() const { return result_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(63):    void SendToThread(Thread* thread);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(67):    void Restart(uint32_t secs);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(93):    Base* Owner() const { return owner_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\DeferredRegistry.h(52):    void EraseAll(const Base* owner);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Duration.h(45): std::string to_string(const usecs_t& usecs);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Duration.h(46): std::string to_string(const nsecs_t& nsecs);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ElementException.h(53):    RestartReason Reason() const { return reason_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ElementException.h(57):    debug64_t Errval() const { return errval_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.h(53):    bool strToSize(const std::string& str, size_t& size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(169):    PerThreadInfo()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\HeapCfg.h(55):    size_t GetMinSize(MemoryType type) const { return minSize_[type]; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroupRegistry.h(62):    Log* FindLog(const std::string& name, LogId id) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MainArgs.h(66):    static std::string Find(c_string tag);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.h(50):    size_t Words(size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.h(58):    void Set(void* dest, byte_t value, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.h(78):    void* Realloc(void* addr, size_t size, MemoryType type);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Module.h(96):    ModuleId Mid() const { return mid_.GetId(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(92):    ClassId GetClassId() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(104):    ObjectId GetObjectId() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(110):    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(131):    void MorphTo(const Class& target);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PooledClass.h(53):    PooledClass(ClassId cid, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PooledClass.h(69):    bool SetPool(ObjectPool& pool);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.h(148): Flags PS_Delayed();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Link.h(65):    bool IsQueued() const { return next != nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(298):    void Display(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysHeap.h(107):    SysHeap(MemoryType type, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(49):    SysLock();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(66):    void Acquire();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(70):    void Release();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(74):    SysThreadId Owner() const { return owner_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h(78):    void Display(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.h(49):    bool Lock(void* addr, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.h(54):    bool Unlock(void* addr, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMutex.h(115):    Thread* Owner() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(129):    static std::atomic_uint32_t* Vector();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(133):    static bool TestFlag(FlagId fid);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(137):    static void ResetFlag(FlagId fid);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(160):    Faction GetFaction() const { return faction_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(164):    bool ChangeFaction(Faction faction);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(410):    static main_t EnterThread(void* arg);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(488):    SysMutex* BlockingMutex() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(496):    uint8_t MutexCount() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.h(182):    const SystemTime::Point& StartTime() const { return startTime_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceRegistry.h(61):    std::vector< IpService* > GetServices(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(113):    static const SysIpL2Addr& NullIpAddr();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(117):    const IPv6Addr& Addr() const { return addr_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(50): uint64_t htonll(uint64_t hostllong);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(53): uint64_t ntohll(uint64_t netllong);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(143):    bool LocAddr(SysIpL3Addr& locAddr);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(198):    IpBuffer* IcMsg() const { return icMsg_; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(93):    bool IsRinging() const { return ringing_; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(97):    bool CanFlash() const { return flash_; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(102):    Cause::Ind GetCause() const { return cause_; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(287):    MediaInfo* AddMedia(const MediaInfo& media);
  C:\Users\Greg\Documents\rsc\rsc\src\rsc\main.cpp(123): main_t main(int argc, char* argv[])
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(120):    static void Kill(NodeBase::debug64_t errval, NodeBase::debug64_t offset);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(125):    static void Dump(NodeBase::fn_name_arg func,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(231):    void SetFaction(NodeBase::Faction faction) { faction_ = faction; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\GlobalAddress.h(47):    GlobalAddress(const NetworkBase::SysIpL3Addr& l3Addr, FactoryId fid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\GlobalAddress.h(66):    GlobalAddress(GlobalAddress&& that) = default;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\LocalAddress.h(55):    LocalAddress(LocalAddress&& that) = default;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(181):    Message* FindSignal(SignalId sid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(89):    ProtocolId Prid() const { return prid_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(68):    bool IsLowermost() const { return lower_ == nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(135):    Message* FirstSentMsg() const { return sentMsgq_.First(); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(166):    bool DropPeer(const GlobalAddress& peerPrevRemAddr);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h(91):    StateId CurrState() const { return currState_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h(131):    Message* SavedMsg() const { return savedMsg_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h(227):    StateId CurrState() const { return currState_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h(231):    StateId NextState() const { return nextState_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h(372):    bool IsInitiation() const { return initiation_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h(383):    Message* GetMessage() const { return message_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(131):    bool Disable();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(135):    bool Enable();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(132):    bool HasTriggered(TriggerId tid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Signal.h(85):    ProtocolId Prid() const { return prid_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.h(64):    ServiceId Sid() const { return sid_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(58):    explicit TextTlvMessage(SbIpBufferPtr& buff);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(62):    TextTlvMessage(ProtocolSM* psm, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(68):    bool Receive();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(58):    TlvMessage(const TlvParm& parm, ProtocolSM* psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(67):    virtual TlvParm* Wrap(const TlvMessage& msg, ParameterId pid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(176):    size_t AllParms(const TlvParm* ptab[], size_t size) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(182):    size_t FindParms(ParameterId pid, const TlvParm* ptab[], size_t size) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(196):    TlvParm* AddBytes(const NodeBase::byte_t* src, size_t size, ParameterId pid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(202):    TlvParm* CopyParm(const TlvParm& src, ParameterId pid = NodeBase::NIL_ID);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(263):    NodeBase::byte_t* FindBytes(size_t& size, ParameterId pid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(270):    virtual bool MatchParm
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(286):    size_t ParmOffset(const ParmIterator& pit) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvParameter.h(68):    static Id ExtractPid(const TlvParm& parm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(77):    PotsMuxPsm(ProtocolLayer& adj, bool upper, Switch::PortId port);
W033 Unused typedef
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.h(226): using PersistentStr =
W037 Member hides inherited name
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(316):    static const Id NextId = FirstId + 50;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(883):    static const Id NextId                 = FirstUn + 7;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(63):    static const ServicePortId NextPortId = FirstPortId + 1;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(213):    static const Id FirstId = BcEvent::NextId;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(219):    static const Id NextId        = FirstId + 4;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(303):    static const Id NextId              = FirstId + 7;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.h(77):    static ptrdiff_t CellDiff();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(97):    static ptrdiff_t LinkDiff();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(105):    void HostToNetwork(IPv4Addr& netaddr, ipport_t& netport) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(110):    void HostToNetwork(uint16_t netaddr[8], ipport_t& netport) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(115):    void NetworkToHost(IPv4Addr netaddr, ipport_t netport);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(120):    void NetworkToHost(const uint16_t netaddr[8], ipport_t netport);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(160):    std::string to_str(bool verbose) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(166):    static ptrdiff_t LinkDiff();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Timer.h(105):    static ptrdiff_t LinkDiff();
W038 Class could be namespace
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(213): class Facility
W042 Member could be private
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(175):    static bool IsValidDigit(Digit d)
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(182):    Rc AddDigit(Digit d);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(201):    DigitCount Size() const;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(236):    void EnsureMediaMsg() override;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(245):    IncomingRc ProcessIcMsg(Message& msg, Event*& event) override;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(423):    Message* AllocIcMsg(SbIpBufferPtr& buff) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1015):    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1016):    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1017):    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1063):    virtual EventHandler::Rc RequestService(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1145):    CipPsm* AllocNPsm();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(488):    ProxyBcPsm* FirstBroadcast() const;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.h(54):    void SetService(Address::SC sc, ServiceId sid);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.h(54):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(130):    const CxxTokenList Items() const { return items_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(131):    const IncludePtrVector& Includes() const { return incls_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(284):    size_t FindFirstReference(const CxxTokenVector& refs) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(289):    size_t FindLastUsage(const CxxNamedSet& usages) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.h(109):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.h(64):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(543):    Numeric(NumericType type, size_t width, bool sign) :
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(92):    Typedef* FindType(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(174):    Enum* FindEnum(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(178):    Enumerator* FindEnumerator(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(392):    void FindCtors(FunctionVector& ctors) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(408):    FunctionDefinition GetFuncDefinition(FunctionRole role) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(520):    bool AddAnonymousUnion(const ClassPtr& cls) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(992):    Namespace* FindNamespace(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(270):    virtual CxxToken* GetValue() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(319):    CxxToken* RootType() const override { return GetValue(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(164):    size_t Refs() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(747):    static Cxx::Access ScopeAccess() { return Frame_->ScopeAccess(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(878):    static bool OptionIsOn(char opt);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(886):    static void Trace(CxxTrace::Action act, const CodeFile& file);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(265):    virtual bool ResolveTemplate
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(625):    TypeName* Last() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(792):    bool ResolveTemplate
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(936):    bool IsUnboundedArray() const { return array_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1197):    DataSpec(const DataSpec& that);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(355):    const Data* GetDecl() const { return (defn_ ? mate_ : this); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(360):    const Data* GetDefn() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1152):    bool IsDefaulted() const { return GetDefn()->defaulted_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1206):    Function* GetBase() const { return GetDecl()->base_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1272):    size_t MaxArgs() const { return args_.size(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1337):    bool IsInvokedInBase() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1366):    void CheckAccessControl() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1370):    void CheckIfHiding() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(70):    bool IsClassMember() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(79):    bool IsSubscopeOf(const std::string& fqSuper) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(137):    bool Contains(const CxxToken* item) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(614):    void CheckAccessControl() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1136):    bool ResolveTemplate
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1873):    bool ResolveTypedef(Typedef* type, size_t n) const override { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStrLiteral.h(78):    static DataPtr CreateRef()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(502):    virtual bool GetSpan(size_t& begin, size_t& left, size_t& end) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(160):    bool Advance();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(364):    const LineInfo* GetLineInfo(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(414):    bool LineHasTrailingCommentAt(size_t n, size_t offset) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(452):    size_t LineRfindFirstOf(size_t pos, const std::string& chars) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(528):    NodeBase::word CheckDepth(size_t n) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryVarSet.h(53):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h(95):    bool is_number() const;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.h(123):    size_t set_from(const Token* stream);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.h(128):    size_t set_from(const Token* stream, size_t length);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(104):    virtual void EndOfTransaction();
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(132):    Tone::Id GetOgTone() const { return ogTone_; }
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(170):    void SetOgPort(Switch::PortId ogport);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(193):    void PrepareOgMsgq() override;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(197):    Event* ReceiveMsg(Message& msg) override;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.h(74):    static bool IsValidPort(PortId pid)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.h(52):    virtual bool CurrValue() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.h(56):    virtual bool NextValue() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.h(70):    bool SetNext(c_string input) override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBoolParm.h(68):    bool SetNextValue(bool value) override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.h(48):    bool CurrValue() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.h(69):    bool SetNextValue(bool value) override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(62):    virtual bool SetNextValue(word value);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(84):    bool SetNext(c_string input) override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h(68):    c_string Key() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h(100):    virtual std::string GetCurr() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParmRegistry.h(60):    CfgTuple* FindTuple(const std::string& key) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(75):    virtual MemoryType ObjType() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(137):    virtual Object* New(size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliBuffer.h(104):    bool ReadingFromFile() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h(46):    static const char CommandSeparator;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliStack.h(68):    const CliCommand* FindCommand
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h(61):    c_string HelpText() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(56):    virtual void* Addr() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(103):    virtual size_t Overhead() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(117):    size_t MaxInUse() const { return maxInUse_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(142):    bool IsFixedSize() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.h(119):    static Log* Find(c_string groupName, LogId id, LogGroup*& group);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.h(76):    id_t Gid() const { return gid_.GetId(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.h(80):    bool Suppressed() const { return suppressed_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MutexRegistry.h(56):    SysMutex* Find(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(98):    virtual InstanceId GetInstanceId() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPoolRegistry.h(65):    bool NullifyObjectData() const { return nullifyObjectDataCfg_->CurrValue(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(493):    void Purge()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.h(54):    static const size_t ReportWidth;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.h(62):    id_t Gid() const { return gid_.GetId(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(141):    static void ResetFlags();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(156):    SysThreadId NativeThreadId() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceRecord.h(54):    static const uint32_t InvalidSlot;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(87):    bool ExitOnRestart(NodeBase::RestartLevel level) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h(189):    virtual IoThread* CreateIoThread();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTracer.h(63):    bool PeersEmpty() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTracer.h(67):    bool PortsEmpty() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(90):    NodeBase::word Connect(const SysIpL3Addr& remAddr);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(138):    NodeBase::word Send(const NodeBase::byte_t* data, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(160):    bool SetClose(bool graceful);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(189):    bool IsOpen() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.h(73):    NodeBase::word SendTo
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.h(75):    void Unblock() override;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpService.h(86):    IpPort* CreatePort(ipport_t pid) override;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.h(58):    void Unblock() override;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIpService.h(59):    IpPort* CreatePort(ipport_t pid) override;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(134):    void ResetCircuit();
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(72):    Id Fid() const { return Id(fid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(80):    c_string FullName() const { return name_; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(84):    bool CanBeDeactivated() const { return deactivation_; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(67):    PotsFeature::Id Fid() const { return fid_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(158):    bool StopTimer(const Base& owner, TimerId tid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(192):    virtual void EndOfTransaction() { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.h(130):    virtual bool Save();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.h(134):    virtual Event* Restore(EventHandler::Rc& rc);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.h(138):    virtual void Free();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(151):    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(235):    virtual Context* AllocContext() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.h(57):    static NodeBase::word RtcYieldPercent() { return RtcYieldPercent_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(329):    virtual void Handled(bool retain);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(333):    virtual bool SendFailure(NodeBase::debug64_t errval);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.h(53):    MsgPort(const Message& msg, Context& ctx);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(89):    virtual FactoryId GetFactory() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(143):    ProtocolId GetProtocol() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(251):    bool SendMsg(Message& msg) override;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(520):    const StateId stid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(65):    Id Sid() const { return Id(sid_.GetId()); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(79):    static bool IsValidPortId(PortId pid)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(121):    bool IsModifiable() const { return modifiable_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(125):    bool IsModifier() const { return modifier_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(95):    StateId NextState() const { return nextState_; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(147):       ParmIterator() : mptr(nullptr), pptr(nullptr), pindex(0) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(150):       ParmIterator& operator=(const ParmIterator& that) = default;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(165):    TlvParm* FirstParm(ParmIterator& pit) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(170):    TlvParm* NextParm(ParmIterator& pit) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(191):    virtual TlvParm* AddParm(ParameterId pid, size_t plen);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(276):    virtual void AddFence();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(280):    TlvMsgLayout* TlvLayout() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(291):    Fence* FencePtr() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(295):    void CheckFence() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Trigger.h(80):    static bool IsValidId(Id tid)
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(263):    void StartTimer(TimerId tid, uint32_t secs);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h(160):    void SetProfile(PotsProfile* prof) { prof_ = prof; }
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSessions.h(410):    ProtocolSM* TimerPsm(TimerId tid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.h(58):    void SetCauseToTreatmentQ(Cause::Ind cause, PotsTreatmentQueue::QId qid);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(96):    PotsTreatment* NextTreatment(const PotsTreatment& treatment) const;
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(265):    void UpdateTestPsm();
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(348):    TestPsm* GetTestPsm() const { return testPsm_; }
W043 Member could be protected
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(124):    static DN IndexToDN(uint32_t i) { return i + FirstDN - 1; }
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1029):    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1034):    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1099):    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CtIncrement.cpp(93):    static LibrarySet* Evaluate(CliThread& cli);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(68):    const ClassPtrVector* Classes() const { return &classes_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(70):    const EnumPtrVector* Enums() const { return &enums_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(71):    const ForwardPtrVector* Forws() const { return &forws_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(74):    const TypedefPtrVector* Types() const { return &types_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(75):    const AsmPtrVector* Assembly() const { return &assembly_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(76):    const StaticAssertPtrVector* Asserts() const { return &asserts_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(865):    const std::string& GetText() const { return text_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(211):    void DisplayReferent(std::ostream& stream, bool fq) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(221):    void strName(std::ostream& stream, bool fq, const QualName* name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1033):    TypeSpecUser GetUserType() const { return user_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(73):    void ReplaceTemplateParms(std::string& code,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(335):    bool IsThreadLocal() const { return thread_local_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(339):    bool IsConstexpr() const { return constexpr_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(343):    bool WasInited() const { return GetDecl()->inited_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(106):    CxxScoped* FindInheritedName() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(125):    virtual bool IsUnused() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(142):    void DisplayFiles(std::ostream& stream) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(476):    std::string strLocation() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(376):    size_t PrevBegin(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(388):    LineType PosToType(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(392):    bool IsBlankLine(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(396):    size_t LineSize(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(400):    bool OnSameLine(size_t pos1, size_t pos2) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(405):    int CompareCode(size_t pos, const std::string& str) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(409):    size_t FindComment(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(424):    size_t LineFindNext(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(428):    bool IsFirstNonBlank(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(432):    bool NoCodeFollows(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(438):    size_t LineFind(size_t pos, const std::string& str) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(442):    size_t LineRfind(size_t pos, const std::string& str) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(456):    size_t LineFindNonBlank(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(460):    size_t LineRfindNonBlank(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(472):    size_t FindNonBlank(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(75):    virtual void Display(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(98):    void LogSubtended(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h(51):    static fixed_string UnexpectedIndex;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.h(44):    bool BindCommand(CliCommand& comm);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(131):    static fixed_string AnyStringParm;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(166):    bool GetBoolParm(bool& b, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(176):    bool GetCharParm(char& c, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(186):    bool GetPtrParm(void*& p, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(212):    bool GetTextParm(id_t& i, std::string& s, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(234):    bool GetFileName(std::string& s, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(246):    bool GetIdentifier(std::string& s, CliThread& cli,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(261):    bool IsOptional() const { return opt_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h(65):    const Registry< CliParm >& Parms() const { return parms_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Daemon.h(96):    id_t Did() const { return did_.GetId(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.h(44):    FunctionTrace();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MsgBuffer.h(47):    MsgBuffer(const MsgBuffer& that);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(59):    virtual void Patch(sel_t selector, void* arguments) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SoftwareException.h(41):    SoftwareException(debug64_t errval, debug64_t offset);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(68):    virtual void DisplayStat(std::ostream& stream, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StreamRequest.h(59):    StreamRequest(const StreamRequest& that);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(71):    IpPort* Port() const { return port_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(113):    id_t Sid() const { return sid_.GetId(); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(57):    SysIpL2Addr(const SysIpL2Addr& that) = default;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(107):    bool IsValid() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(128):    virtual AllocRc SetService(const IpService* service, bool shared);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(145):    void OutputLog(NodeBase::LogId id,
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(263):    explicit PotsMessage(SbIpBufferPtr& buff);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.h(96):    enum Location
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(132):    virtual InspectRc InspectMsg(NodeBase::debug64_t& errval) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(241):    NodeBase::MsgDirection Dir() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(64):    bool IsUppermost() const { return upper_ == nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(75):    enum IncomingRc
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(84):    enum OutgoingRc
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(129):    Message* FirstOgMsg() const { return ogMsgq_.First(); }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(87):    virtual NodeBase::c_string PortName(PortId pid) const;
W044 Typedef of pointer type
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysDecls.h(46): typedef void* SysHeap_t;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(54): typedef void* StackFrames[MaxFrames];
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(101): typedef char* ptr_t;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(102): typedef const char* const_ptr_t;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(119): typedef const char* c_string;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(120): typedef const char* const fixed_string;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(125): typedef const char* const fn_name;      // for defining a function name
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h(126): typedef const char* const fn_name_arg;  // when fn_name is an argument
W047 Data is init-only
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Gate.cpp(50):    std::unique_lock< std::mutex > lock(mutex_);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(308):    std::ostringstream expl;
W048 Data is write-only
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(121):    bool game_started;                // set when the game has begun
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(147):    word our_number_of_disbands;    // disbands required (negative for builds)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(921):    SteadyTime::Point readyTime_;
W050 Data is not private
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(340):    size_t refs_ : 16;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(333):    CxxToken* item_;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(980):    bool ptrDet_: 1;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(984):    bool refDet_: 1;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(564):    std::string code_;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(568):    CodeFile* file_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(211):    std::unique_ptr< CliBuffer > ibuf;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(215):    ostringstreamPtr obuf;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(87):    std::atomic_size_t curr_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(91):    std::atomic_size_t prev_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(95):    std::atomic_uint64_t total_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(99):    size_t divisor_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceRecord.h(125):    Id rid_ : 8;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(91):    const ipport_t port_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(96):    IpPort* ipPort_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(100):    SysIpL2Addr self_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(104):    size_t recvs_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(108):    SysIpL3Addr txAddr_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(113):    SysIpL3Addr rxAddr_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(117):    NodeBase::SteadyTime::Point time_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h(121):    NodeBase::byte_t* buffer_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(482):    ServiceId owner_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(486):    const EventId eid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(516):    const ServiceId sid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(520):    const StateId stid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(524):    const EventHandler::Rc rc_;
W053 Data could be const
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(175):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(340):    Progress::Ind progress_;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(356):    Cause::Ind cause_;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(237):    LibraryVarSet* varSet_;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryTypes.h(64):    size_t level;    // the file's level in the build
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.h(112):       BotEvent event;         // event
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(144):    DipHeader header;  // no parameters (length = 0)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h(202):    byte_t first_payload_byte;  // for creating a pointer to the first byte
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.h(93):    RegCell port_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.h(129):    RegCell aid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(96):    word min_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(100):    word max_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h(158):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.h(122):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliBuffer.cpp(61):    istreamPtr file_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.h(110):    RegCell iid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIntParm.h(71):    word min_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIntParm.h(75):    word max_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIntParm.h(79):    bool hex_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(105):    Q2Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.h(185):    RegCell lid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.h(137):    RegCell gid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Module.h(134):    RegCell mid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(56):    Q2Link link;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(136):    uintptr_t patchArea_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.h(135):    RegCell sid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Singletons.cpp(41):    MemoryType type;    // the type of memory that the singleton uses
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(115):    RegCell sid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.h(97):    RegCell gid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Symbol.h(112):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMutex.h(140):    RegCell mid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.h(75):    ThreadId tid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.h(91):    Q2Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1365):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1851):    Q2Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h(207):    NodeBase::Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(160):    RegCell sid_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceCfg.h(60):    IpService* const service_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.h(98):    IoThreadRecreator* recreator_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTypes.h(60):       uint8_t  u8[16];  // bytes: [12-15] overlay IPv4Addr
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(99):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.h(59):    Address::DN dn_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(309):    NodeBase::Q2Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(333):    NodeBase::Faction faction_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.h(137):    NodeBase::Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.h(132):    NodeBase::RegCell iid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.h(158):    static NodeBase::word RtcYieldPercent_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Timer.h(133):    TimerId tid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Timer.h(145):    NodeBase::Q2Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(190):    Cause::Ind cause_;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(154):    Facility::Ind ind_;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(168):    PotsTreatmentQueue::QId qid_;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(172):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(201):    Tone::Id tone_;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(205):    uint32_t secs_;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.h(128):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.h(145):    Q1Link link_;
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.h(85):    Q1Link link_;
W054 Data could be const pointer
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryTypes.h(63):    CodeFile* file;  // the file
W055 Data need not be mutable
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.h(113):       mutable uint32_t secs;  // delay
W056 Implicit constructor invoked: POD members not initialized
i C:\Users\Greg\Documents\rsc\rsc\src\launcher\RscLauncher.win.cpp(38):    STARTUPINFOA si;
i C:\Users\Greg\Documents\rsc\rsc\src\launcher\RscLauncher.win.cpp(39):    PROCESS_INFORMATION pi;
i C:\Users\Greg\Documents\rsc\rsc\src\nb\SystemTime.cpp(101):    tm ymdhms;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(63): class TinyBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(74): class SmallBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(85): class MediumBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(96): class LargeBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(107): class HugeBuffer : public ByteBuffer
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.win.cpp(50):       addrinfo hints;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(51):    addrinfo hints;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(132):    sockaddr_in ipv4addr;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp(133):    sockaddr_in6 ipv6addr;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(127):    sockaddr_in ipv4addr;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(128):    sockaddr_in6 ipv6addr;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(322):    WSAData wsaData;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(47):    sockaddr_in ipv4peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(48):    sockaddr_in6 ipv6peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(98):    sockaddr_in ipv4peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(99):    sockaddr_in6 ipv6peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(191):    sockaddr_in ipv4self;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(192):    sockaddr_in6 ipv6self;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(329):    sockaddr_in ipv4peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(330):    sockaddr_in6 ipv6peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(404):    linger linger_opts;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(90):    sockaddr_in ipv4peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(91):    sockaddr_in6 ipv6peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(172):    sockaddr_in ipv4peer;
i C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp(173):    sockaddr_in6 ipv6peer;
W060 Base class constructor is public
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(259):    Class(QualNamePtr& name, Cxx::ClassTag tag);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(79):    Lexer();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBoolParm.h(39):    CfgBoolParm(c_string key, c_string def, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(39):    CfgIntParm(c_string key, c_string def, word min, word max, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgStrParm.h(40):    CfgStrParm(c_string key, c_string def, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCharParm.h(40):    CliCharParm(c_string help, c_string chars,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIntParm.h(45):    CliIntParm(c_string help, word min, word max,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h(49):    CliText(c_string help, c_string text, bool opt = false, uint32_t size = 32);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliTextParm.h(49):    explicit CliTextParm(c_string help, bool opt = false,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.h(44):    FunctionTrace();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(41):    StatusCommand();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(56):    LogsAction();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(76):    explicit LogsCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(93):    SetWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(107):    explicit SetCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(124):    IncludeWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(138):    explicit IncludeCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(155):    ExcludeWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(168):    explicit ExcludeCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(199):    explicit QueryCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(216):    SaveWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(228):    explicit SaveCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(245):    ClearWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h(263):    explicit ClearCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SoftwareException.h(41):    SoftwareException(debug64_t errval, debug64_t offset);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SoftwareException.h(42):    SoftwareException(const std::string& errstr, debug64_t offset);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(131):    explicit Counter(const std::string& expl, size_t divisor = 1);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StreamRequest.h(54):    StreamRequest();
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(44):    CorruptWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(56):    explicit CorruptCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(98):    NtSaveWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(110):    explicit NtSaveCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(123):    TestsAction();
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h(144):    explicit TestsCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(55):    IpBuffer(NodeBase::MsgDirection dir, size_t header, size_t payload);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwCliParms.h(68):    IpAddrParm(NodeBase::c_string help, NodeBase::c_string text);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(39):    NwClearWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(54):    explicit NwClearCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(69):    NwExcludeWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(82):    explicit NwExcludeCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(97):    NwIncludeWhatParm();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(110):    explicit NwIncludeCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(127):    explicit NwQueryCommand(bool bind = true);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h(142):    NwStatusCommand() = default;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(42):    SysIpL2Addr();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(49):    SysIpL2Addr(const std::string& text);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(41):    SysIpL3Addr();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(46):    SysIpL3Addr(const SysIpL2Addr& l2Addr, ipport_t port,
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(53):    SysIpL3Addr(IPv4Addr netaddr, ipport_t netport,
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(60):    SysIpL3Addr(const uint16_t netaddr[8], ipport_t netport,
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(69):    explicit SysIpL3Addr(const std::string& text);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(79):    SysIpL3Addr
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(263):    explicit PotsMessage(SbIpBufferPtr& buff);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h(267):    PotsMessage(ProtocolSM* psm, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(462):    EventTrace(Id rid, const Event& evt);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(503):    HandlerTrace(ServiceId sid, const State& state, const Event& evt,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(50):    TlvMessage(ProtocolSM* psm, size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(58):    TlvMessage(const TlvParm& parm, ProtocolSM* psm);
W065 Base class virtual destructor is not public
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(196):    virtual ~LibrarySet();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliAppData.h(82):    virtual ~CliAppData();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Exception.h(69):    virtual ~Exception();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(270):    virtual ~Thread();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(214):    virtual ~SysSocket();
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(80):    virtual ~PotsFeatureProfile();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(188):    virtual ~Context();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.h(99):    virtual ~Initiator();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(126):    virtual ~ProtocolLayer();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(167):    virtual ~ServiceSM();
W075 Virtual function is public
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1010):    virtual EventHandler::Rc RaiseAuthorizeOrigination(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1011):    virtual EventHandler::Rc RaiseCollectInformation(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1012):    virtual EventHandler::Rc RaiseLocalInformation(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1013):    virtual EventHandler::Rc RaiseCollectionTimeout(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1014):    virtual EventHandler::Rc RaiseAnalyzeInformation(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1015):    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1016):    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1017):    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1018):    virtual EventHandler::Rc RaiseSendCall(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1019):    virtual EventHandler::Rc RaiseRemoteBusy(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1020):    virtual EventHandler::Rc RaiseRemoteProgress
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1022):    virtual EventHandler::Rc RaiseRemoteAlerting(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1023):    virtual EventHandler::Rc RaiseRemoteNoAnswer(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1024):    virtual EventHandler::Rc RaiseRemoteAnswer(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1025):    virtual EventHandler::Rc RaiseAuthorizeTermination(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1026):    virtual EventHandler::Rc RaiseSelectFacility(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1027):    virtual EventHandler::Rc RaisePresentCall(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1028):    virtual EventHandler::Rc RaiseLocalBusy(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1029):    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1030):    virtual EventHandler::Rc RaiseLocalProgress
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1032):    virtual EventHandler::Rc RaiseLocalAlerting(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1033):    virtual EventHandler::Rc RaiseLocalAnswer(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1034):    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1035):    virtual EventHandler::Rc RaiseLocalSuspend(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1036):    virtual EventHandler::Rc RaiseLocalResume(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1037):    virtual EventHandler::Rc RaiseRemoteSuspend(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1038):    virtual EventHandler::Rc RaiseRemoteResume(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1045):    virtual EventHandler::Rc RaiseLocalRelease
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1047):    virtual EventHandler::Rc RaiseRemoteRelease
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1049):    virtual EventHandler::Rc RaiseReleaseCall
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1051):    virtual EventHandler::Rc RaiseApplyTreatment
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1058):    virtual EventHandler::Rc AnalyzeInformation(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1063):    virtual EventHandler::Rc RequestService(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1070):    virtual EventHandler::Rc SelectRoute(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1076):    virtual EventHandler::Rc AnalyzeNPsmTimeout
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1083):    virtual EventHandler::Rc HandleLocalAlerting();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1088):    virtual EventHandler::Rc HandleLocalAnswer();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1092):    virtual EventHandler::Rc HandleRemoteRelease(Event& currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1099):    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1105):    virtual CipMessage* BuildCipIam();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1111):    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1208):    virtual Cause::Ind VerifyRoute(RouteResult::Id rid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(465):    virtual EventHandler::Rc RaiseReleaseUser
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(467):    virtual EventHandler::Rc RaiseProxyProgress
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(469):    virtual EventHandler::Rc RaiseProxyAnswer(Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(470):    virtual EventHandler::Rc RaiseProxyRelease
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h(510):    void SetUPsm(MediaPsm& psm) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.h(54):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.h(109):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.h(64):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(102):    virtual Function* FindFunc(const std::string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(110):    virtual Function* MatchFunc(const Function* curr, bool base) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(114):    virtual CxxScoped* FindItem(const std::string& name) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(284):    virtual ClassInst* EnsureInstance(const TypeName* type);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(297):    virtual Class* BaseClass()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(302):    virtual BaseDecl* GetBaseDecl() const { return base_.get(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(341):    virtual Class* GetClassTemplate() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(356):    virtual bool DerivesFrom(const Class* cls) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(520):    bool AddAnonymousUnion(const ClassPtr& cls) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h(622):    CxxTokenVector Items() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(55):    virtual bool IsIncludeGuard() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(270):    virtual CxxToken* GetValue() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(275):    virtual bool IsDefined() const { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(281):    virtual void SetExpr(ExprPtr& rhs);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(319):    CxxToken* RootType() const override { return GetValue(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(465):    virtual bool AddElif(Elif* e) { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(469):    virtual bool AddElse(const Else* e) { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(473):    virtual bool AddEndif(const Endif* e) { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h(477):    virtual bool HasCompiledCode() const { return compile_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(126):    bool Display(ostream& stream, const string& opts) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(138):    bool Display(ostream& stream, const string& opts) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(154):    bool Display(ostream& stream, const string& opts) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(170):    bool Display(ostream& stream, const string& opts) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(198):    bool Display(ostream& stream, const string& opts) override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(58):    virtual bool IsDeclaredInFunction() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(64):    virtual void SetTemplateParms(TemplateParmsPtr& parms);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(69):    virtual TemplateParms* GetTemplateParms() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(79):    virtual std::string QualifiedName(bool scopes, bool templates)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(85):    virtual std::string ScopedName(bool templates) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(91):    virtual void GetScopedNames(stringVector& names, bool templates) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(96):    virtual Function* GetFunction() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(103):    virtual CodeFile* GetDeclFile() const { return GetFile(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(108):    virtual CodeFile* GetDefnFile() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(131):    virtual CxxScoped* DirectType() const { return Referent(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(135):    virtual void FindReferent();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(141):    virtual void SetReferent(CxxScoped* item, const SymbolView* view) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(145):    virtual void SetAsReferent(const CxxNamed* user) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(152):    virtual StackArg NameToArg(Cxx::Operator op, TypeName* name);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(157):    virtual StackArg MemberToArg
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(164):    virtual bool NamesReferToArgs(const NameVector& names,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(171):    virtual std::string ArgString(const TemplateParmToArgMap& tmap) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(177):    virtual void Instantiating(CxxScopedVector& locals) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(189):    virtual void GetDirectClasses(CxxUsageSets& symbols);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(196):    virtual void GetDirectTemplateArgs(CxxUsageSets& symbols) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(201):    virtual bool ItemIsTemplateArg(const CxxNamed* item) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(206):    virtual std::string XrefName(bool templates) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(494):    bool ResolveTypedef(Typedef* type, size_t n) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(792):    bool ResolveTemplate
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(797):    bool ResolveTypedef(Typedef* type, size_t n) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1041):    virtual Function* GetFuncSpec() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1050):    virtual TypeTags* Tags() = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1051):    virtual const TypeTags* Tags() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1055):    virtual void AddArray(ArraySpecPtr& array) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1061):    virtual TagCount Ptrs(bool arrays) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1067):    virtual TagCount Refs() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1072):    virtual TagCount Arrays() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1076):    virtual bool HasArrayDefn() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1080):    virtual void EnteringScope(const CxxScope* scope) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1084):    virtual void EnterArrays() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1089):    virtual TypeTags GetAllTags() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1094):    virtual std::string TypeTagsString(const TypeTags& tags) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1099):    virtual void DisplayTags(std::ostream& stream) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1103):    virtual void DisplayArrays(std::ostream& stream) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1109):    virtual void SetPtrs(TagCount count) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1114):    virtual bool MatchesExactly(const TypeSpec* that) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1118):    virtual void SetTemplateRole(TemplateRole role) const { role_ = role; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1122):    virtual void SetUserType(TypeSpecUser user) const { user_ = user; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1133):    virtual TypeMatch MatchTemplate(const TypeSpec* that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1140):    virtual TypeMatch MatchTemplateArg(const TypeSpec* that) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1145):    virtual std::string AlignTemplateArg(const TypeSpec* thatArg) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1149):    virtual void GetNames(stringVector& names) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(78):    virtual Cxx::Access GetCurrAccess() const { return Cxx::Private; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(83):    virtual Using* GetUsingFor(const std::string& fqName, size_t prefix,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(91):    virtual void AccessibilityOf
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(379):    virtual void Promote
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(384):    virtual bool IsUnionMember() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1366):    void CheckAccessControl() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(1370):    void CheckIfHiding() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(59):    virtual bool NameRefersToItem(const std::string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(88):    virtual void AccessibilityTo(const CxxScope* scope, SymbolView& view) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(97):    virtual void RecordAccess(Cxx::Access access) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(110):    virtual void AddFiles(LibItemSet& imSet) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(115):    virtual void UpdateReference(CxxToken* item, bool insert) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(125):    virtual bool IsUnused() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(131):    virtual bool CheckIfUnused(Warning warning) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(614):    void CheckAccessControl() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1136):    bool ResolveTemplate
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1873):    bool ResolveTypedef(Typedef* type, size_t n) const override { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(72):    virtual void Delete();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(76):    virtual void SetLoc(CodeFile* file, size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(85):    virtual void SetContext(size_t pos);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(95):    virtual void CopyContext(const CxxToken* that, bool internal);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(101):    virtual CxxToken* Clone() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(106):    virtual StackArg ResultType() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(134):    virtual Cxx::ItemType Type() const { return Cxx::Undefined; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(138):    virtual void SetScope(CxxScope* scope) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(143):    virtual CxxScope* GetScope() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(149):    virtual bool IsForward() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(153):    virtual QualName* GetQualName() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(159):    virtual std::string TypeString(bool arg) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(163):    virtual TypeSpec* GetTypeSpec() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(169):    virtual Class* DirectClass() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(173):    virtual bool IsConst() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(177):    virtual bool IsVolatile() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(181):    virtual bool IsConstPtr() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(185):    virtual bool IsVolatilePtr() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(189):    virtual bool IsConstPtr(size_t n) const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(193):    virtual bool IsVolatilePtr(size_t n) const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(201):    virtual bool IsStatic() const { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(205):    virtual bool IsExtern() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(209):    virtual void SetAccess(Cxx::Access access) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(213):    virtual Cxx::Access GetAccess() const { return Cxx::Public; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(218):    virtual bool IsAuto() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(223):    virtual bool IsIndirect(bool arrays) const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(227):    virtual void Creating() { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(232):    virtual void Instantiate() { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(236):    virtual bool IsInitializing() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(241):    virtual CxxToken* AutoType() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(246):    virtual Namespace* GetSpace() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(251):    virtual CxxArea* GetArea() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(256):    virtual Class* GetClass() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(261):    virtual CxxScope* GetMate() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(266):    virtual Class* Declarer() const { return GetClass(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(270):    virtual CxxScope* GetTemplate() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(274):    virtual const TemplateArgPtrVector* Args() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(280):    virtual TypeName* GetTemplatedName() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(284):    virtual CxxScope* GetTemplateInstance() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(293):    virtual CxxScoped* FindTemplateAnalog(const CxxToken* item) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(298):    virtual Numeric GetNumeric() const { return Numeric::Nil; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(303):    virtual void GetConvertibleTypes(StackArgVector& types, bool expl) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(307):    virtual CxxScoped* Referent() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(312):    virtual bool VerifyReferents() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(320):    virtual bool EnterScope() { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(325):    virtual void EnterBlock();
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(330):    virtual void ExitBlock() const { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(336):    virtual bool AppendUnary() { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(340):    virtual CxxToken* Back() { return this; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(345):    virtual bool WasRead() { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(357):    virtual bool WasWritten(const StackArg* arg, bool direct, bool indirect);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(362):    virtual bool SetNonConst() { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(367):    virtual void WasMutated(const StackArg* arg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(373):    virtual void RecordUsage() { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(377):    virtual void UpdateXref(bool insert) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(382):    virtual void GetUsages(const CodeFile& file, CxxUsageSets& symbols) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(399):    virtual CxxToken* PosToItem(size_t pos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(404):    virtual bool LocateItem(const CxxToken* item, size_t& n)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(410):    virtual CxxScoped* FindNthItem(const std::string& name, size_t& n)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(415):    virtual void Check() const { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(419):    virtual std::string Trace() const { return NodeBase::EMPTY_STR; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(423):    virtual CxxTokenSet* Xref() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(427):    virtual bool InLine() const { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(432):    virtual void Print
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(456):    virtual bool IsPOD() const { return GetNumeric().IsPOD(); }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(471):    virtual void UpdatePos(EditorAction action,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(698):    virtual void PushBack(uint32_t c) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.h(44):    virtual const std::string& Name() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.h(48):    virtual void Rename(const std::string& name);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.h(52):    virtual void GetDecls(CxxNamedSet& items) { }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(80):    virtual LibSetType GetType() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(86):    virtual NodeBase::word Check(NodeBase::CliThread& cli,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(93):    virtual NodeBase::word Count(std::string& result) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(99):    virtual NodeBase::word Countlines(std::string& result) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(105):    virtual NodeBase::word Fix(NodeBase::CliThread& cli,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(111):    virtual NodeBase::word Format(std::string& expl) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(119):    virtual NodeBase::word Parse
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(126):    virtual NodeBase::word Scan(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(133):    virtual NodeBase::word Sort(std::ostream& stream, std::string& expl) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(137):    virtual BuildOrder SortInBuildOrder() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(142):    virtual LibrarySet* Assign(LibrarySet* that);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(143):    virtual LibrarySet* Intersection(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(144):    virtual LibrarySet* Difference(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(145):    virtual LibrarySet* Union(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(146):    virtual LibrarySet* Directories() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(147):    virtual LibrarySet* Files() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(148):    virtual LibrarySet* FileName(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(149):    virtual LibrarySet* FileType(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(150):    virtual LibrarySet* MatchString(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(151):    virtual LibrarySet* FoundIn(const LibrarySet* that) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(152):    virtual LibrarySet* Implements() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(153):    virtual LibrarySet* UsedBy(bool self) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(154):    virtual LibrarySet* Users(bool self) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(155):    virtual LibrarySet* AffectedBy() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(156):    virtual LibrarySet* Affecters() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(157):    virtual LibrarySet* CommonAffecters() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(158):    virtual LibrarySet* NeededBy() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(159):    virtual LibrarySet* Needers() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(160):    virtual LibrarySet* DeclaredBy() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(161):    virtual LibrarySet* Declarers() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(162):    virtual LibrarySet* Definitions() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(163):    virtual LibrarySet* ReferencedBy() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(164):    virtual LibrarySet* Referencers() const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryVarSet.h(53):    void to_str(stringVector& strings, bool verbose) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(90):    virtual bool process_command_line_parameter(char token, std::string& value);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(96):    virtual std::string report_command_line_parameters();
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.h(72):    virtual std::string Name() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.h(76):    virtual bool Supports(ProtocolId prid) const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(62):    virtual void SetState(StateId stid);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(78):    virtual void Deallocate();
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(68):    virtual void SetOgPsm(MediaPsm* ogPsm);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(73):    virtual void SetOgTone(Tone::Id ogTone);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(78):    virtual void SetIcTone(Tone::Id icTone);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.h(48):    virtual bool SetMgwPsm(ProtocolSM* psm);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(75):    virtual void Display(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(93):    virtual void GetSubtended(std::vector< Base* >& objects) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(104):    virtual void ClaimBlocks();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(122):    virtual void Cleanup() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(129):    virtual void Startup(RestartLevel level) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(137):    virtual void Shutdown(RestartLevel level) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h(141):    virtual MemoryType MemType() const { return MemPermanent; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CallbackRequest.h(44):    virtual void Callback() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBoolParm.h(47):    bool CurrValue() const override { return curr_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.h(48):    bool CurrValue() const override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h(72):    virtual void Explain(std::string& expl) const { expl = expl_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(71):    virtual void Initialize();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(75):    virtual MemoryType ObjType() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(80):    virtual Object* Create();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(84):    virtual Object* GetQuasiSingleton();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(88):    virtual void FreeQuasiSingleton(Object* obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliAppData.h(63):    virtual void EventOccurred(Event event);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h(60):    virtual word ExplainCommand(std::ostream& stream, bool verbose) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h(93):    Rc GetTextParmRc(id_t& i, std::string& s, CliThread& cli) const override;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.h(75):    virtual void Enter();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.h(80):    virtual void Exit();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(143):    virtual CliParm* AccessParm(CliCookie& cookie, uint32_t depth) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(151):    virtual void Explain(std::ostream& stream, col_t indent) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(161):    virtual Rc GetIntParmRc(word& n, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(171):    virtual Rc GetBoolParmRc(bool& b, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(181):    virtual Rc GetCharParmRc(char& c, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(191):    virtual Rc GetPtrParmRc(void*& p, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(219):    virtual Rc GetTextParmRc(id_t& i, std::string& s, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(229):    virtual Rc GetStringRc(std::string& s, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(239):    virtual Rc GetFileNameRc(std::string& s, CliThread& cli) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(252):    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h(69):    virtual bool BindParm(CliParm& parm);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Exception.h(51):    virtual void Display(std::ostream& stream, const std::string& prefix) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(56):    virtual void* Addr() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(60):    virtual size_t Size() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(64):    virtual MemoryType Type() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(68):    virtual void* Alloc(size_t size) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(72):    virtual void Free(void* addr) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(77):    virtual size_t BlockToSize(const void* addr) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(82):    virtual bool Validate(const void* addr) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(86):    virtual bool CanBeProtected() const { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(93):    virtual int SetPermissions(MemoryProtection attrs);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(99):    virtual size_t CurrAvail() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h(103):    virtual size_t Overhead() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MsgBuffer.h(60):    virtual TraceStatus GetStatus() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(59):    virtual void Patch(sel_t selector, void* arguments) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(79):    virtual Class* GetClass() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(87):    virtual void PostInitialize() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(98):    virtual InstanceId GetInstanceId() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(102):    virtual Pooled* DeqBlock(size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(107):    virtual void EnqBlock(Pooled* obj, bool deleted);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(179):    virtual void DisplayStats(std::ostream& stream, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(64):    virtual uint64_t Overall() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h(68):    virtual void DisplayStat(std::ostream& stream, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.h(70):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(117):    virtual bool EnqMsg(MsgBuffer& msg);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(181):    virtual TraceStatus CalcStatus(bool dynamic) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(241):    virtual void DisplayStats(std::ostream& stream, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Tool.h(64):    virtual c_string Name() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Tool.h(68):    virtual c_string Expl() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Tool.h(74):    virtual std::string Status() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceRecord.h(83):    virtual bool Display(std::ostream& stream, const std::string& opts);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(44):    virtual NodeBase::byte_t* Bytes() = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(48):    virtual size_t Size() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(101):    virtual IpBuffer* AllocBuff(const NodeBase::byte_t* source, size_t size,
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(109):    virtual void NetworkToHost(IpBuffer& buff, NodeBase::byte_t* dest,
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(128):    virtual void ReceiveBuff
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(137):    virtual NodeBase::byte_t* HostToNetwork
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(143):    virtual void SocketFailed(SysSocket* socket) const { }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(64):    virtual IpBuffer* Clone() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(124):    virtual size_t PayloadSize() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(143):    virtual bool AddBytes
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h(106):    virtual SysTcpSocket* CreateAppSocket();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h(151):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(63):    virtual c_string Name() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(67):    virtual IpProtocol Protocol() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(71):    virtual Faction GetFaction() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(76):    virtual bool Enabled() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(80):    virtual size_t RxSize() const { return IoThread::MaxRxBuffSize; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(84):    virtual size_t TxSize() const { return IoThread::MaxTxBuffSize; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(91):    virtual CliText* CreateText() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(97):    virtual bool HasSharedSocket() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(105):    virtual void GetAppSocketSizes(size_t& rxSize, size_t& txSize) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(73):    virtual void Nullify();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(99):    virtual IpProtocol Protocol() const { return IpAny; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(128):    virtual AllocRc SetService(const IpService* service, bool shared);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(134):    virtual SendRc SendBuff(IpBuffer& buff) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(181):    virtual void Acquire();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(185):    virtual void Release();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpService.h(40):    virtual bool AcceptsConns() const { return true; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpService.h(45):    virtual size_t MaxConns() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpService.h(50):    virtual size_t MaxBacklog() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpService.h(54):    virtual bool Keepalive() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(94):    virtual PotsFeatureProfile* Subscribe
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(58):    virtual bool Activate(const PotsProfile& profile, CliThread& cli);  //d
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(63):    virtual bool Deactivate(PotsProfile& profile);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(98):    virtual ContextType Type() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(102):    virtual RootServiceSM* RootSsm() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(106):    virtual ProtocolSM* FirstPsm() const { return nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(110):    virtual void NextPsm(ProtocolSM*& psm) const { psm = nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(114):    virtual void NextPort(MsgPort*& port) const { port = nullptr; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\EventHandler.h(123):    virtual Rc ProcessEvent
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(125):    virtual NodeBase::CliText* CreateText() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(131):    virtual Message* AllocOgMsg(SignalId sid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(138):    virtual bool InjectMsg(Message& msg) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(144):    virtual Message* ReallocOgMsg(SbIpBufferPtr& buff) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(151):    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(161):    virtual bool ScreenIcMsgs(NodeBase::Q1Way< Message >& msgq);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(183):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(90):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(132):    virtual InspectRc InspectMsg(NodeBase::debug64_t& errval) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(152):    virtual void Save();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(157):    virtual void Unsave();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(165):    virtual bool Retrieve(ProtocolSM* psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(172):    virtual bool Relay(ProtocolSM& ogPsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(176):    virtual bool SendToSelf();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(233):    virtual void SetReceiver(const GlobalAddress& receiver);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(237):    virtual void SetSender(const GlobalAddress& sender);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(262):    virtual bool Send(Route route);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(266):    virtual bool Restore();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(99):    virtual void DisplayMsg(std::ostream& stream, const std::string& prefix,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(108):    virtual NodeBase::CliParm* CreateCliParm(Usage use) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(137):    virtual TestRc InjectMsg
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(150):    virtual TestRc VerifyMsg
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.h(82):    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.h(114):    virtual void DisplayMsg(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(52):    virtual MsgPort* Port() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(56):    virtual ProtocolSM* UppermostPsm() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(89):    virtual FactoryId GetFactory() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(93):    virtual Message::Route Route() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(102):    virtual NetworkBase::SysTcpSocket* CreateAppSocket();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\RootServiceSM.h(50):    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(87):    virtual NodeBase::c_string PortName(PortId pid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(117):    virtual ServiceSM* AllocModifier() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(67):    virtual ServicePortId CalcPort(const AnalyzeMsgEvent& ame) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(73):    virtual EventHandler::Rc ProcessSap(Event& currEvent, Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(79):    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(100):    virtual void SetNextState(StateId stid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(107):    virtual void PsmDeleted(const ProtocolSM& exPsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(121):    virtual void SetNextSap(TriggerId sap);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(127):    virtual void SetNextSnp(TriggerId snp);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(139):    virtual void MorphToService(ServiceId sid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Signal.h(92):    virtual NodeBase::CliText* CreateText() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmFactory.h(42):    virtual RootServiceSM* AllocRoot(const Message& msg, ProtocolSM& psm) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmFactory.h(48):    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(67):    virtual TlvParm* Wrap(const TlvMessage& msg, ParameterId pid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(191):    virtual TlvParm* AddParm(ParameterId pid, size_t plen);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(206):    virtual void DeleteParm(TlvParm& parm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(268):    void Cancel() override;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(149):    virtual EventHandler::Rc ApplyTreatment
W077 Virtual function has no overrides
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(62):    virtual void SetState(StateId stid);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(78):    virtual void Deallocate();
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(104):    virtual void EndOfTransaction();
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h(109):    virtual void ProcessIcMsg(Message& msg);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(68):    virtual void SetOgPsm(MediaPsm* ogPsm);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(73):    virtual void SetOgTone(Tone::Id ogTone);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h(78):    virtual void SetIcTone(Tone::Id icTone);
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.h(48):    virtual bool SetMgwPsm(ProtocolSM* psm);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(62):    virtual bool SetNextValue(word value);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h(114):    virtual std::string GetInput() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(71):    virtual void Initialize();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(75):    virtual MemoryType ObjType() const = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(80):    virtual Object* Create();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(84):    virtual Object* GetQuasiSingleton();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(88):    virtual void FreeQuasiSingleton(Object* obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.h(80):    virtual void Exit();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Daemon.h(148):    virtual void Recover() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(79):    virtual Class* GetClass() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(87):    virtual void PostInitialize() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(98):    virtual InstanceId GetInstanceId() const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(102):    virtual Pooled* DeqBlock(size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(107):    virtual void EnqBlock(Pooled* obj, bool deleted);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(117):    virtual bool EnqMsg(MsgBuffer& msg);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(241):    virtual void DisplayStats(std::ostream& stream, const Flags& options) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(283):    virtual MsgBuffer* DeqMsg(const msecs_t& timeout);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h(151):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(80):    virtual size_t RxSize() const { return IoThread::MaxRxBuffSize; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(84):    virtual size_t TxSize() const { return IoThread::MaxTxBuffSize; }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(181):    virtual void Acquire();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h(185):    virtual void Release();
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h(87):    virtual bool Unsubscribe(PotsProfile& profile);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(183):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(90):    virtual void DisplayStats
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(152):    virtual void Save();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(157):    virtual void Unsave();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(165):    virtual bool Retrieve(ProtocolSM* psm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(172):    virtual bool Relay(ProtocolSM& ogPsm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(176):    virtual bool SendToSelf();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(233):    virtual void SetReceiver(const GlobalAddress& receiver);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(237):    virtual void SetSender(const GlobalAddress& sender);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(266):    virtual bool Restore();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(316):    virtual void Refresh();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(329):    virtual void Handled(bool retain);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(333):    virtual bool SendFailure(NodeBase::debug64_t errval);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(341):    virtual void ClearContext() const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(237):    virtual void SetState(StateId stid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(281):    virtual Priority GetPriority() const { return NormalPriority; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(286):    virtual void MsgHandled(Message& msg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(292):    virtual void RestoreIcMsg(Message& msg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(298):    virtual void RefreshMsg(Message& msg) { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(139):    virtual void MorphToService(ServiceId sid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(77):    virtual SbIpBufferPtr Parse() = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(84):    virtual SbIpBufferPtr Build() = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(67):    virtual TlvParm* Wrap(const TlvMessage& msg, ParameterId pid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(191):    virtual TlvParm* AddParm(ParameterId pid, size_t plen);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(206):    virtual void DeleteParm(TlvParm& parm);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(270):    virtual bool MatchParm
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(276):    virtual void AddFence();
W082 Adjacent arguments have the same type
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1212):    BcFactory(Id fid, ProtocolId prid, c_string name);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(536):    void UpdatePos(EditorAction action,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.h(64):    WarningAttrs(bool fixable, bool preserve, NodeBase::c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.h(143):    void UpdatePos(EditorAction action,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(619):    SymbolView(Accessibility a, TypeMatch m, Cxx::Access c,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(287):    TypeMatch CalcMatchWith(const StackArg& that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(342):    TypeMatch MatchWith(const StackArg& that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxLocation.h(76):    void UpdatePos(EditorAction action, size_t begin, size_t count, size_t from);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(378):    TypeMatch MatchTemplate(const TypeName* that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(682):    TypeMatch MatchTemplate(const QualName* that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(893):    bool SetPointer(size_t n, bool readonly, bool unstable);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1133):    virtual TypeMatch MatchTemplate(const TypeSpec* that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1568):    TypeMatch MatchTemplate(const TemplateArg* that, stringVector& tmpltParms,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(185): static TypeMatch MatchTemplate(const string& thisType,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(379):    virtual void Promote
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(236):    bool GetBracedSpan(size_t& begin, size_t& left, size_t& end) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h(1788):    Using(QualNamePtr& name, bool space, bool added = false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.h(59):    bool GetSeqSpan(size_t begin, size_t& left, size_t& end) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.h(64):    bool GetParSpan(size_t& begin, size_t& left, size_t& end) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp(40): static size_t FindTemplateBegin(const string& name, size_t pos, size_t depth);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.h(53):    size_t rfind_first_not_of(const std::string& str,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.h(139):    size_t CompareScopes
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.h(182):    size_t Replace(std::string& code, const std::string& s1,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(47): static bool GetSpanFailure(size_t& begin, size_t& left, size_t& end)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(126):    bool GetSpan3(size_t& begin, size_t& left, size_t& end) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(357):    virtual bool WasWritten(const StackArg* arg, bool direct, bool indirect);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(471):    virtual void UpdatePos(EditorAction action,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(502):    virtual bool GetSpan(size_t& begin, size_t& left, size_t& end) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h(871):    Function* FindNewOrDelete(const StackArg& arg, bool del, bool& pod) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(579): static void DebugFtNames(const Function* func, string& flit, string& fvar)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(949): static bool ItemIsUsedBetween(const CxxToken* item, size_t begin, size_t end)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1006): static void Rename(string& code, const string& oldName, const string& newName)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(106):    void Rename(size_t pos, const string& oldName, const string& newName);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(262):    bool AdjustHorizontally(size_t pos, size_t len, const string& spacing);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(298):    word InsertForward(size_t pos, const string& nspace, const string& forward);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(303):    word InsertNamespaceForward(size_t pos,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(320):    static void ChangeForwards
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(367):    void FindFreeItemPos(const Namespace* space, const string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(377):    CxxItemVector FindDeclRange
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(506):    void UpdateItemDefnAttrs(const CxxToken* prev,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(512):    word UpdateItemDefnLoc(const CxxToken* prev,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(567):    bool GetSpan(const CxxToken* item, size_t& begin, size_t& end);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(595):    size_t Replace(size_t pos, size_t count, const string& code);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(642):    void UpdatePos(EditorAction action,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(257):    size_t FindClosing(char lhc, char rhc, size_t pos = std::string::npos) const;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(578):    LineType CalcLineType(size_t n, bool& cont, bool& c_comment);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h(656):    void SetDepth(int depth1, int depth2, bool merge = true);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(74):    NodeBase::word Import
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(108):    NodeBase::word Assign(CliThread& cli, const std::string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(137):    NodeBase::word Rename(CliThread& cli, const std::string& oldName,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(71): static bool SetCompoundType
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.h(482):    bool GetParExpr(ExprPtr& expr, bool omit, bool opt = false);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\SetOperations.h(33):    void SetDifference
  C:\Users\Greg\Documents\rsc\rsc\src\ct\SetOperations.h(42):    void SetIntersection
  C:\Users\Greg\Documents\rsc\rsc\src\ct\SetOperations.h(51):    void SetUnion
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(143):    void send_press_to_server(const TokenMessage& press_to,
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(272):    virtual void process_not_ccd_message(const TokenMessage& message,
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(501):    virtual void report_failed_press
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(187):    bool set_support_to_move_order
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(189):    bool set_convoy_order(ProvinceId unit, ProvinceId client, ProvinceId dest);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(190):    bool set_move_by_convoy_order(ProvinceId unit,
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(192):    bool set_move_by_single_step_convoy_order
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(271):    Location find_result_unit_initial_location(ProvinceId province,
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(398):    bool has_route_to_province(const UnitOrder& unit, ProvinceId province,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.h(64):    Alarm(c_string name, c_string expl, uint32_t delay);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.h(51):    uint64_t pack3(uint16_t a, uint16_t b, uint16_t c);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.h(55):    uint64_t pack4(uint16_t a, uint16_t b, uint16_t c, uint16_t d);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.h(63):    size_t round_to_2_exp_n(size_t n, size_t e, bool up);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.h(48):    CfgBitParm(c_string key, c_string def, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBoolParm.h(39):    CfgBoolParm(c_string key, c_string def, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.h(39):    CfgFlagParm(c_string key, c_string def,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h(39):    CfgIntParm(c_string key, c_string def, word min, word max, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h(94):    CfgParm(c_string key, c_string def, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgStrParm.h(40):    CfgStrParm(c_string key, c_string def, c_string expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCharParm.h(40):    CliCharParm(c_string help, c_string chars,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h(103):    CliCommand(c_string comm, c_string help, uint32_t size = 32);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.h(59):    CliCommandSet(c_string comm, c_string help, uint32_t size = 32);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.h(102):    CliIncrement(c_string name, c_string help, uint32_t size = 32);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIntParm.h(45):    CliIntParm(c_string help, word min, word max,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(246):    bool GetIdentifier(std::string& s, CliThread& cli,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h(252):    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h(49):    CliText(c_string help, c_string text, bool opt = false, uint32_t size = 32);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(99):    char CharPrompt(const std::string& prompt,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(106):    word IntPrompt(const std::string& prompt, word min, word max);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(251):    void Report1
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.h(63):    static void Spool(const std::string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.h(99):    int strCompare
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.h(111):    std::string strCenter(const std::string& s, size_t breadth, size_t blanks);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbCliParms.h(123): CliParm::Rc GetCBV(const CliCommand& comm, CliThread& cli, bool& c, bool& v);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbCliParms.h(129): bool ValidateOptions
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(242):    bool BidToIndices(PooledObjectId bid, size_t& i, size_t& j) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(247):    bool IndicesToBid(size_t i, size_t j, PooledObjectId& bid) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.h(105):    PosixSignal(signal_t value, c_string name,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SymbolRegistry.h(59):    bool BindSymbol
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.h(96):    static bool ReportError(fn_name function, fixed_string expl, int error);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(92):    static const char* GetFileLoc(DWORD64 frame, DWORD& line, DWORD& disp);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(644):    void DisplaySummary(std::ostream& stream,
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.cpp(60): static void CheckHigh(FunctionStats*& high,
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(201):    static word Sort(const string& input, const string& output, string& expl);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(55):    IpBuffer(NodeBase::MsgDirection dir, size_t header, size_t payload);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceCfg.h(43):    IpServiceCfg(c_string key, c_string def, c_string expl, IpService* service);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h(79):    SysIpL3Addr
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h(107):    PotsFeature(Id fid, bool deactivation, c_string abbr, c_string name);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(132):    void TraceMsg(ProtocolId prid, SignalId sid, NodeBase::MsgDirection dir);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(168):    void RecordMsg(bool incoming, bool inter, size_t size) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\GlobalAddress.h(51):    GlobalAddress
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.h(94):    Initiator(ServiceId sid, ServiceId aid, TriggerId tid, Priority prio);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(68): static void DisplayEvent(ostream& stream, ServiceId sid, EventId eid)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(174):    static BuffTrace* NextIcMsg
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTracer.h(136):    NodeBase::TraceRc SelectSignal
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTracer.h(190):       SignalFilter(ProtocolId p, SignalId s, NodeBase::TraceStatus ts);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(181):    explicit Service(Id sid, bool modifiable = false, bool modifier = false);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmFactory.h(56):    SsmFactory(Id fid, ProtocolId prid, NodeBase::c_string name);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(104):    template< class T > T* CopyType
  C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.h(78):    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(354):    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
W088 Argument could be const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(507/4):       const CxxToken* item, const CxxToken* next, ItemDefnAttrs& attrs) const;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(59/2):    virtual void Patch(sel_t selector, void* arguments) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(90/1):    bool Enq(T& elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(114/1):    bool Henq(T& elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(136/1):    bool Insert(T* prev, T& elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(171/1):    bool Exq(T& elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(328/1):    void Corrupt(T* elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(150/1):    bool Exq(T& elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(277/1):    bool Erase(T& item)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h(138/1):       (IpBuffer& buff, NodeBase::byte_t* src, size_t size) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(288/1):    bool ProcessMsg(NodeBase::Q1Way< Message >& msgq, const InvokerThread* inv);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(161/1):    virtual bool ScreenIcMsgs(NodeBase::Q1Way< Message >& msgq);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.h(108/2):       (const ServiceSM& parentSsm, Event& currEvent, Event*& nextEvent) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(132/1):    virtual InspectRc InspectMsg(NodeBase::debug64_t& errval) const;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(206/1):    virtual void DeleteParm(TlvParm& parm);
W090 Function could be const
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1111):    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1167):    CipMessage* BuildCipRel(Cause::Ind cause);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(152):    void InsertClass(Class* cls);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(153):    void InsertData(Data* data);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(154):    void InsertEtor(Enumerator* etor);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(155):    void InsertEnum(Enum* item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(156):    void InsertForw(Forward* forw);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(157):    void InsertFriend(Friend* frnd);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(158):    void InsertFunc(Function* func);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(159):    void InsertMacro(Macro* macro);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(160):    void InsertSpace(Namespace* space);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(161):    void InsertTerm(Terminal* term);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(162):    void InsertType(Typedef* type);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(166):    void EraseClass(const Class* cls);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(167):    void EraseData(const Data* data);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(168):    void EraseEtor(const Enumerator* etor);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(169):    void EraseEnum(const Enum* item);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(170):    void EraseForw(const Forward* forw);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(171):    void EraseFriend(const Friend* frnd);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(172):    void EraseFunc(const Function* func);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(173):    void EraseMacro(const Macro* macro);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(174):    void EraseSpace(const Namespace* space);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(175):    void EraseTerm(const Terminal* term);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(176):    void EraseType(const Typedef* type);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(80):    CodeFile* EnsureFile(const std::string& file, CodeDir* dir = nullptr);
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(108):    NodeBase::word Assign(CliThread& cli, const std::string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(125):    NodeBase::word Purge(const std::string& name, std::string& expl);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(205):    virtual void process_ccd_message
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(211):    virtual void process_drw_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(242):    virtual void process_out_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(250):    virtual void process_smr_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(267):    virtual void process_adm_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(272):    virtual void process_not_ccd_message(const TokenMessage& message,
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(466):    virtual void process_hlo_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(471):    virtual void process_map_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(475):    virtual void process_mdf_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(483):    virtual void process_sco_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(487):    virtual void process_now_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(491):    virtual void process_slo_message(const TokenMessage& message);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.h(113):    void SetStatus(AlarmStatus status);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CallbackRequest.h(44):    virtual void Callback() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(71):    virtual void Initialize();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(88):    virtual void FreeQuasiSingleton(Object* obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(137):    virtual Object* New(size_t size);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(150):    bool SetTemplate(Object& obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h(158):    bool SetQuasiSingleton(Object& obj);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h(89):    virtual void EventHasOccurred(Event event) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.h(114):    void SetInterval(uint8_t interval);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.h(171):    void SetState(index_t index, BlockState state);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(59):    virtual void Patch(sel_t selector, void* arguments) { }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(189):    bool Corrupt(size_t n);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h(255):    void UpdateAlarm();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(150):    bool Exq(T& elem)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsRegistry.h(77):    void StartInterval(bool first);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.h(161):    DelayRc Suspend(Gate& gate, const msecs_t& timeout);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(125):    bool Interrupt(const Flags& mask = NoFlags);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(168):    void SetStatus(TraceStatus status);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(277):    void SetInitialized();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(418):    void Reset(FlagId fid);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(422):    void Ready();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(426):    void Preempt();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(445):    void Proceed();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(484):    void UpdateMutex(SysMutex* mutex);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(492):    void UpdateMutexCount(bool acquired);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(544):    bool LogTrap(const Exception* ex,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(592):    void SetTrap(bool on);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(600):    void StackCheck();
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(604):    void SetSignal(signal_t sig);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceRecord.h(105):    virtual void ClaimBlocks() { }
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.h(84):    FunctionStats* EnsureRecord(fn_name_arg func, size_t count);
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtTestData.h(81):    void Reset();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h(189):    virtual IoThread* CreateIoThread();
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(152):    virtual IpPort* CreatePort(ipport_t pid) = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.h(62):    void ReleaseResources();
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureRegistry.h(66):    void Audit();
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h(108):    void SetState(const ProtocolSM* psm, State state);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h(118):    bool SetObjAddr(const MsgPort& port);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(158):    bool StopTimer(const Base& owner, TimerId tid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(192):    virtual void EndOfTransaction() { }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(161):    virtual bool ScreenIcMsgs(NodeBase::Q1Way< Message >& msgq);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(257):    virtual Rc ReceiveMsg
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(149):    void KickThread();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(153):    Context* FindWork();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(172):    void Requeue(Context& ctx);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h(180):    void ScheduledOut();
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(110):    void SetSignal(SignalId sid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(114):    void SetJoin(bool join);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(225):    void SetProtocol(ProtocolId prid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(229):    void SetPriority(MsgPriority prio);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(233):    virtual void SetReceiver(const GlobalAddress& receiver);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(237):    virtual void SetSender(const GlobalAddress& sender);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h(358):    void SetRxAddr(const LocalAddress& rxaddr);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(167):    virtual Message* UnwrapMsg(Message& msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h(174):    virtual Message* WrapMsg(Message& msg);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h(116):    void StopTimer(const Base& owner, TimerId tid);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(186):    virtual EventHandler::Rc ProcessInitNack
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(235):    EventHandler::Rc ProcessSsmqSap
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h(246):    void ProcessSsmqSnp(ServiceSM* modifier, Event& snpEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(77):    virtual SbIpBufferPtr Parse() = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h(84):    virtual SbIpBufferPtr Build() = 0;
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(265):    void UpdateTestPsm();
W092 Function could be free
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.h(88):    static void DisplayStateCounts // AnIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h(175):    static bool IsValidDigit(Digit d) // DigitString.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1115):    static void DisplayStateCounts // AnIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1120):    static void ResetStateCounts(RestartLevel level); // CbModule.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(358):    const stringVector& Prolog() const; // CodeFile.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(463):    static void UpdateOperator(Cxx::Operator& oper, size_t args); // CxxScope.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(743):    static bool AtFileScope(); // CxxToken.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(758):    static Cxx::Access ScopeVisibility(); // CxxArea.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(816):    static void WasCalled(Function* func); // CxxScope.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(850):    static bool ParsingTemplate(); // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(858):    static void PushXrefFrame(XrefUpdater updater); // CxxScope.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(862):    static void PopXrefFrame(); // CxxScope.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(870):    static void PushXrefItem(TypeName* item); // CxxNamed.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(874):    static TypeName* FindXrefItem(const std::string& name); // CxxScoped.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(884):    static void Trace(CxxTrace::Action act, const CxxToken* token); // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(885):    static void Trace(CxxTrace::Action act, const StackArg& arg); // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(886):    static void Trace(CxxTrace::Action act, const CodeFile& file); // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(887):    static void Trace(CxxTrace::Action act, NodeBase::word err, // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(892):    static void InsertTracepoint // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(897):    static void EraseTracepoint // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(902):    static void ClearTracepoints(); // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(917):    static void DisplayTracepoints // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h(939):    static void Startup(NodeBase::RestartLevel level) { } // CtModule.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(177):    static void AddUsing(Using* use); // CxxScoped.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(182):    static void RemoveUsing(const Using* use); // CxxScoped.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(186):    static void ResetUsings(); // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h(2032):    TypeSpec* Clone() const override; // CxxScope.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(118):    static size_t CommitCount(); // CodeFileSet.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(154):    static void ReportFix(const CodeWarning* log, word rc); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(170):    word ChangeCast(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(171):    word ChangeClassToNamespace(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(174):    word ChangeOperator(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(179):    word EraseCast(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(180):    word EraseClass(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(193):    word InsertCopyCtorCall(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(194):    word InsertDataInit(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(196):    word InsertDisplay(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(197):    word InsertEnumName(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(198):    word InsertFallthrough(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(203):    word InsertMemberInit(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(205):    word InsertPODCtor(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(206):    word InsertPureVirtual(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(208):    word MoveDefine(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(209):    word MoveMemberInit(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(213):    word ReplaceHeading(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(214):    word ReplaceName(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(359):    static void QualifyClassItems // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(418):    word FixInvokers(const CodeWarning& log); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(427):    word ChangeFunctionToMember(const Function* func, word offset); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(428):    word ChangeInvokerToMember(const Function* func, word offset); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(429):    word EraseArgument(const Function* func, word offset); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(430):    word EraseDefaultValue(const Function* func, word offset); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(431):    word EraseParameter(const Function* func, word offset); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(433):    word InsertArgument(const Function* func, word offset); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h(434):    word SplitVirtualFunction(const Function* func); // Editor.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.h(74):    static bool IsOperator(const std::string& s); // Library.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(137):    NodeBase::word Rename(CliThread& cli, const std::string& oldName, // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.h(171):    static void ResetStats(); // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.h(175):    static void DisplayStats(std::ostream& stream); // CtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.h(602):    static bool Backup(size_t cause); // Parser.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.h(629):    static std::string Indent(); // Parser.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(178):    void cancel_event(BotEvent event); // BaseBot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(523):    static void report_ccd(const Token& power, bool disorder); // BaseBot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(543):    static void report_out(const Token& power); // BaseBot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(555):    void report_exit(c_string reason); // BaseBot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h(715):    static bool send_buff(DipIpBuffer& buff); // BaseBot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(162):    static MapAndUnits* create_clone(); // MapAndUnits.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(166):    static void delete_clone(MapAndUnits*& clone); // MapAndUnits.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h(259):    std::string display_retreat_result(const UnitOrder& unit) const; // BaseBot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.h(74):    static bool IsValidPort(PortId pid) // Circuit.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\mb\ToneRegistry.h(54):    static Switch::PortId ToneToPort(Tone::Id tid); // MediaPsm.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.h(92):    static const std::string& ValidValueChars(); // CfgParmRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.h(97):    static const std::string& ValidBlankChars(); // CfgParmRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CoutThread.h(48):    static void Spool(c_string s, bool eol = false); // CoutThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.h(105):    static void SetSwFlag(FlagId fid, bool value); // NtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.h(109):    static void ResetSwFlags(); // NtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.h(113):    static Flags GetSwFlags(); // NtIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.h(117):    static void noop(debug64_t info = 0); // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Element.h(50):    static bool IsUnnamed(); // ModuleRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.h(45):    static ostringstreamPtr CreateStream(); // CliThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.h(58):    static void Spool(const std::string& name, ostringstreamPtr& stream, // FileThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.h(63):    static void Spool(const std::string& name, // FileThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.h(72):    static void Truncate(const std::string& name); // NbIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.h(124):    static Log* Find(c_string log); // Log.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.h(132):    static size_t Count(); // NbIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogThread.h(67):    static void Spool(const std::string& str, const Log* log); // Log.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MainArgs.h(61):    static void PushBack(const std::string& arg); // main.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.h(91):    void SetLevel(RestartLevel level); // InitThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.h(95):    static RestartLevel GetLevel(); // RootThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.h(99):    static RestartLevel NextLevel(); // ModuleRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h(110):    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid); // Object.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PermanentHeap.h(41):    static PermanentHeap* Instance(); // Memory.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\RootThread.h(48):    static main_t Main(); // main.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.h(96):    static bool ReportError(fn_name function, fixed_string expl, int error); // SysThread.win.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.h(101):    static void ConfigureProcess(); // RootThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(226):    static double PercentIdle(); // NbIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(410):    static main_t EnterThread(void* arg); // Thread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(637):    static void EnableFactions(const FactionFlags& enabled); // ModuleRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(653):    static TraceRc LogContextSwitches(bool on); // NbIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(661):    static void DisplayContextSwitches(std::ostream& stream); // NbIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.h(105):    void QueryTools(std::ostream& stream) const; // NbIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.h(111):    static TcpIoDaemon* GetDaemon(const TcpIpService* service, ipport_t port); // TcpIpPort.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.h(138):    static UdpIoDaemon* GetDaemon(const UdpIpService* service, ipport_t port); // UdpIpPort.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h(113):    static const SysIpL2Addr& NullIpAddr(); // SysIpL2Addr.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(156):    static NodeBase::c_string AlarmName(nwerr_t errval); // NwLogs.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(161):    static bool StartLayer(); // NwModule.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h(166):    static void StopLayer(); // NwModule.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(138):    static void DisplayStateCounts // AnIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(147):    static void ResetStateCounts(RestartLevel level); // PotsProfileRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(84):    static RootServiceSM* ContextRoot(); // Event.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(120):    static void Kill(NodeBase::debug64_t errval, NodeBase::debug64_t offset); // Context.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(125):    static void Dump(NodeBase::fn_name_arg func, // Context.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.h(70):    static bool AppCanHandle(Id eid) // State.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\EventHandler.h(92):    static bool AppCanRegister(Id ehid) // Service.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\EventHandler.h(100):    static bool AppCanUse(Id ehid) // State.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.h(168):    static MsgPort* FindPeer(const GlobalAddress& remAddr); // PsmFactory.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h(155):    static NodeBase::c_string ExplainRc(TestRc rc); // StIncrement.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbDaemons.h(43):    static InvokerDaemon* GetDaemon(NodeBase::Faction faction, size_t size); // InvokerPool.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h(79):    static bool IsValidPortId(PortId pid) // State.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvParameter.h(68):    static Id ExtractPid(const TlvParm& parm); // TlvParameter.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Trigger.h(80):    static bool IsValidId(Id tid) // ServiceSM.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h(113):    static TestPsm* Find(const MsgPort& port); // TestSessions.cpp
W099 Line contains adjacent spaces
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(65):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(66):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(67):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(68):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(70):    CauseInfo*    cci;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(120):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(121):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(122):    auto       sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(123):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(161):    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(162):    auto       msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(163):    auto       sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(164):    auto&      bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(191):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(192):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(193):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(194):    auto&         bcssm = static_cast< BcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp(196):    CauseInfo*    cci;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(461):    id_t        idx;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(462):    word        fid, rid;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(464):    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(491):    TestRc       rc;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(492):    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(494):    id_t         idx;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(495):    word         fid, rid;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(788):    auto          state = GetState();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(789):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(790):    auto          sig = tmsg.GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(791):    TimeoutInfo*  toi = nullptr;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(793):    auto          err = true;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(794):    debug64_t     error;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(918):    auto          state = GetState();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(919):    auto&         tmsg = static_cast< TlvMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(920):    auto          sig = msg.GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(922):    auto          err = true;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(923):    debug64_t     error;
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(359):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(360):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(361):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(362):    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(364):    CauseInfo*    cci;
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(400):    CxxWord("D",   "D",    "D",  F),  // ALIGNAS
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(401):    CxxWord("@",   "@",    "@",  T),  // ASM
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(402):    CxxWord("-",   "-",    "D",  F),  // AUTO
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(403):    CxxWord("-",   "-",    "b",  T),  // BREAK
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(404):    CxxWord("-",   "-",    "c",  T),  // CASE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(405):    CxxWord("C",   "C",    "-",  T),  // CLASS
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(406):    CxxWord("DP",  "DP",   "D",  F),  // CONST
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(407):    CxxWord("DP",  "DP",   "D",  F),  // CONSTEXPR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(408):    CxxWord("-",   "-",    "n",  T),  // CONTINUE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(409):    CxxWord("-",   "-",    "o",  T),  // DEFAULT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(410):    CxxWord("-",   "-",    "d",  T),  // DO
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(411):    CxxWord("E",   "E",    "E",  T),  // ENUM
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(412):    CxxWord("-",   "P",    "-",  F),  // EXPLICIT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(413):    CxxWord("DP",  "-",    "-",  F),  // EXTERN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(414):    CxxWord("-",   "-",    "-",  F),  // FINAL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(415):    CxxWord("-",   "-",    "f",  T),  // FOR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(416):    CxxWord("-",   "F",    "-",  T),  // FRIEND
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(417):    CxxWord("-",   "-",    "g",  T),  // GOTO
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(418):    CxxWord("H",   "H",    "H",  F),  // HASH
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(419):    CxxWord("-",   "-",    "i",  T),  // IF
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(420):    CxxWord("P",   "P",    "-",  F),  // INLINE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(421):    CxxWord("-",   "D",    "-",  F),  // MUTABLE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(422):    CxxWord("N",   "-",    "-",  T),  // NAMESPACE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(423):    CxxWord("-",   "P",    "-",  F),  // OPERATOR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(424):    CxxWord("-",   "-",    "-",  F),  // OVERRIDE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(425):    CxxWord("-",   "A",    "-",  T),  // PRIVATE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(426):    CxxWord("-",   "A",    "-",  T),  // PROTECTED
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(427):    CxxWord("-",   "A",    "-",  T),  // PUBLIC
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(428):    CxxWord("-",   "-",    "r",  T),  // RETURN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(429):    CxxWord("DP",  "DP",   "D",  F),  // STATIC
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(430):    CxxWord("$",   "$",    "$",  T),  // STATIC_ASSERT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(431):    CxxWord("C",   "C",    "-",  T),  // STRUCT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(432):    CxxWord("-",   "-",    "s",  T),  // SWITCH
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(433):    CxxWord("DCP", "DCFP", "-",  F),  // TEMPLATE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(434):    CxxWord("D",   "D",    "D",  F),  // THREAD_LOCAL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(435):    CxxWord("-",   "-",    "t",  T),  // TRY
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(436):    CxxWord("T",   "T",    "T",  T),  // TYPEDEF
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(437):    CxxWord("C",   "C",    "-",  T),  // UNION
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(438):    CxxWord("U",   "U",    "U",  T),  // USING
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(439):    CxxWord("-",   "P",    "-",  F),  // VIRTUAL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(440):    CxxWord("DP",  "DP",   "D",  F),  // VOLATILE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(441):    CxxWord("-",   "-",    "w",  T),  // WHILE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(442):    CxxWord("-",   "P",    "-",  F),  // NVDTOR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(443):    CxxWord("DP",  "DP",   "xD", F)   // NIL_KEYWORD
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(471):    CxxOp(           SCOPE_STR, 2, 18, F, F, F, XN),  // SCOPE_RESOLUTION
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(472):    CxxOp(                 ".", 2, 17, F, F, F, NN),  // REFERENCE_SELECT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(473):    CxxOp(                "->", 2, 17, T, F, F, NN),  // POINTER_SELECT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(474):    CxxOp(                 "[", 2, 17, T, F, F, NN),  // ARRAY_SUBSCRIPT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(475):    CxxOp(                 "(", 0, 17, F, F, F, NN),  // FUNCTION_CALL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(476):    CxxOp(                "++", 1, 17, T, F, F, NX),  // POSTFIX_INCREMENT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(477):    CxxOp(                "--", 1, 17, T, F, F, NX),  // POSTFIX_DECREMENT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(478):    CxxOp(         DEFINED_STR, 1, 17, F, F, F, XN),  // DEFINED
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(479):    CxxOp(          TYPEID_STR, 1, 17, F, F, F, XN),  // TYPE_NAME
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(480):    CxxOp(      CONST_CAST_STR, 2, 17, F, F, F, XN),  // CONST_CAST
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(481):    CxxOp(    DYNAMIC_CAST_STR, 2, 17, F, F, F, XN),  // DYNAMIC_CAST
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(483):    CxxOp(     STATIC_CAST_STR, 2, 17, F, F, F, XN),  // STATIC_CAST
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(484):    CxxOp(          SIZEOF_STR, 1, 16, F, T, F, XN),  // SIZEOF_TYPE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(485):    CxxOp(         ALIGNOF_STR, 1, 16, F, T, F, XN),  // ALIGNOF_TYPE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(486):    CxxOp(        NOEXCEPT_STR, 1, 16, F, T, F, XN),  // NOEXCEPT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(487):    CxxOp(                "++", 1, 16, T, T, F, XN),  // PREFIX_INCREMENT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(488):    CxxOp(                "--", 1, 16, T, T, F, XN),  // PREFIX_DECREMENT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(489):    CxxOp(                 "~", 1, 16, T, T, F, XN),  // ONES_COMPLEMENT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(490):    CxxOp(                 "!", 1, 16, T, T, F, XN),  // LOGICAL_NOT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(491):    CxxOp(                 "+", 1, 16, T, T, F, XN),  // UNARY_PLUS
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(492):    CxxOp(                 "-", 1, 16, T, T, F, XN),  // UNARY_MINUS
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(493):    CxxOp(                 "&", 1, 16, T, T, F, XN),  // ADDRESS_OF
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(494):    CxxOp(                 "*", 1, 16, T, T, F, XN),  // INDIRECTION
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(495):    CxxOp(             NEW_STR, 0, 16, T, T, F, XX),  // OBJECT_CREATE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(496):    CxxOp(       NEW_ARRAY_STR, 0, 16, T, T, F, XX),  // OBJECT_CREATE_ARRAY
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(497):    CxxOp(          DELETE_STR, 1, 16, T, T, F, XX),  // OBJECT_DELETE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(498):    CxxOp(    DELETE_ARRAY_STR, 1, 16, T, T, F, XX),  // OBJECT_DELETE_ARRAY
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(499):    CxxOp(                 "(", 2, 16, T, T, F, SN),  // CAST
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(500):    CxxOp(                ".*", 2, 15, F, F, F, NN),  // REFERENCE_SELECT_MEMBER
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(501):    CxxOp(               "->*", 2, 15, T, F, F, NN),  // POINTER_SELECT_MEMBER
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(502):    CxxOp(                 "*", 2, 14, T, F, T, SS),  // MULTIPLY
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(503):    CxxOp(                 "/", 2, 14, T, F, F, SS),  // DIVIDE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(504):    CxxOp(                 "%", 2, 14, T, F, F, SS),  // MODULO
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(505):    CxxOp(                 "+", 2, 13, T, F, T, SS),  // ADD
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(506):    CxxOp(                 "-", 2, 13, T, F, F, SS),  // SUBTRACT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(507):    CxxOp(                "<<", 2, 12, T, F, F, SS),  // LEFT_SHIFT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(508):    CxxOp(                ">>", 2, 12, T, F, F, SS),  // RIGHT_SHIFT
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(509):    CxxOp(                 "<", 2, 11, T, F, T, SS),  // LESS
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(510):    CxxOp(                "<=", 2, 11, T, F, T, SS),  // LESS_OR_EQUAL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(511):    CxxOp(                 ">", 2, 11, T, F, T, SS),  // GREATER
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(512):    CxxOp(                ">=", 2, 11, T, F, T, SS),  // GREATER_OR_EQUAL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(513):    CxxOp(                "==", 2, 10, T, F, T, SS),  // EQUALITY
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(514):    CxxOp(                "!=", 2, 10, T, F, T, SS),  // INEQUALITY
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(515):    CxxOp(                 "&", 2,  9, T, F, T, SS),  // BITWISE_AND
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(516):    CxxOp(                 "^", 2,  8, T, F, T, SS),  // BITWISE_XOR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(517):    CxxOp(                 "|", 2,  7, T, F, T, SS),  // BITWISE_OR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(518):    CxxOp(                "&&", 2,  6, T, F, T, SS),  // LOGICAL_AND
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(519):    CxxOp(                "||", 2,  5, T, F, T, SS),  // LOGICAL_OR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(520):    CxxOp(                 "?", 3,  4, F, F, F, SS),  // CONDITIONAL
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(521):    CxxOp(                 "=", 2,  3, T, T, F, SS),  // ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(522):    CxxOp(                "*=", 2,  3, T, T, F, SS),  // MULTIPLY_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(523):    CxxOp(                "/=", 2,  3, T, T, F, SS),  // DIVIDE_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(524):    CxxOp(                "%=", 2,  3, T, T, F, SS),  // MODULO_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(525):    CxxOp(                "+=", 2,  3, T, T, F, SS),  // ADD_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(526):    CxxOp(                "-=", 2,  3, T, T, F, SS),  // SUBTRACT_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(527):    CxxOp(               "<<=", 2,  3, T, T, F, SS),  // LEFT_SHIFT_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(528):    CxxOp(               ">>=", 2,  3, T, T, F, SS),  // RIGHT_SHIFT_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(529):    CxxOp(                "&=", 2,  3, T, T, F, SS),  // BITWISE_AND_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(530):    CxxOp(                "^=", 2,  3, T, T, F, SS),  // BITWISE_XOR_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(531):    CxxOp(                "|=", 2,  3, T, T, F, SS),  // BITWISE_OR_ASSIGN
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(532):    CxxOp(           THROW_STR, 0,  2, F, T, F, SS),  // THROW
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(533):    CxxOp(                 ",", 2,  1, F, F, F, NS),  // STATEMENT_SEPARATOR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(534):    CxxOp(                 "$", 0,  0, F, F, F, XX),  // START_OF_EXPRESSION
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(535):    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX),  // FALSE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(536):    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX),  // TRUE
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(537):    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX),  // NULLPTR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(538):    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX)   // NIL_OPERATOR
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(90):    OperatorInfo(" ",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpNil
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(91):    OperatorInfo("(",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpLeftPar
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(92):    OperatorInfo(")",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpRightPar
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(93):    OperatorInfo("&",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpIntersection
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(94):    OperatorInfo("-",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpDifference
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(95):    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpUnion
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(96):    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpAutoUnion
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(97):    OperatorInfo("d",  1, DIR_SET,  ANY_SET,  ERR_SET),   // OpDirectories
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(98):    OperatorInfo("f",  1, FILE_SET, ANY_SET,  ERR_SET),   // OpFiles
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(111):    OperatorInfo("db", 1, ITEM_SET, ANY_SET,  ERR_SET),   // OpDeclaredBy
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(114):    OperatorInfo("rb", 1, ITEM_SET, ANY_SET,  ERR_SET),   // OpReferencedBy
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(208):    inline static fn_name Array_ctor()    { return "Array.ctor"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(209):    inline static fn_name Array_dtor()    { return "Array.dtor"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h(210):    inline static fn_name Array_Init()    { return "Array.Init"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(669):                case Split:     c = 'S'; break;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(670):                case Merged:    c = 'm'; break;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(169):    CounterPtr      allocCount_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(170):    CounterPtr      freeCount_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(171):    CounterPtr      failCount_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(172):    CounterPtr      auditCount_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(173):    CounterPtr      expansions_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(389):    inline static fn_name Q1Way_dtor()    { return "Q1Way.dtor"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(390):    inline static fn_name Q1Way_Init()    { return "Q1Way.Init"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(391):    inline static fn_name Q1Way_Enq()     { return "Q1Way.Enq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(392):    inline static fn_name Q1Way_Henq()    { return "Q1Way.Henq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(393):    inline static fn_name Q1Way_Insert()  { return "Q1Way.Insert"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(394):    inline static fn_name Q1Way_Deq()     { return "Q1Way.Deq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(395):    inline static fn_name Q1Way_Exq()     { return "Q1Way.Exq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(396):    inline static fn_name Q1Way_Next()    { return "Q1Way.Next"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(397):    inline static fn_name Q1Way_Size()    { return "Q1Way.Size"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(398):    inline static fn_name Q1Way_Purge()   { return "Q1Way.Purge"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h(400):    inline static fn_name Q1Way_Item()    { return "Q1Way.Item"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(366):    inline static fn_name Q2Way_dtor()  { return "Q2Way.dtor"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(367):    inline static fn_name Q2Way_Init()  { return "Q2Way.Init"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(368):    inline static fn_name Q2Way_Enq()   { return "Q2Way.Enq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(369):    inline static fn_name Q2Way_Henq()  { return "Q2Way.Henq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(370):    inline static fn_name Q2Way_Deq()   { return "Q2Way.Deq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(371):    inline static fn_name Q2Way_Exq()   { return "Q2Way.Exq"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(372):    inline static fn_name Q2Way_Next()  { return "Q2Way.Next"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(373):    inline static fn_name Q2Way_Prev()  { return "Q2Way.Prev"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(374):    inline static fn_name Q2Way_Size()  { return "Q2Way.Size"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h(376):    inline static fn_name Q2Way_Item()  { return "Q2Way.Item"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(626):    inline static fn_name Registry_ctor()   { return "Registry.ctor"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(627):    inline static fn_name Registry_dtor()   { return "Registry.dtor"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(628):    inline static fn_name Registry_Init()   { return "Registry.Init"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(630):    inline static fn_name Registry_Erase()  { return "Registry.Erase"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(631):    inline static fn_name Registry_Next()   { return "Registry.Next"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(632):    inline static fn_name Registry_Prev()   { return "Registry.Prev"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(633):    inline static fn_name Registry_Size()   { return "Registry.Size"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(634):    inline static fn_name Registry_Empty()  { return "Registry.Empty"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(635):    inline static fn_name Registry_Purge()  { return "Registry.Purge"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h(636):    inline static fn_name Registry_Cell()   { return "Registry.Cell"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Singleton.h(129):    inline static fn_name Singleton_Destroy()  { return "Singleton.Destroy"; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(275):    CounterPtr       traps_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(276):    CounterPtr       exceeds_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(277):    CounterPtr       yields_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(278):    CounterPtr       interrupts_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(282):    AccumulatorPtr   totTime_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(182):    CfgIntParmPtr  initTimeoutMsecs_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(183):    CfgIntParmPtr  schedTimeoutMsecs_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(185):    CfgIntParmPtr  rtcTimeoutMsecs_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(187):    CfgIntParmPtr  rtcLimit_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(188):    CfgIntParmPtr  rtcInterval_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(190):    CfgIntParmPtr  trapLimit_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(191):    CfgIntParmPtr  trapInterval_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(193):    CfgIntParmPtr  stackUsageLimit_;
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h(194):    CfgIntParmPtr  stackCheckInterval_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(60):    CounterPtr       recvs_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(61):    AccumulatorPtr   bytesRcvd_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(64):    CounterPtr       discards_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(65):    CounterPtr       rejects_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(66):    CounterPtr       sends_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(67):    AccumulatorPtr   bytesSent_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(69):    CounterPtr       overflows_;
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTypes.h(60):       uint8_t  u8[16];  // bytes: [12-15] overlay IPv4Addr
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(463):    id_t             index;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(464):    word             sid, ind;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(466):    auto&            pmsg = static_cast< PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(522):    TestRc            rc;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(523):    auto&             pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(525):    id_t              index;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(526):    word              sid, ind;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(645):    word           port;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(647):    auto&          pmsg = static_cast< PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(670):    TestRc          rc;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(671):    auto&           pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(672):    word            port;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(758):    TestRc        rc;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(759):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(761):    bool          ring = false;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(762):    auto          exists = false;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(840):    TestRc        rc;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(841):    auto&         pmsg = static_cast< const PotsMessage& >(msg);
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(843):    string        scan;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(844):    auto          digits = false;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(845):    auto          flash = false;
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp(846):    auto          exists = false;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(53):    CounterPtr       icMsgsIntra_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(54):    CounterPtr       icMsgsInter_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(56):    CounterPtr       ogMsgsIntra_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(57):    CounterPtr       ogMsgsInter_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(59):    CounterPtr       contexts_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(60):    CounterPtr       msgsDeleted_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(61):    CounterPtr       ctxsDeleted_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(120):    CounterPtr       requeues_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(121):    CounterPtr       trojans_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(122):    CounterPtr       lockouts_;
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(42):    LocalAddress   txAddr;         // source address
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(43):    LocalAddress   rxAddr;         // destination address
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(44):    MsgPriority    priority : 2;   // message's priority
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(45):    bool           initial  : 1;   // true for initial message
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(46):    bool           final    : 1;   // true for final message
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(47):    bool           join     : 1;   // true to create PSM and join root SSM
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(48):    bool           self     : 1;   // true for message to self
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(49):    bool           injected : 1;   // true if sent by InjectCommand
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(50):    bool           kill     : 1;   // true to kill context on arrival
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(51):    uint8_t        spare    : 6;   // reserved for future use
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(52):    Message::Route route    : 2;   // the route that the message took
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(53):    ProtocolId     protocol : 16;  // message's protocol
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(54):    SignalId       signal   : 16;  // message's signal
  C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h(55):    uint16_t       length   : 16;  // total bytes in all parameters
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(132):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(133):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(134):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(135):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(137):    CauseInfo*    cci;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(236):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(237):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(238):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(239):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(241):    CauseInfo*    cci;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(300):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(301):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(302):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(303):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(305):    CauseInfo*    cci;
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(346):    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(347):    auto          msg = static_cast< CipMessage* >(ame.Msg());
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(348):    auto          sid = msg->GetSignal();
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(349):    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp(351):    CauseInfo*    cci;
W102 Line length exceeds the standard maximum
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp(285):    for(auto s = BcState::AuthorizingOrigination; s <= BcState::OrigAlerting; ++s)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(3177): "Alloc  Min kB     kB       Bytes                            Memory        Prot\n"
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(3178): "Fails   Avail  Avail      In Use     Allocs      Frees        Type  RWX  Chngs";
W106 Function does not invoke Debug::ft
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(1351): void PotsTrafficThread::RecordHoldingTime(const nsecs_t& time)
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(225): bool CipUdpService::Enabled() const
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp(301): bool CipTcpService::Enabled() const
  C:\Users\Greg\Documents\rsc\rsc\src\cb\DigitString.cpp(146): Digit DigitString::At(DigitCount i) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1083): void CodeFile::EraseClass(const Class* cls)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1091): void CodeFile::EraseData(const Data* data)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1099): void CodeFile::EraseEnum(const Enum* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1107): void CodeFile::EraseForw(const Forward* forw)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1115): void CodeFile::EraseFunc(const Function* func)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1157): void CodeFile::EraseItem(const CxxToken* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1171): void CodeFile::EraseSpace(const SpaceDefn* space)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1179): void CodeFile::EraseType(const Typedef* type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1187): void CodeFile::EraseUsing(const Using* use)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1552): void CodeFile::GetLineCounts() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1762): void CodeFile::InsertAsm(Asm* code)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1770): void CodeFile::InsertClass(Class* cls)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1778): void CodeFile::InsertData(Data* data)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1786): bool CodeFile::InsertDirective(DirectivePtr& dir)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1795): void CodeFile::InsertEnum(Enum* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1803): void CodeFile::InsertForw(Forward* forw)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1811): void CodeFile::InsertFunc(Function* func)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1819): void CodeFile::InsertInclude(IncludePtr& incl)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1862): void CodeFile::InsertItem(CxxToken* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1887): void CodeFile::InsertMacro(Macro* macro)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1895): void CodeFile::InsertSpace(SpaceDefn* space)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1903): void CodeFile::InsertStaticAssert(StaticAssert* assert)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1911): void CodeFile::InsertType(Typedef* type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(1919): void CodeFile::InsertUsing(Using* use)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp(93): static bool IsSortedByFileLevel(const FileLevel& item1, const FileLevel& item2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(55): void CodeItemSet::CopyItems(const CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp(67): void CodeItemSet::CopyUsages(const CxxUsageSets& usages)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeTypes.cpp(406): size_t IndentSize()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeTypes.cpp(413): bool IsAccessControl(const std::string& s)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeTypes.cpp(426): size_t LineLengthMax()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(343): bool CodeWarning::HasCodeToDisplay() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(350): bool CodeWarning::HasInfoToDisplay() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(812): bool CodeWarning::IsInformational() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(819): bool CodeWarning::IsSortedByFile
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(838): bool CodeWarning::IsSortedByType
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(857): bool CodeWarning::IsSortedToFix
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(876): void CodeWarning::ItemDeleted(const CxxToken* item) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(886): size_t CodeWarning::Line() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(954): bool CodeWarning::Preserve() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(981): bool CodeWarning::Suppress() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp(1243): bool CodeWarning::WasResolved() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(89): Cxx::Access FindAccessControl(const std::string& s)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(810): static void EraseTemplateArgs
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(842): static void Union(CxxNamedSet& lhs, const CxxNamedSet& rhs)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(852): void CxxUsageSets::AddBase(CxxNamed* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(860): void CxxUsageSets::AddDirect(CxxNamed* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(868): void CxxUsageSets::AddForward(CxxNamed* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(879): void CxxUsageSets::AddIndirect(CxxNamed* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(887): void CxxUsageSets::AddInherit(CxxNamed* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp(895): void CxxUsageSets::AddUser(CxxNamed* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(69): static TypeMatch FindMin(const std::vector< TypeMatch >& matches)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1558): Class* Class::GetClassTemplate() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1594): Cxx::Access Class::GetCurrAccess() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1611): void Class::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(1722): CxxScope* Class::GetTemplate() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(2196): Class* Class::OuterClass() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(3308): const FunctionPtrVector* CxxArea::FuncVector(const string& name) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(3326): void CxxArea::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(3366): void CxxArea::InsertFunc(Function* func)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(46): static void AlignLeft(ostream& stream, const string& prefix)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(58): bool IncludesAreSorted(const IncludePtr& incl1, const IncludePtr& incl2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(193): CxxToken* Define::AutoType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(936): bool Macro::WasRead()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp(974): CxxScope* MacroName::GetScope() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(59): static bool CompilingTemplateFunction()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(335): TypeName* Context::FindXrefItem(const string& name)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(347): const Parser* Context::GetParser()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(355): XrefUpdater Context::GetXrefUpdater()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(384): void Context::OnLine(size_t line, Phase phase)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(419): bool Context::OptionIsOn(char opt)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(447): bool Context::ParsingSourceCode()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(455): bool Context::ParsingTemplate()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(468): bool Context::ParsingTemplateInstance()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(493): void Context::PopXrefFrame()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(511): void Context::PushScope(CxxScope* scope, bool hidden)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(520): void Context::PushXrefFrame(XrefUpdater updater)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(527): void Context::PushXrefItem(TypeName* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(549): CxxScope* Context::Scope()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(600): void Context::SetOptions(const std::string& opts)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(643): void Context::SetPos(size_t pos)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(658): void Context::SetPos(const CxxLocation& loc)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1079): OptionalCode* ParseFrame::Optional() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1270): CxxScope* ParseFrame::Scope() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1277): Cxx::Access ParseFrame::ScopeAccess() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1284): Cxx::Access ParseFrame::SetAccess(Cxx::Access access)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(1688): bool StackArg::IsBool() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2394): TypeName* XrefFrame::FindItem(const string& name) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2406): void XrefFrame::PushItem(TypeName* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxLocation.cpp(41): void CxxLocation::SetLoc(CodeFile* file, size_t pos)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxLocation.cpp(49): void CxxLocation::SetLoc(CodeFile* file, size_t pos, bool internal)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(204): CxxArea* CxxNamed::GetArea() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(213): Class* CxxNamed::GetClass() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(244): CodeFile* CxxNamed::GetDistinctDeclFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(259): CodeFile* CxxNamed::GetImplFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(268): void CxxNamed::GetScopedNames(stringVector& names, bool templates) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(275): Namespace* CxxNamed::GetSpace() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(284): void CxxNamed::Instantiating(CxxScopedVector& locals) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(633): void CxxNamed::strName(ostream& stream, bool fq, const QualName* name) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(766): const TemplateArgPtrVector* DataSpec::Args() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1020): TypeTags DataSpec::GetAllTags() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1088): TypeSpec* DataSpec::GetTypeSpec() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1225): bool DataSpec::IsAutoDecl() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1292): bool DataSpec::IsPOD() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(1651): CxxScoped* DataSpec::Referent() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2008): bool DataSpec::VerifyReferents() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2082): const TemplateArgPtrVector* QualName::Args() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2134): TypeName* QualName::At(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2342): CxxScope* QualName::GetScope() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2373): TypeName* QualName::GetTemplatedName() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2461): TypeName* QualName::Last() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2683): size_t QualName::Size() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2745): bool QualName::VerifyReferents() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2977): CxxScoped* TemplateArg::GetReferent() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3297): bool TemplateArg::VerifyReferents() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3381): const TemplateArgPtrVector* TypeName::Args() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3440): CxxScoped* TypeName::DirectType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3537): TypeName* TypeName::GetTemplatedName() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(3772): void TypeName::PushBack(TypeNamePtr& type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4074): bool TypeName::VerifyReferents() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4354): int TypeTags::IsConstPtr() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4363): bool TypeTags::IsConstPtr(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4372): int TypeTags::IsVolatilePtr() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4381): bool TypeTags::IsVolatilePtr(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(4421): TagCount TypeTags::PtrCount(bool arrays) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(114): bool FuncDefnsAreSorted(const Function* func1, const Function* func2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(146): FunctionVector FuncsInArea(const FunctionVector& defns, const CxxArea* area)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(267): bool Block::CrlfOver(Form form) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(408): CxxToken* Block::FirstStatement() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(416): Function* Block::GetFunction() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(876): void ClassData::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(985): void ClassData::SetMemInit(const MemberInit* init)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1520): CodeFile* Data::GetDeclFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1527): const Data* Data::GetDefn() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1536): CodeFile* Data::GetDefnFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1579): TypeName* Data::GetTemplatedName() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1728): bool Data::IsConst() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(1885): bool Data::WasRead()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2246): const TemplateArgPtrVector* FuncSpec::Args() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2271): TypeSpec* FuncSpec::Clone() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2293): void FuncSpec::EnterArrays() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2310): void FuncSpec::FindReferent()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2318): TypeTags FuncSpec::GetAllTags() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2325): void FuncSpec::GetNames(stringVector& names) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2333): TypeName* FuncSpec::GetTemplatedName() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2340): TypeSpec* FuncSpec::GetTypeSpec() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2347): bool FuncSpec::HasArrayDefn() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2354): void FuncSpec::Instantiating(CxxScopedVector& locals) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2362): bool FuncSpec::ItemIsTemplateArg(const CxxNamed* item) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2370): bool FuncSpec::MatchesExactly(const TypeSpec* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2378): TypeMatch FuncSpec::MatchTemplate(const TypeSpec* that,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2388): TypeMatch FuncSpec::MatchTemplateArg(const TypeSpec* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2396): bool FuncSpec::NamesReferToArgs(const NameVector& names,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2422): TagCount FuncSpec::Ptrs(bool arrays) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2429): TagCount FuncSpec::Refs() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2463): void FuncSpec::SetReferent(CxxScoped* item, const SymbolView* view) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2471): const TypeTags* FuncSpec::Tags() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2478): TypeTags* FuncSpec::Tags()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(2879): uint32_t Function::CalcHash() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4500): FunctionRole Function::FuncRole() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4537): FunctionType Function::FuncType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4548): Cxx::Access Function::GetAccess() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4556): CodeFile* Function::GetDeclFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4563): void Function::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4570): const Function* Function::GetDefn() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4579): Function* Function::GetDefn()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4588): CodeFile* Function::GetDefnFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4597): CxxScope* Function::GetScope() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4625): CxxScope* Function::GetTemplate() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4636): CxxScope* Function::GetTemplateInstance() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(4644): TemplateType Function::GetTemplateType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5153): bool Function::IsImplemented() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5376): size_t Function::LogOffsetToArgIndex(word offset) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(6083): bool Function::WasRead()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(6288): void SpaceData::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(6374): void SpaceDefn::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(454): Class* BaseDecl::GetClass() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(578): void CxxScoped::AddFiles(LibItemSet& imSet) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(806): bool CxxScoped::IsAuto() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(815): bool CxxScoped::IsClassMember() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(829): bool CxxScoped::IsConst() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(838): bool CxxScoped::IsConstPtr() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(847): bool CxxScoped::IsConstPtr(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(856): bool CxxScoped::IsDeclaredInFunction() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(864): bool CxxScoped::IsDefinedIn(const CxxArea* area) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(877): bool CxxScoped::IsIndirect(bool arrays) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1141): void CxxScoped::UpdateReference(CxxToken* item, bool insert) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1198): CxxTokenVector CxxScoped::XrefItems() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1433): void Enum::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1454): TypeSpec* Enum::GetTypeSpec() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1693): void Enumerator::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1871): CxxToken* Forward::AutoType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(1953): void Forward::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2101): CxxToken* Friend::AutoType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2373): void Friend::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2390): Function* Friend::GetFunction() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2399): QualName* Friend::GetQualName() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2408): CxxScoped* Friend::GetReferent() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2842): CxxScoped* MemberInit::Referent() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2900): CxxToken* TemplateParm::AutoType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(2994): CxxScoped* TemplateParm::Referent() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3007): CxxToken* TemplateParm::RootType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3300): const TemplateArgPtrVector* Typedef::Args() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3458): void Typedef::GetDecls(CxxNamedSet& items)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3474): TypeName* Typedef::GetTemplatedName() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3489): void Typedef::Instantiating(CxxScopedVector& locals) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3607): bool Typedef::VerifyReferents() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.cpp(377): void CxxStatement::EnterBlock()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(251): template< typename T > void GetSymbols
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(263): static bool IsSortedByScope(const CxxScoped* item1, const CxxScoped* item2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(276): static bool IsSortedForXref(const CxxScoped* item1, const CxxScoped* item2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(415): void CxxSymbols::EraseClass(const Class* cls)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(422): void CxxSymbols::EraseData(const Data* data)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(429): void CxxSymbols::EraseEnum(const Enum* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(436): void CxxSymbols::EraseEtor(const Enumerator* etor)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(443): void CxxSymbols::EraseForw(const Forward* forw)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(450): void CxxSymbols::EraseFriend(const Friend* frnd)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(457): void CxxSymbols::EraseFunc(const Function* func)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(464): void CxxSymbols::EraseMacro(const Macro* macro)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(471): void CxxSymbols::EraseSpace(const Namespace* space)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(478): void CxxSymbols::EraseTerm(const Terminal* term)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(485): void CxxSymbols::EraseType(const Typedef* type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(822): void CxxSymbols::FindTerminal(const string& name, SymbolVector& list) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(829): void CxxSymbols::InsertClass(Class* cls)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(836): void CxxSymbols::InsertData(Data* data)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(843): void CxxSymbols::InsertEnum(Enum* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(850): void CxxSymbols::InsertEtor(Enumerator* etor)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(857): void CxxSymbols::InsertForw(Forward* forw)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(864): void CxxSymbols::InsertFriend(Friend* frnd)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(871): void CxxSymbols::InsertFunc(Function* func)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(878): void CxxSymbols::InsertMacro(Macro* macro)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(885): void CxxSymbols::InsertSpace(Namespace* space)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(892): void CxxSymbols::InsertTerm(Terminal* term)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp(899): void CxxSymbols::InsertType(Typedef* type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(258): template< typename T > void EraseSymbol(const CxxScoped* item,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(278): template< typename T > void ListSymbols(const std::string& name,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(59): bool IsSortedByFilePos(const CxxToken* item1, const CxxToken* item2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(90): bool IsSortedByPos(const CxxToken* item1, const CxxToken* item2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(701): CxxScope* CxxToken::GetTemplateInstance() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(710): bool CxxToken::IsInTemplateInstance() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(717): bool CxxToken::IsPointer(bool arrays) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(909): bool CxxToken::VerifyReferents() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1382): Numeric FloatLiteral::GetNumeric() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1441): Numeric IntLiteral::BaseNumeric() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1587): CxxToken* Literal::AutoType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1619): CxxToken* Literal::RootType() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(1635): Cxx::ItemType Literal::Type() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxVector.h(47): template< typename T > size_t IndexOf
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxVector.h(62): template< class T > void SortAndDisplayItems
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxVector.h(91): template< class T > void SortAndDisplayItemPtrs
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxVector.h(125): template< class T > void EraseItem(std::vector< T* >& vec, const T* item)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxVector.h(149): template< class T > void EraseItemPtr
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1990): size_t Editor::CommitCount() { return Commits_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4857): static FunctionRole WarningToRole(Warning log)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(133): const OperatorInfo* OperatorInfo::GetAttrs(LibTokenType type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(141): bool OperatorInfo::GetType(const string& op, LibTokenType& type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(87): static IndentRule ClassifyIndent(string& id)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(810): word Lexer::CheckDepth(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(860): int Lexer::CheckLineMerge(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1285): size_t Lexer::CurrBegin(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1311): size_t Lexer::CurrEnd(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2095): const LineInfo* Lexer::GetLineInfo(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2104): LineInfo* Lexer::GetLineInfo(size_t pos)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2113): size_t Lexer::GetLineNum(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2137): size_t Lexer::GetLineStart(size_t line) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2214): bool Lexer::GetNthLine(size_t n, string& s) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2727): bool Lexer::LineHasTrailingCommentAt(size_t n, size_t offset) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2809): size_t Lexer::LineSize(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2852): size_t Lexer::NextBegin(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2967): size_t Lexer::NextPos(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3209): size_t Lexer::PrevBegin(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3285): void Lexer::SetDepth(int depth1, int depth2, bool merge)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.cpp(34): bool IsSortedByName(const LibraryItem* item1, const LibraryItem* item2)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.cpp(78): bool LibItemSort::operator()
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(97): LibrarySet* LibrarySet::AffectedBy() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(104): LibrarySet* LibrarySet::Affecters() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(111): LibrarySet* LibrarySet::Assign(LibrarySet* that)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(128): LibrarySet* LibrarySet::CommonAffecters() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(169): LibrarySet* LibrarySet::Create
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(177): LibrarySet* LibrarySet::DeclaredBy() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(184): LibrarySet* LibrarySet::Declarers() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(191): LibrarySet* LibrarySet::Definitions() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(198): LibrarySet* LibrarySet::Difference(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(205): LibrarySet* LibrarySet::Directories() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(230): LibrarySet* LibrarySet::FileName(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(237): LibrarySet* LibrarySet::Files() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(244): LibrarySet* LibrarySet::FileType(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(269): LibrarySet* LibrarySet::FoundIn(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(288): LibrarySet* LibrarySet::Implements() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(295): LibrarySet* LibrarySet::Intersection(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(302): bool LibrarySet::IsReadOnly() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(309): bool LibrarySet::IsTemporary() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(341): LibrarySet* LibrarySet::MatchString(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(348): LibrarySet* LibrarySet::NeededBy() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(355): LibrarySet* LibrarySet::Needers() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(372): word LibrarySet::NotImplemented(string& expl) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(384): LibrarySet* LibrarySet::OpError(c_string op) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(412): LibrarySet* LibrarySet::ReferencedBy() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(419): LibrarySet* LibrarySet::Referencers() const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(516): LibrarySet* LibrarySet::Union(const LibrarySet* that) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(523): LibrarySet* LibrarySet::UsedBy(bool self) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp(530): LibrarySet* LibrarySet::Users(bool self) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(301): size_t Parser::CurrPos() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(431): BaseBot::StartupResult BaseBot::initialise(const StartupParameters& parameters)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(438): BaseBot* BaseBot::instance()
  C:\Users\Greg\Documents\rsc\rsc\src\dip\ConvoySubversion.cpp(29): void ConvoySubversion::clear()  // <b>
  C:\Users\Greg\Documents\rsc\rsc\src\dip\ConvoySubversion.cpp(37): void ConvoySubversion::decrement()
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(282): bool MapAndUnits::can_move_to(const UnitOrder& unit, const Location& dest) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(300): bool MapAndUnits::can_move_to_province
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(562): TokenMessage MapAndUnits::encode_location(const Location& location) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(839): TokenMessage MapAndUnits::encode_unit(const UnitOrder& unit) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(1146): const LocationSet* MapAndUnits::get_neighbours(const Location& location) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(1385): MapAndUnits* MapAndUnits::instance()
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(2452): Token MapAndUnits::province_token(ProvinceId province) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp(2571): bool MapAndUnits::set_move_by_single_step_convoy_order
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(32): Token::Token(const category_t cat, const subtoken_t sub)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(40): Token& Token::operator=(const Token& that)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(48): int Token::get_number() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(57): bool Token::is_number() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(64): bool Token::is_power() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(71): bool Token::is_province() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(118): Token::SeasonType Token::order_season() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(129): PowerId Token::power_id() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(137): ProvinceId Token::province_id() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(260): Token power_token(PowerId power)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(273): Token province_token(ProvinceId province)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.cpp(36): static void copy_tokens(Token* dest, const Token* source, int num)
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.cpp(161): Token TokenMessage::at(size_t index) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.cpp(168): void TokenMessage::clear()
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.cpp(295): Token TokenMessage::front() const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.cpp(354): Token TokenMessage::operator[](size_t index) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenTextMap.cpp(328): TokenTextMap* TokenTextMap::instance()
  C:\Users\Greg\Documents\rsc\rsc\src\dip\WinterOrders.cpp(37): size_t WinterOrders::get_number_of_results() const
  C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.cpp(234): MediaPsm* MediaPsm::GetOgPsm() const
  C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.cpp(85): Circuit* Switch::GetCircuit(PortId pid) const
  C:\Users\Greg\Documents\rsc\rsc\src\mb\ToneRegistry.cpp(77): Tone* ToneRegistry::GetTone(Tone::Id tid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.cpp(203): AlarmStatus Alarm::Status() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp(90): void Base::Nullify(size_t n)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp(154): Base::vptr_t Base::Vptr() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.cpp(88): void CfgBitParm::Explain(string& expl) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.cpp(55): bool CfgFlagParm::CurrValue() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.cpp(74): bool CfgFlagParm::NextValue() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.cpp(68): void CfgIntParm::Explain(string& expl) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParmRegistry.cpp(347): void CfgParmRegistry::ListParms(ostream& stream, const string& prefix) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgStrParm.cpp(60): void CfgStrParm::Explain(string& expl) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CinThread.cpp(65): void CinThread::ClearClient(const Thread* client)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ClassRegistry.cpp(89): Class* ClassRegistry::Lookup(ClassId cid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliBuffer.cpp(618): bool CliBuffer::ReadingFromFile() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCookie.cpp(118): uint32_t CliCookie::Index(uint32_t depth) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(57): void Debug::Assert(bool condition, debug64_t errval)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(73): void Debug::ft(fn_name_arg func) NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(81): void Debug::ftnt(fn_name_arg func) NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Element.cpp(199): bool Element::RunningInLab()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(191): CtorChain::CtorChain(FunctionTrace* inner) :
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(208): bool CtorChain::AddToPreviousChain(FunctionTrace* ctor)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(261): CtorChain::Action CtorChain::CalcAction
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(329): TraceRecord* CtorChain::CheckForEndOfChains(const FunctionTrace* curr)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(348): bool CtorChain::CheckForInitializer(const FunctionTrace* curr)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(391): bool CtorChain::FunctionEndsChain(const FunctionTrace* curr) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(409): TraceRecord* CtorChain::HandleCtor(FunctionTrace* ctor)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(458): void CtorChain::HandleFunction(FunctionTrace* func)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(485): void CtorChain::MoveOuterAboveInit()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(499): void CtorChain::MoveOuterAboveInner() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp(512): void CtorChain::SetOuter(FunctionTrace* outer)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.cpp(157): void Heap::Freeing(void* addr, size_t size)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.cpp(173): bool Heap::IsFixedSize() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.cpp(229): void Heap::Requested(size_t size, void* addr)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\InitFlags.cpp(28): bool InitFlags::AllowBreak()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\InitFlags.cpp(39): bool InitFlags::CauseTimeout()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\InitFlags.cpp(48): bool InitFlags::SuspendRoot()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\InitFlags.cpp(55): bool InitFlags::TraceInit()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.cpp(142): size_t Log::Count()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(501): void LogBuffer::UpdateMax()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.cpp(182): void LogGroup::SetSuppressed(bool suppressed)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroupRegistry.cpp(190): LogGroup* LogGroupRegistry::Group(id_t gid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MainArgs.cpp(142): size_t MainArgs::Size()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(172): static Heap* EnsureHeap(MemoryType type)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(189): Heap* Memory::AccessHeap(MemoryType type)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(208): size_t Memory::Align(size_t size, size_t log2align)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(387): bool Memory::Protect(MemoryType type)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(468): bool Memory::Unprotect(MemoryType type)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp(499): size_t Memory::Words(size_t size)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.cpp(64): static const FactionFlags& AllFactions()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.cpp(106): static const FactionFlags& ShutdownFactions()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.cpp(197): RestartLevel ModuleRegistry::GetLevel()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.cpp(204): Module* ModuleRegistry::GetModule(ModuleId mid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MsgBuffer.cpp(63): TraceStatus MsgBuffer::GetStatus() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbCliParms.cpp(123): word ExplainTraceRc(const CliThread& cli, TraceRc rc)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(128): static NbHeap::index_t IndexToChild(NbHeap::index_t index)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(137): static NbHeap::index_t IndexToParent(NbHeap::index_t index)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(146): static NbHeap::index_t IndexToSibling(NbHeap::index_t index)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(157): static size_t Log2Size(NbHeap::level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(166): static size_t LevelToSize(NbHeap::level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(175): static NbHeap::level_t SizeToLevel(size_t size)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(272): bool NbHeap::AddrIsValid(const void* addr, bool header) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(314): HeapBlock* NbHeap::AllocBlock(level_t level, size_t size)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(346): NbHeap::index_t NbHeap::BlockToIndex
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(413): NbHeap::BlockState NbHeap::Corrupt(int reason, bool restart) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(595): HeapBlock* NbHeap::Dequeue(level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(701): void NbHeap::EnqBlock(HeapBlock* block, index_t index, level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(710): HeapBlock* NbHeap::Enqueue(HeapBlock* block, level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(753): void NbHeap::FreeBlock(HeapBlock* block, level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(772): NbHeap::BlockState NbHeap::GetState(index_t index) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(788): HeapBlock* NbHeap::IndexToBlock(index_t index, level_t level) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(801): size_t NbHeap::Overhead() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(815): void NbHeap::ReleaseBlock(HeapBlock* block, level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(831): void NbHeap::ReserveBlock(const HeapBlock* block)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(844): void NbHeap::SetState(index_t index, BlockState state)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(860): void NbHeap::SplitAncestors(index_t block)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(908): NbHeap::BlockState NbHeap::ValidateBlock
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTracer.cpp(188): TraceStatus NbTracer::FactionStatus(Faction faction) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.cpp(75): char BlockingReasonChar(BlockingReason reason)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.cpp(98): char FactionChar(Faction faction)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.cpp(59): Object::ClassId Object::GetClassId() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.cpp(70): bool Object::GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.cpp(95): Object::ObjectId Object::GetObjectId() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(84): static ObjectBlock* ObjToBlock(const Pooled* obj)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(351): size_t ObjectPool::AllocCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(518): size_t ObjectPool::AvailCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(525): bool ObjectPool::BidToIndices(PooledObjectId bid, size_t& i, size_t& j) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(741): void ObjectPool::EnqBlock(Pooled* obj, bool deleted)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(836): size_t ObjectPool::Expansions() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(843): size_t ObjectPool::FailCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(884): size_t ObjectPool::FreeCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(891): bool ObjectPool::IndicesToBid(size_t i, size_t j, PooledObjectId& bid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(903): size_t ObjectPool::InUseCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(910): size_t ObjectPool::LowAvailCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(917): ObjectBlock* ObjectPool::Next(PooledObjectId& bid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(936): Pooled* ObjectPool::NextUsed(PooledObjectId& bid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(1008): ObjectPoolId ObjectPool::ObjPid(const Pooled* obj)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(1017): PooledObjectSeqNo ObjectPool::ObjSeq(const Pooled* obj)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPoolRegistry.cpp(280): ObjectPool* ObjectPoolRegistry::Pool(ObjectPoolId pid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PermanentHeap.cpp(43): PermanentHeap* PermanentHeap::Instance()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(124): Flags PS_Break()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(129): Flags PS_Delayed()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(134): Flags PS_Final()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(139): Flags PS_Interrupt()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(144): Flags PS_Native()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(149): Flags PS_NoError()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp(154): Flags PS_NoLog()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignalRegistry.cpp(58): Flags PosixSignalRegistry::Attrs(signal_t value) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignalRegistry.cpp(89): PosixSignal* PosixSignalRegistry::Find(signal_t value) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignalRegistry.cpp(101): PosixSignal* PosixSignalRegistry::Find(const string& name) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignalRegistry.cpp(153): signal_t PosixSignalRegistry::Value(const string& name) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Link.cpp(40): Q2Link::~Q2Link()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\RegCell.cpp(38): RegCell::~RegCell()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\RegCell.cpp(50): void RegCell::SetId(id_t cid)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Restart.cpp(38): bool Restart::ClearsMemory(MemoryType type)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Restart.cpp(69): RestartLevel Restart::LevelToClear(MemoryType type)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\RootThread.cpp(61): static Gate& ExitGate()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Singletons.cpp(126): Singletons* Singletons::Instance()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.cpp(117): uint64_t Statistic::Overall() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.cpp(248): uint64_t HighWatermark::Overall() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.cpp(320): uint64_t LowWatermark::Overall() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsRegistry.cpp(131): StatisticsGroup* StatisticsRegistry::GetGroup(id_t gid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysConsole.cpp(33): std::istream& SysConsole::In()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysConsole.cpp(40): ostream& SysConsole::Out()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysFile.cpp(68): size_t SysFile::FindExt(const string& name, const string& ext)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysHeap.win.cpp(107): void* SysHeap::Addr() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysHeap.win.cpp(142): bool SysHeap::CanBeProtected() const { return false; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysHeap.win.cpp(190): size_t SysHeap::Overhead() const { return 0; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.cpp(38): SysLock::~SysLock()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.cpp(48): void SysLock::Acquire()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.cpp(65): void SysLock::Release()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.win.cpp(50): static DWORD GetMemoryProtection(MemoryProtection attrs)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMutex.cpp(125): Thread* SysMutex::Owner() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.cpp(105): bool SysThread::ReportError(fn_name function, fixed_string expl, int error)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(49): static signal_t AccessViolationType(const _EXCEPTION_POINTERS* ex)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(219): void SysThread::RegisterForSignal(signal_t sig, sighandler_t handler)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(226): SysThreadId SysThread::RunningThreadId() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(122): fn_depth StackInfo::GetFrames(StackFramesPtr& frames)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(147): void StackInfo::Shutdown()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(156): DWORD StackInfo::Startup()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(270): fn_depth SysThreadStack::FuncDepth()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp(315): bool SysThreadStack::TrapIsOk() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.cpp(37): static uintptr_t BadPointer()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(32): bool ThisThread::EnterBlockingOperation(BlockingReason why, fn_name_arg func)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(39): void ThisThread::ExitBlockingOperation(fn_name_arg func)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(46): void ThisThread::IncludeInTrace()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(53): DelayRc ThisThread::Pause(const msecs_t& timeout)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(60): void ThisThread::PauseOver(word limit)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(67): word ThisThread::RtcPercentUsed()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(74): ThreadId ThisThread::RunningThreadId()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(81): TraceRc ThisThread::StartTracing(const string& opts)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp(88): void ThisThread::StopTracing()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(89): static std::map< SysThreadId, std::atomic_flag >& AccessFtLocks() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(100): static std::atomic_flag& AccessFtLock() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(122): static void EraseFtLock() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(455): ContextSwitch* ContextSwitches::AddSwitch()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1091): static bool ClearActiveThread(Thread* active)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1217): Thread* Thread::ActiveThread() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1227): SysMutex* Thread::BlockingMutex() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1234): TraceStatus Thread::CalcStatus(bool dynamic) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1252): bool Thread::CanBeScheduled() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1690): void Thread::ExitIfSafe(debug64_t offset) NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1778): Thread* Thread::FindRunningThread() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1802): void Thread::FunctionInvoked(fn_name_arg func) NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1846): void Thread::FunctionInvoked(fn_name_arg func, const std::nothrow_t&) NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1864): BlockingReason Thread::GetBlockingReason() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1871): signal_t Thread::GetSignal() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1878): TraceStatus Thread::GetStatus() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2039): bool Thread::IsLocked() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2046): bool Thread::IsScheduled() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2053): bool Thread::IsTraceable() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2109): Thread* Thread::LockedThread()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2171): TraceRc Thread::LogContextSwitches(bool on)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2349): uint8_t Thread::MutexCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2356): SysThreadId Thread::NativeThreadId() const NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2373): DelayRc Thread::Pause(msecs_t time)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2419): double Thread::PercentIdle()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2710): void Thread::ResetDebugFlags()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2804): Thread* Thread::RunningThread() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2830): Thread* Thread::RunningThread(const std::nothrow_t&) NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2884): void Thread::SetStatus(TraceStatus status)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2987): void Thread::StackCheck() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3302): TraceRc Thread::StartTracing(const string& opts)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3334): void Thread::StopTracing()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3503): bool Thread::TraceRunningThread(Thread*& thr)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3531): bool Thread::TraceRunningThread(Thread*& thr, const std::nothrow_t&)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3558): void Thread::TrapCheck() NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3764): void Thread::UpdateMutex(SysMutex* mutex)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3771): void Thread::UpdateMutexCount(bool acquired)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(205): static ThreadAdmin* AccessAdminData()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(291): bool ThreadAdmin::BreakEnabled()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(367): void ThreadAdmin::Incr(Register r)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(454): bool ThreadAdmin::ReinitOnSchedTimeout()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(462): word ThreadAdmin::RtcInterval()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(470): word ThreadAdmin::RtcLimit()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(478): msecs_t ThreadAdmin::RtcTimeout()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(487): msecs_t ThreadAdmin::SchedTimeout()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(507): word ThreadAdmin::StackCheckInterval()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(515): word ThreadAdmin::StackUsageLimit()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(547): word ThreadAdmin::TrapCount()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(559): word ThreadAdmin::TrapInterval()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(567): word ThreadAdmin::TrapLimit()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(575): bool ThreadAdmin::TrapOnRtcTimeout()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(48): static bool IsSortedByThreadId(const Thread* thr1, const Thread* thr2)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(298): Thread* ThreadRegistry::FindThread(SysThreadId nid) const NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(307): ThreadId ThreadRegistry::FindTid(SysThreadId nid) const NO_FT
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(347): Thread* ThreadRegistry::GetThread(ThreadId tid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(360): std::vector< Thread* > ThreadRegistry::GetThreads() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(398): bool ThreadRegistry::IsDeleted() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp(558): size_t ThreadRegistry::Size()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ToolRegistry.cpp(117): Tool* ToolRegistry::GetTool(FlagId id) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(113): TraceBuffer::TraceBuffer() :
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(149): TraceBuffer::~TraceBuffer()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(169): void* TraceBuffer::AddFunction()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(237): uint32_t TraceBuffer::AllocSlot()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(387): bool TraceBuffer::Empty() const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(405): bool TraceBuffer::Insert(TraceRecord* record)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(437): fn_depth TraceBuffer::LastDtorDepth(SysThreadId nid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(469): const FunctionTrace* TraceBuffer::LastFunction(SysThreadId nid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(489): void TraceBuffer::Lock()
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(496): void TraceBuffer::MoveAbove(TraceRecord* second, const TraceRecord* first) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(516): void TraceBuffer::Next(TraceRecord*& curr, const Flags& mask) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(627): void TraceBuffer::RecordInvocation(fn_name_arg func) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(792): void TraceBuffer::Unlock()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.cpp(60): static void CheckHigh(FunctionStats*& high,
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.cpp(48): int FunctionStats::Compare(const FunctionStats& that) const
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.cpp(66): void FunctionStats::IncrCalls(const usecs_t& net)
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1007): static word CheckHeap(bool shouldExist, const CliThread& cli, Heap*& heap)
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1478): Q1WayItem::~Q1WayItem()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1509): Q1WayPool::Q1WayPool()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1538): void Q1WayPool::Reallocate()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1972): Q2WayItem::~Q2WayItem()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(2003): Q2WayPool::Q2WayPool()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(2032): void Q2WayPool::Reallocate()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(2494): RegistryItem::~RegistryItem()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(2522): RegistryPool::RegistryPool()
  C:\Users\Greg\Documents\rsc\rsc\src\nt\TestDatabase.cpp(148): TestDatabase::State TestDatabase::GetState(const string& testname)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp(194): TraceStatus IpBuffer::GetStatus() const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(221): size_t IpPort::Discards() const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPortRegistry.cpp(287): IpPort* IpPortRegistry::GetPort(ipport_t port, IpProtocol protocol) const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPortRegistry.cpp(509): bool IpPortRegistry::UseIPv6()
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceRegistry.cpp(77): std::vector< IpService* > IpServiceRegistry::GetServices
  C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.cpp(122): bool SendLocalIpService::Enabled() const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwLogs.cpp(152): static void UpdateAlarm
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.cpp(358): const SysIpL2Addr& SysIpL2Addr::NullIpAddr()
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.win.cpp(127): bool SysIpL2Addr::SupportsIPv6()
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.cpp(155): bool SysSocket::SetTracing(bool tracing)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.cpp(185): bool SysSocket::TraceEnabled()
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(43): uint32_t htonl(uint32_t hostlong) { return ::htonl(hostlong); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(45): uint64_t htonll(uint64_t hostllong) { return ::htonll(hostllong); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(47): uint16_t htons(uint16_t hostshort) { return ::htons(hostshort); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(49): uint32_t ntohl(uint32_t netlong) { return ::ntohl(netlong); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(51): uint64_t ntohll(uint64_t netllong) { return ::ntohll(netllong); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(53): uint16_t ntohs(uint16_t netshort) { return ::ntohs(netshort); }
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp(228): bool SysSocket::IsValid() const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.cpp(492): SysTcpSocket* TcpIoThread::Listener() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBicFeature.cpp(80): CliText* PotsBicFeature::Attrs() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBocFeature.cpp(69): CliText* PotsBocFeature::Attrs() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.cpp(76): CliText* PotsCfbFeature::Attrs() const { return new PotsCfbAttrs; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.cpp(86): CliText* PotsCfnFeature::Attrs() const { return new PotsCfnAttrs; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.cpp(76): CliText* PotsCfuFeature::Attrs() const { return new PotsCfuAttrs; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCwtFeature.cpp(64): CliText* PotsCwtFeature::Attrs() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCxfFeature.cpp(65): CliText* PotsCxfFeature::Attrs() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureRegistry.cpp(148): PotsFeature* PotsFeatureRegistry::Feature(PotsFeature::Id fid) const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.cpp(105): void DnRouteFeatureProfile::SetActive(bool on)
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.cpp(113): void DnRouteFeatureProfile::SetDN(Address::DN dn)
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.cpp(81): CliText* PotsHtlFeature::Attrs() const { return new PotsHtlAttrs; }
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.cpp(107): PotsProfile* PotsProfileRegistry::Profile(Address::DN dn) const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsSusFeature.cpp(62): CliText* PotsSusFeature::Attrs() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsTwcFeature.cpp(81): CliText* PotsTwcFeature::Attrs() const
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.cpp(85): CliText* PotsWmlFeature::Attrs() const { return new PotsWmlAttrs; }
  C:\Users\Greg\Documents\rsc\rsc\src\sb\AnalyzeSapEvent.cpp(86): void AnalyzeSapEvent::Capture
  C:\Users\Greg\Documents\rsc\rsc\src\sb\AnalyzeSnpEvent.cpp(82): void AnalyzeSnpEvent::Capture
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(334): void Context::Dump() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(931): bool Context::TraceOn()
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(941): bool Context::TraceOn(TransTrace*& trans)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.cpp(137): void Event::Capture
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(216): size_t Factory::DiscardedContextCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(223): size_t Factory::DiscardedMessageCount() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\FactoryRegistry.cpp(147): Factory* FactoryRegistry::GetFactory(FactoryId fid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InitiationReqEvent.cpp(84): void InitiationReqEvent::Capture
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(738): void InvokerPool::RecordDelay(MsgPriority prio, const nsecs_t& delay) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(790): size_t InvokerPool::WorkQCurrLength(MsgPriority prio) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(798): nsecs_t InvokerPool::WorkQMaxDelay(MsgPriority prio) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(806): size_t InvokerPool::WorkQMaxLength(MsgPriority prio) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPoolRegistry.cpp(169): InvokerPool* InvokerPoolRegistry::Pool(Faction faction) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.cpp(119): TraceStatus InvokerThread::CalcStatus(bool dynamic) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(236): MsgDirection Message::Dir() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(323): ProtocolId Message::GetProtocol() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(354): SignalId Message::GetSignal() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(409): MsgHeader* Message::Header() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.cpp(198): Parameter::Usage Parameter::GetUsage(SignalId sid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(129): Parameter* Protocol::FirstParm() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(142): Signal* Protocol::FirstSignal() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(155): Parameter* Protocol::GetParameter(ParameterId pid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(167): Signal* Protocol::GetSignal(SignalId sid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(179): void Protocol::NextParm(Parameter*& parm) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp(192): void Protocol::NextSignal(Signal*& sig) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolRegistry.cpp(78): Protocol* ProtocolRegistry::GetProtocol(ProtocolId prid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.cpp(370): void TimerPool::IncrTimeouts() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.cpp(377): Trigger* Service::GetTrigger(TriggerId tid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceRegistry.cpp(78): Service* ServiceRegistry::GetService(ServiceId sid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(312): Service* ServiceSM::GetService() const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.cpp(126): bool State::BindEventHandler(EventHandlerId ehid, EventId eid)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.cpp(161): bool State::BindMsgAnalyzer(EventHandlerId ehid, ServicePortId pid)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.cpp(244): EventHandlerId State::GetHandler(EventId eid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\State.cpp(252): EventHandlerId State::MsgAnalyzer(ServicePortId pid) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerThread.cpp(62): TraceStatus TimerThread::CalcStatus(bool dynamic) const
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp(378): PotsProfile* PotsBcSsm::Profile() const
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.cpp(118): void PotsTreatmentRegistry::SetCauseToTreatmentQ
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.cpp(199): PotsTreatmentQueue* PotsTreatmentRegistry::TreatmentQ
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.cpp(73): bool MscAddress::ExternalFid(FactoryId& fid) const
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.cpp(80): bool MscContext::IsEqualTo(const void* rcvr, uint16_t cid) const
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.cpp(53): void MscContextPair::Contexts(MscContext*& ctx1, MscContext*& ctx2) const
W107 Function does not invoke Debug::ft as first statement
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp(486):    Debug::ft("CodeFile.Affecters");
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp(2332):    Debug::ft("Tracepoint.OnLine");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CinThread.cpp(103):       Debug::ft(CinThread_Enter);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Exception.cpp(42):    Debug::ft("Exception.ctor");  //@
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MutexGuard.cpp(35):    Debug::ft("MutexGuard.ctor");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\MutexGuard.cpp(55):       Debug::ftnt("MutexGuard.Release");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Link.cpp(49):    Debug::ftnt(Q1Link_dtor);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp(73):    Debug::ft("NodeBase.SE_Handler");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1629):    Debug::ft("Thread.Exit");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2623):    Debug::ft("Thread.Ready");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2954):    Debug::ft("Thread.SignalHandler");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3029):             Debug::ft("Thread.Start(initializing)");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3575):       Debug::ft(Thread_TrapHandler);  //@
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(3139):       Debug::ft(RecoveryThread_Enter);
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwLogs.cpp(102):    Debug::ft("NetworkBase.NetworkIsUp");
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(688):    Debug::ft(Context_ProcessWork);
W110 Override of Base.Display not found
  C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp(227): class TrafficCallPool : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(298): class CipUdpService : public UdpIpService
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h(343): class CipTcpService : public TcpIpService
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeCoverage.h(43): class CodeCoverage : public NodeBase::Temporary
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h(97): class CxxSymbols: public NodeBase::Base
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.h(48): class Interpreter : public NodeBase::Base
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.cpp(44): struct AlarmDynamic : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.cpp(48): struct ClassDynamic : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\HeapCfg.h(41): class HeapCfg : public Immutable
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.cpp(56): struct LogDynamic : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTracer.h(63): class NbTracer : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(96): class ObjectPoolSizeCfg : public CfgIntParm
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(162): class ObjectPoolStats : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(204): struct ObjectPoolDynamic : public Persistent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(269): class ThreadStats : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(356): class ContextSwitches : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp(54): class ThreadsStats : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.h(64): class TraceBuffer : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.h(48): class FunctionProfiler : public Temporary
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(884): class TestHeap : public NbHeap
  C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp(1244): class LbcPool : public Temporary
  C:\Users\Greg\Documents\rsc\rsc\src\nt\TestDatabase.h(41): class TestDatabase : public NodeBase::Temporary
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(63): class TinyBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(74): class SmallBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(85): class MediumBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(96): class LargeBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(107): class HugeBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp(54): class IpPortStats : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPortRegistry.cpp(57): class LocalAddrCfg : public CfgStrParm
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceCfg.h(38): class IpServiceCfg : public CfgBoolParm
  C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.h(110): class SendLocalIpService : public UdpIpService
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTracer.h(40): class NwTracer : public NodeBase::Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h(81):    struct PotsProfileDynamic : public Persistent
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp(45): class FactoryStats : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(111): class InvokerPoolStats : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp(152): class InvokerWork : public Dynamic
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.h(167): class TimerPool : public NodeBase::ObjectPool
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTracer.h(113): class SbTracer : public NodeBase::Permanent
W111 Override of Object.Patch not found
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(356): class ContextSwitches : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(784): class ThreadPriv : public Permanent
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(35): class ByteBuffer : public NodeBase::Pooled
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(63): class TinyBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(74): class SmallBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(85): class MediumBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(96): class LargeBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h(107): class HugeBuffer : public ByteBuffer
  C:\Users\Greg\Documents\rsc\rsc\src\sb\EventHandler.h(48): class EventHandler : public NodeBase::Immutable
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerProtocol.h(88): class TimeoutParameter : public TlvParameter
W117 Line can merge with the next line and be under the length limit
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.cpp(102):    return (use == Mandatory ?
  C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp(238):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(686):       attrs.test(HasPublicMemberFunction) ||
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(717):       attrs.test(HasPublicStaticData) ||
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(724):          attrs.test(HasInstantiations) ||
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2767):    auto sName = (del ?
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(2777):          auto vName = (del ?
  C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp(1707):          (press->message == contents))
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliStack.h(68):    const CliCommand* FindCommand
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(191):       stream << fileName_ << SPACE
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1090):    BindText(*new CliText
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(1116):    BindText(*new CliText
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp(2603):    BindText(*new CliText
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(560):          (curr->slot_ != TraceRecord::InvalidSlot) &&
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(764):                   ->CurrInitiator() != nullptr)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(767):                   ->CurrSsm() != nullptr)
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(611):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(625):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(629):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(631):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(633):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(637):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(645):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp(647):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(426):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(459):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(461):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp(473):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(612):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp(626):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h(186):    PotsToneTreatment
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(706):    BindMsgAnalyzer
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(710):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(712):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(722):    BindMsgAnalyzer
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(726):    BindEventHandler
  C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp(728):    BindEventHandler
W119 Argument passed by value is modified
  C:\Users\Greg\Documents\rsc\rsc\src\cb\DigitString.cpp(50/1): DigitString::DigitString(Address::DN dn) :
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(132/3):    (const CxxScoped* member, const CxxScope* scope, SymbolView* view)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp(2781/2):    const CxxScope* scope, CodeFile* file, SymbolView& view) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp(2134/1): TypeName* QualName::At(size_t n) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5434/2):    const CxxScope* scope, CodeFile* file, SymbolView& view) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp(5674/1): void Function::SetOperator(Cxx::Operator oper)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp(3816/1): void Using::SetScope(CxxScope* scope)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp(217/2): static size_t FindTemplateBegin(const string& name, size_t pos, size_t depth)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp(239/2): static size_t FindTemplateEnd(const string& name, size_t pos)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp(762/5):    const string& s2, size_t begin, size_t end, char c)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp(798/3): size_t rfind_first_not_of(const string& str, const string& chars, size_t off)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp(812/2): size_t rfind_first_of(const string& str, size_t off, const string& chars)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp(730/2):    const CxxToken* item, word offset, const string& info) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1933/1): bool Editor::CodeFollowsImmediately(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(1948/1): bool Editor::CommentFollows(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4376/1): word Editor::InsertForward(size_t pos,
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(4544/1):    (size_t pos, const string& nspace, const string& forward)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5170/2): CxxToken* Editor::ParseFileItem(size_t pos, Namespace* ns) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(5363/1): void Editor::Rename(size_t pos, const string& oldName, const string& newName)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp(6596/3):    const CxxToken* item, const CxxToken* next, ItemDefnAttrs& attrs) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(488/1): LibExprErr Interpreter::ApplyOperator(bool operand)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp(599/1): LibrarySet* Interpreter::Error(LibExprErr err) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1285/1): size_t Lexer::CurrBegin(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1344/1): size_t Lexer::Find(size_t pos, const string& str) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1361/3): size_t Lexer::FindClosing(char lhc, char rhc, size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1473/2): size_t Lexer::FindFirstOf(const string& targs, size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1592/1): size_t Lexer::FindLineEnd(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1633/1): size_t Lexer::FindNonBlank(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1650/1): size_t Lexer::FindWord(size_t pos, const string& id) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(1996/2): size_t Lexer::GetHexNum(int64_t& num, size_t max)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2019/1): bool Lexer::GetIncludeFile(size_t pos, string& file, bool& angle) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2644/1): size_t Lexer::LineFind(size_t pos, const string& str) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2676/1): size_t Lexer::LineFindFirstOf(size_t pos, const std::string& chars) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2707/1): size_t Lexer::LineFindNonBlank(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2884/1): string Lexer::NextIdentifier(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2930/1): size_t Lexer::NextLineIndentation(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2945/1): string Lexer::NextOperator(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(2967/1): size_t Lexer::NextPos(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3103/1): bool Lexer::NoCodeFollows(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3209/1): size_t Lexer::PrevBegin(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3240/1): size_t Lexer::Rfind(size_t pos, const std::string& str) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3255/1): size_t Lexer::RfindFirstOf(size_t pos, const std::string& chars) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3270/1): size_t Lexer::RfindNonBlank(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3341/1): size_t Lexer::SkipCharLiteral(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3384/1): size_t Lexer::SkipStrLiteral(size_t pos, bool& fragmented) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp(3417/1): size_t Lexer::SkipTemplateSpec(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(1100/2): bool Parser::GetCompoundType(const QualName* name, Cxx::Type type)
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(2381/1): size_t Parser::GetLineNum(size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp(4209/2): void Parser::Log(Warning warning, size_t pos) const
  C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp(147/1): bool Token::set_number(int number)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(30/1): size_t find_first_one(uword n)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(55/1): size_t log2(size_t n, bool up)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp(122/1): size_t round_to_2_exp_n(size_t n, size_t e, bool up)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp(90/1): void Base::Nullify(size_t n)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliBuffer.cpp(214/3):    (const CliThread& cli, const string& expl, std::streamsize p)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.cpp(39/2): CliText::CliText(c_string help, c_string text, bool opt, uint32_t size) :
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliTextParm.cpp(142/2): void CliTextParm::Explain(ostream& stream, col_t indent) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.cpp(757/2):    (const string& expl, size_t begin, size_t end, col_t indent) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.cpp(75/4):    const string& prefix, const byte_t* bytes, size_t count)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.cpp(311/2): size_t strSkipSpaces(const std::string& str, size_t index)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp(99/1): LogBuffer::LogBuffer(size_t size) :
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(294/1): void* NbHeap::Alloc(size_t size)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(446/1): bool NbHeap::Create(size_t size)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(753/1): void NbHeap::FreeBlock(HeapBlock* block, level_t level)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp(860/1): void NbHeap::SplitAncestors(index_t block)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(525/1): bool ObjectPool::BidToIndices(PooledObjectId bid, size_t& i, size_t& j) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(539/1): Pooled* ObjectPool::BidToObj(PooledObjectId bid) const
  C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp(563/1): bool ObjectPool::Corrupt(size_t n)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.win.cpp(72/1): void* SysMemory::Alloc(void* addr, size_t size, MemoryProtection attrs)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1091/1): static bool ClearActiveThread(Thread* active)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(1885/1): bool Thread::HandleSignal(signal_t sig, uint32_t code)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(2373/1): DelayRc Thread::Pause(msecs_t time)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp(3486/1): void Thread::Trace(Thread* thr,
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(189/1): bool TraceBuffer::AllocBuffers(size_t n)
  C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp(368/1): TraceRc TraceBuffer::DisplayTrace(ostream* stream, const string& opts)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.cpp(141/2):    (const IpPort& port, const byte_t* source, size_t size) const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.cpp(141/3):    (const IpPort& port, const byte_t* source, size_t size) const
  C:\Users\Greg\Documents\rsc\rsc\src\nw\NwLogs.cpp(115/1): void OutputNwLog(LogId id, c_string func, nwerr_t errval, c_string extra)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.cpp(246/1): SysSocket::SendRc SysTcpSocket::QueueBuff(IpBuffer* buff, bool henq)
  C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp(165/1): word SysTcpSocket::Listen(size_t backlog)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(384/3): void Context::Enqueue(Q2Way< Context >& whichq, MsgPriority prio, bool henq)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp(682/1): void Context::ProcessWork(InvokerThread* inv)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(589/1): bool Message::Retrieve(ProtocolSM* psm)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(656/1): bool Message::Send(Route route)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp(386/1):    (BuffTrace* bt, FactoryId fid, SignalId sid, SkipInfo& skip)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(391/1): EventHandler::Rc ServiceSM::ProcessEvent(Event* currEvent, Event*& nextEvent)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(831/2):    (const Trigger* trigger, const Initiator* modifier, Event& sapEvent,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp(899/2):    (const Trigger* trigger, const Initiator* modifier, Event& snpEvent)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerRegistry.cpp(76/1): Timer::QId TimerRegistry::CalcQId(uint32_t secs) const
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp(223/2): TlvParm* TlvMessage::CopyParm(const TlvParm& src, ParameterId pid)
  C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h(105/3):       (const TlvMessage& icMsg, ParameterId icPid, ParameterId ogPid = 0)
  C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp(1024/1):    (const MscContext* active, const MsgTrace& mt, const TransTrace* tt)
W120 Function returns non-const reference or pointer to member data
  C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h(1000):    DigitString& DialedDigits() { return dialed_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h(293):    Editor& GetEditor() { return editor_; }
  C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h(76):    LibItemSet& Items() { return items_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h(82):    Registry< CliParm >& Parms() { return parms_; }
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h(190):    CliCookie& Cookie() { return cookie_; }
W121 Static member function has indirect argument for its class
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h(587/1):    static void Trace(Thread* thr, fn_name_arg func,
  C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h(175/1):       (BuffTrace* bt, FactoryId fid, SignalId sid, SkipInfo& skip);
W125 Non-const cast is not a downcast
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp(954):          auto bt = dynamic_cast< const BuffTrace* >(bt_);
W127 Data could be free
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(391):    static const CxxWord Attrs[Cxx::NIL_KEYWORD + 1]; // Parser.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(585):    static const Numeric Short; // CxxRoot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(586):    static const Numeric uChar; // CxxRoot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h(590):    static const Numeric uShort; // CxxRoot.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h(1201):    static const TypeSpecPtr Bool; // CxxExecute.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h(151):    static NodeBase::fixed_string SubsDir; // CodeDir.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.h(60):    static const char CommentChar; // CfgParmRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h(46):    static const char CommandSeparator; // CliThread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\InitThread.h(75):    static const Flags RecreateMask; // Daemon.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\InitThread.h(76):    static const Flags ScheduleMask; // Thread.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.h(51):    static const signal_t MaxId; // PosixSignalRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.h(54):    static const size_t ReportWidth; // StatisticsRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h(50):    static const size_t MaxBuffSize; // IpBuffer.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h(59):    static const id_t MaxId; // IpServiceRegistry.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h(181):    static const SignalEntry NilSignalEntry; // PotsCircuit.cpp
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(361):    static const MessageEntry NilMessageEntry; // Context.cpp
W130 Redundant scope
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(91):    Debug::ft("Debug.GetSwFlags");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(101):    Debug::ft("Debug.noop");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(108):    Debug::ft("Debug.Progress");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(118):    Debug::ft("Debug.ResetSwFlags");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(127):    Debug::ftnt("Debug.SetSwFlag");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(146):    Debug::ftnt("Debug.SwFlagOn");
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(163):    Debug::ftnt(Debug_SwLog);
  C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp(167):    Debug::ftnt(Debug_SwLog);
W131 C-style preprocessor directive
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SystemTime.cpp(74): #ifdef OS_WIN
  C:\Users\Greg\Documents\rsc\rsc\src\nb\SystemTime.cpp(79): #ifdef OS_LINUX
W141 Function could be moved to a subclass
  C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.h(56):    virtual bool NextValue() const = 0; // CfgBoolParm
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h(192):    virtual void EndOfTransaction() { } // MsgContext
  C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h(235):    virtual Context* AllocContext() const; // PsmFactory
====================================================================================================================================
WARNINGS SORTED BY FILE/TYPE/LINE (i = informational)
C:\Users\Greg\Documents\rsc\rsc\src\an\AnIncrement.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\an\AnIncrement.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\an\AnModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\an\AnModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelf.h
* W020 Using statement in header
    31: using namespace NodeBase;
    32: using namespace SessionBase;
    33: using namespace NetworkBase;
C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfFactory.cpp
  W007 Cast down the inheritance hierarchy
    124:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    137:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
    157:    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
    167:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
* W022 Add using statement
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfHandler.cpp
  W006 reinterpret_cast
    68:    auto pptr = reinterpret_cast< TlvParm* >(sbuff->PayloadPtr());
    69:    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  W007 Cast down the inheritance hierarchy
    66:    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
* W022 Add using statement
    0:  // namespace MediaBase
    0:  // namespace NetworkBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\an\PotsShelfIpService.cpp
* W022 Add using statement
    0:  // namespace NetworkBase
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.cpp
  W004 C-style cast
    493:    Singleton< TrafficCallPool >::Extant()->Enq((TrafficCall*) addr);
    1053:    timewheel_ = (Q1Way< TrafficCall >*) Memory::Alloc(size, MemDynamic);
  W006 reinterpret_cast
    483:    auto fake = reinterpret_cast< const TrafficCall* >(&local);
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W053 Data could be const
    175:    Q1Link link_;
* W106 Function does not invoke Debug::ft
    1351: void PotsTrafficThread::RecordHoldingTime(const nsecs_t& time)
  W110 Override of Base.Display not found
    227: class TrafficCallPool : public Dynamic
C:\Users\Greg\Documents\rsc\rsc\src\an\PotsTrafficThread.h
* W020 Using statement in header
    35: using namespace NodeBase;
    36: using namespace CallBase;
* W092 Function could be free
    88:    static void DisplayStateCounts // AnIncrement.cpp
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.cpp
  W006 reinterpret_cast
    90:    reinterpret_cast< const DigitString* >(bytes)->Display(stream, prefix);
  W007 Cast down the inheritance hierarchy
    107:    auto& tlvmsg = static_cast< TlvMessage& >(msg);
    155:    auto& tlvmsg = static_cast< const TlvMessage& >(msg);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcAddress.h
* W020 Using statement in header
    33: using namespace NodeBase;
    34: using namespace SessionBase;
* W032 Unused function
    213:    Digit At(DigitCount i) const;
* W042 Member could be private
    175:    static bool IsValidDigit(Digit d)
    182:    Rc AddDigit(Digit d);
    201:    DigitCount Size() const;
* W043 Member could be protected
    124:    static DN IndexToDN(uint32_t i) { return i + FirstDN - 1; }
* W092 Function could be free
    175:    static bool IsValidDigit(Digit d) // DigitString.cpp
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.cpp
  W006 reinterpret_cast
    112:    reinterpret_cast< const CauseInfo* >(bytes)->Display(stream, prefix);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W117 Line can merge with the next line and be under the length limit
    102:    return (use == Mandatory ?
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcCause.h
* W020 Using statement in header
    32: using namespace NodeBase;
    33: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcEvents.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcFactory.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcHandlers.cpp
  W007 Cast down the inheritance hierarchy
    41:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    43:    auto& bcssm = static_cast< BcSsm& >(ssm);
    65:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    66:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    68:    auto&         bcssm = static_cast< BcSsm& >(ssm);
    120:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    121:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    123:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    161:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    162:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    164:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    191:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    192:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    194:    auto&         bcssm = static_cast< BcSsm& >(ssm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W099 Line contains adjacent spaces
    65:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    66:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    67:    auto          sid = msg->GetSignal();
    68:    auto&         bcssm = static_cast< BcSsm& >(ssm);
    70:    CauseInfo*    cci;
    120:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    121:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    122:    auto       sid = msg->GetSignal();
    123:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    161:    auto&      ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    162:    auto       msg = static_cast< CipMessage* >(ame.Msg());
    163:    auto       sid = msg->GetSignal();
    164:    auto&      bcssm = static_cast< BcSsm& >(ssm);
    191:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    192:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    193:    auto          sid = msg->GetSignal();
    194:    auto&         bcssm = static_cast< BcSsm& >(ssm);
    196:    CauseInfo*    cci;
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.cpp
  W006 reinterpret_cast
    98:    reinterpret_cast< const ProgressInfo* >(bytes)->Display(stream, prefix);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProgress.h
* W020 Using statement in header
    32: using namespace NodeBase;
    33: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.cpp
  W005 Functional cast
    508:    if(route->identifier != RouteResult::Id(rid)) return ParmValueMismatch;
  W006 reinterpret_cast
    451:    reinterpret_cast< const RouteResult* >(bytes)->Display(stream, prefix);
  W007 Cast down the inheritance hierarchy
    464:    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
    492:    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
    759:       if(m->GetSignal() == sid) return static_cast< CipMessage* >(m);
    789:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    919:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    1257:    auto& tmsg = static_cast< const CipMessage& >(msg);
    1262:    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
* W022 Add using statement
    0:  // namespace MediaBase
    0:  // namespace NetworkBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W099 Line contains adjacent spaces
    461:    id_t        idx;
    462:    word        fid, rid;
    464:    auto&       tlvmsg = static_cast< TlvMessage& >(msg);
    491:    TestRc       rc;
    492:    auto&        tlvmsg = static_cast< const TlvMessage& >(msg);
    494:    id_t         idx;
    495:    word         fid, rid;
    788:    auto          state = GetState();
    789:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    790:    auto          sig = tmsg.GetSignal();
    791:    TimeoutInfo*  toi = nullptr;
    793:    auto          err = true;
    794:    debug64_t     error;
    918:    auto          state = GetState();
    919:    auto&         tmsg = static_cast< TlvMessage& >(msg);
    920:    auto          sig = msg.GetSignal();
    922:    auto          err = true;
    923:    debug64_t     error;
* W106 Function does not invoke Debug::ft
    225: bool CipUdpService::Enabled() const
    301: bool CipTcpService::Enabled() const
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcProtocol.h
* W020 Using statement in header
    50: using namespace NodeBase;
    51: using namespace NetworkBase;
    52: using namespace SessionBase;
    53: using namespace MediaBase;
* W032 Unused function
    182:    MediaInfo* AddMedia(const MediaInfo& media);
* W042 Member could be private
    236:    void EnsureMediaMsg() override;
    245:    IncomingRc ProcessIcMsg(Message& msg, Event*& event) override;
    423:    Message* AllocIcMsg(SbIpBufferPtr& buff) const override;
  W110 Override of Base.Display not found
    298: class CipUdpService : public UdpIpService
    343: class CipTcpService : public TcpIpService
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcRouting.cpp
* W022 Add using statement
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcRouting.h
* W020 Using statement in header
    31: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcService.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSessions.h
* W020 Using statement in header
    53: using namespace MediaBase;
    54: using namespace NodeBase;
    55: using namespace SessionBase;
  W037 Member hides inherited name
    316:    static const Id NextId = FirstId + 50;
    883:    static const Id NextId                 = FirstUn + 7;
* W042 Member could be private
    1015:    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
    1016:    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
    1017:    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
    1063:    virtual EventHandler::Rc RequestService(Event*& nextEvent);
    1145:    CipPsm* AllocNPsm();
* W043 Member could be protected
    1029:    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
    1034:    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
    1099:    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
* W053 Data could be const
    340:    Progress::Ind progress_;
    356:    Cause::Ind cause_;
  W075 Virtual function is public
    1010:    virtual EventHandler::Rc RaiseAuthorizeOrigination(Event*& nextEvent);
    1011:    virtual EventHandler::Rc RaiseCollectInformation(Event*& nextEvent);
    1012:    virtual EventHandler::Rc RaiseLocalInformation(Event*& nextEvent);
    1013:    virtual EventHandler::Rc RaiseCollectionTimeout(Event*& nextEvent);
    1014:    virtual EventHandler::Rc RaiseAnalyzeInformation(Event*& nextEvent);
    1015:    virtual EventHandler::Rc RaiseInvalidInformation(Event*& nextEvent);
    1016:    virtual EventHandler::Rc RaiseSelectRoute(Event*& nextEvent);
    1017:    virtual EventHandler::Rc RaiseAuthorizeCallSetup(Event*& nextEvent);
    1018:    virtual EventHandler::Rc RaiseSendCall(Event*& nextEvent);
    1019:    virtual EventHandler::Rc RaiseRemoteBusy(Event*& nextEvent);
    1020:    virtual EventHandler::Rc RaiseRemoteProgress
    1022:    virtual EventHandler::Rc RaiseRemoteAlerting(Event*& nextEvent);
    1023:    virtual EventHandler::Rc RaiseRemoteNoAnswer(Event*& nextEvent);
    1024:    virtual EventHandler::Rc RaiseRemoteAnswer(Event*& nextEvent);
    1025:    virtual EventHandler::Rc RaiseAuthorizeTermination(Event*& nextEvent);
    1026:    virtual EventHandler::Rc RaiseSelectFacility(Event*& nextEvent);
    1027:    virtual EventHandler::Rc RaisePresentCall(Event*& nextEvent);
    1028:    virtual EventHandler::Rc RaiseLocalBusy(Event*& nextEvent);
    1029:    virtual EventHandler::Rc RaiseFacilityFailure(Event*& nextEvent);
    1030:    virtual EventHandler::Rc RaiseLocalProgress
    1032:    virtual EventHandler::Rc RaiseLocalAlerting(Event*& nextEvent);
    1033:    virtual EventHandler::Rc RaiseLocalAnswer(Event*& nextEvent);
    1034:    virtual EventHandler::Rc RaiseLocalNoAnswer(Event*& nextEvent);
    1035:    virtual EventHandler::Rc RaiseLocalSuspend(Event*& nextEvent);
    1036:    virtual EventHandler::Rc RaiseLocalResume(Event*& nextEvent);
    1037:    virtual EventHandler::Rc RaiseRemoteSuspend(Event*& nextEvent);
    1038:    virtual EventHandler::Rc RaiseRemoteResume(Event*& nextEvent);
    1045:    virtual EventHandler::Rc RaiseLocalRelease
    1047:    virtual EventHandler::Rc RaiseRemoteRelease
    1049:    virtual EventHandler::Rc RaiseReleaseCall
    1051:    virtual EventHandler::Rc RaiseApplyTreatment
    1058:    virtual EventHandler::Rc AnalyzeInformation(Event*& nextEvent);
    1063:    virtual EventHandler::Rc RequestService(Event*& nextEvent);
    1070:    virtual EventHandler::Rc SelectRoute(Event*& nextEvent);
    1076:    virtual EventHandler::Rc AnalyzeNPsmTimeout
    1083:    virtual EventHandler::Rc HandleLocalAlerting();
    1088:    virtual EventHandler::Rc HandleLocalAnswer();
    1092:    virtual EventHandler::Rc HandleRemoteRelease(Event& currEvent);
    1099:    virtual EventHandler::Rc ClearCall(Cause::Ind cause);
    1105:    virtual CipMessage* BuildCipIam();
    1111:    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
    1208:    virtual Cause::Ind VerifyRoute(RouteResult::Id rid) const;
  W082 Adjacent arguments have the same type
    1212:    BcFactory(Id fid, ProtocolId prid, c_string name);
* W090 Function could be const
    1111:    virtual CipMessage* BuildCipCpg(Progress::Ind progress);
    1167:    CipMessage* BuildCipRel(Cause::Ind cause);
* W092 Function could be free
    1115:    static void DisplayStateCounts // AnIncrement.cpp
    1120:    static void ResetStateCounts(RestartLevel level); // CbModule.cpp
  W120 Function returns non-const reference or pointer to member data
    1000:    DigitString& DialedDigits() { return dialed_; }
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcSsm.cpp
  W007 Cast down the inheritance hierarchy
    384:    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
    825:       auto fac = static_cast< BcFactory* >(reg->GetFactory(route_.selector));
* W022 Add using statement
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
  W102 Line length exceeds the standard maximum
    285:    for(auto s = BcState::AuthorizingOrigination; s <= BcState::OrigAlerting; ++s)
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcStates.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\BcTriggers.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\CbModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\CbModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\cb\DigitString.cpp
  W005 Functional cast
    137:       auto rc = AddDigit(Digit(ds.digits_[i]));
    148:    if(i < Size()) return Digit(digits_[i]);
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    146: Digit DigitString::At(DigitCount i) const
  W119 Argument passed by value is modified
    50/1: DigitString::DigitString(Address::DN dn) :
C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.cpp
  W007 Cast down the inheritance hierarchy
    359:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    360:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    362:    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
    391:    auto& ppe = static_cast< ProxyBcProgressEvent& >(currEvent);
    400:       auto& pssm = static_cast< ProxyBcSsm& >(ssm);
    426:    auto& pssm = static_cast< ProxyBcSsm& >(ssm);
    427:    auto ppsm = static_cast< ProxyBcPsm* >(Context::ContextPsm());
    531:    auto pssm = static_cast< ProxyBcSsm* >(RootSsm());
    672:          return static_cast< ProxyBcPsm* >(p);
    704:          ppsm = static_cast< ProxyBcPsm* >(psm);
    909:    auto& tmsg = static_cast< const CipMessage& >(msg);
    914:    auto fac = static_cast< SsmFactory* >(reg->GetFactory(rte->selector));
* W022 Add using statement
    0:  // namespace MediaBase
    0:  // namespace NetworkBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W099 Line contains adjacent spaces
    359:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    360:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    361:    auto          sid = msg->GetSignal();
    362:    auto&         pssm = static_cast< ProxyBcSsm& >(ssm);
    364:    CauseInfo*    cci;
* W117 Line can merge with the next line and be under the length limit
    238:    BindEventHandler
C:\Users\Greg\Documents\rsc\rsc\src\cb\ProxyBcSessions.h
* W020 Using statement in header
    33: using namespace MediaBase;
    34: using namespace NodeBase;
    35: using namespace SessionBase;
  W027 Unused class
    192: class ProxyBcDisconnecting : public BcDisconnecting
* W028 Unused data
    63:    static const ServicePortId NextPortId = FirstPortId + 1;
    219:    static const Id NextId        = FirstId + 4;
    303:    static const Id NextId              = FirstId + 7;
    387:    constexpr TriggerId NextId = FirstId + 3;
* W032 Unused function
    195:    explicit ProxyBcDisconnecting(ServiceId sid);
  W037 Member hides inherited name
    63:    static const ServicePortId NextPortId = FirstPortId + 1;
    213:    static const Id FirstId = BcEvent::NextId;
    219:    static const Id NextId        = FirstId + 4;
    303:    static const Id NextId              = FirstId + 7;
* W042 Member could be private
    488:    ProxyBcPsm* FirstBroadcast() const;
  W075 Virtual function is public
    465:    virtual EventHandler::Rc RaiseReleaseUser
    467:    virtual EventHandler::Rc RaiseProxyProgress
    469:    virtual EventHandler::Rc RaiseProxyAnswer(Event*& nextEvent);
    470:    virtual EventHandler::Rc RaiseProxyRelease
    510:    void SetUPsm(MediaPsm& psm) override;
C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cb\ServiceCodeRegistry.h
* W020 Using statement in header
    30: using namespace NodeBase;
    31: using namespace SessionBase;
* W042 Member could be private
    54:    void SetService(Address::SC sc, ServiceId sid);
C:\Users\Greg\Documents\rsc\rsc\src\cb\TestCallFactory.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\cn\CnModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\cn\CnModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeCoverage.h
  W110 Override of Base.Display not found
    43: class CodeCoverage : public NodeBase::Temporary
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDir.cpp
  W007 Cast down the inheritance hierarchy
    69:       auto file = static_cast< CodeFile* >(*f);
    126:       auto file = static_cast< CodeFile* >(*f);
    143:       auto file = static_cast< CodeFile* >(*f);
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.cpp
  W007 Cast down the inheritance hierarchy
    94:       auto file = static_cast< CodeFile* >(*f);
    121:       auto dir = static_cast< CodeDir* >(*d);
    130:       auto dir = static_cast< CodeDir* >(*d);
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeDirSet.h
* W042 Member could be private
    54:    void to_str(stringVector& strings, bool verbose) const override;
  W075 Virtual function is public
    54:    void to_str(stringVector& strings, bool verbose) const override;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.cpp
  W007 Cast down the inheritance hierarchy
    80:          auto base = static_cast< const Class* >(*b);
    236:       auto base = static_cast< const Class* >(*b);
    266:                auto type = static_cast< const Typedef* >(*item2);
    289:          auto type = static_cast< const Typedef* >(*item1);
    1022:       auto f = static_cast< const CodeFile* >(*i);
    1030:       auto f = static_cast< const CodeFile* >(*u);
    1422:       auto file = static_cast< const CodeFile* >(*f);
    1624:          auto file = static_cast< const CodeFile* >(*d);
    2043:       auto file = static_cast< const CodeFile* >(*f);
    2207:       const auto& name = static_cast< const CodeFile* >(*f)->Name();
    2389:                auto incl = static_cast< const CodeFile* >(*a);
    2497:          auto file = static_cast< const CodeFile* >(*d);
    2526:       auto file = static_cast< CodeFile* >(*f);
    2557:       auto base = static_cast< const Class* >(*b);
* W106 Function does not invoke Debug::ft
    1083: void CodeFile::EraseClass(const Class* cls)
    1091: void CodeFile::EraseData(const Data* data)
    1099: void CodeFile::EraseEnum(const Enum* item)
    1107: void CodeFile::EraseForw(const Forward* forw)
    1115: void CodeFile::EraseFunc(const Function* func)
    1157: void CodeFile::EraseItem(const CxxToken* item)
    1171: void CodeFile::EraseSpace(const SpaceDefn* space)
    1179: void CodeFile::EraseType(const Typedef* type)
    1187: void CodeFile::EraseUsing(const Using* use)
    1552: void CodeFile::GetLineCounts() const
    1762: void CodeFile::InsertAsm(Asm* code)
    1770: void CodeFile::InsertClass(Class* cls)
    1778: void CodeFile::InsertData(Data* data)
    1786: bool CodeFile::InsertDirective(DirectivePtr& dir)
    1795: void CodeFile::InsertEnum(Enum* item)
    1803: void CodeFile::InsertForw(Forward* forw)
    1811: void CodeFile::InsertFunc(Function* func)
    1819: void CodeFile::InsertInclude(IncludePtr& incl)
    1862: void CodeFile::InsertItem(CxxToken* item)
    1887: void CodeFile::InsertMacro(Macro* macro)
    1895: void CodeFile::InsertSpace(SpaceDefn* space)
    1903: void CodeFile::InsertStaticAssert(StaticAssert* assert)
    1911: void CodeFile::InsertType(Typedef* type)
    1919: void CodeFile::InsertUsing(Using* use)
  W107 Function does not invoke Debug::ft as first statement
    486:    Debug::ft("CodeFile.Affecters");
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFile.h
  W026 Unused argument
    420/3:       const CxxNamed* item, const CxxScope* scope) const;
* W042 Member could be private
    130:    const CxxTokenList Items() const { return items_; }
    131:    const IncludePtrVector& Includes() const { return incls_; }
    284:    size_t FindFirstReference(const CxxTokenVector& refs) const;
    289:    size_t FindLastUsage(const CxxNamedSet& usages) const;
  W082 Adjacent arguments have the same type
    536:    void UpdatePos(EditorAction action,
* W092 Function could be free
    358:    const stringVector& Prolog() const; // CodeFile.cpp
  W120 Function returns non-const reference or pointer to member data
    293:    Editor& GetEditor() { return editor_; }
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.cpp
  W004 C-style cast
    606:    LibrarySet* nbSet = (LibrarySet*) this;
    634:    LibrarySet* nsSet = (LibrarySet*) this;
  W007 Cast down the inheritance hierarchy
    80:       auto file = static_cast< CodeFile* >(*f);
    193:       auto file = static_cast< CodeFile* >(*f);
    252:       auto file = static_cast< CodeFile* >(*f);
    277:       auto file = static_cast< CodeFile* >(*f);
    308:       auto file = static_cast< CodeFile* >(*f);
    334:       auto file = static_cast< CodeFile* >(*f);
    362:       auto file = static_cast< CodeFile* >(*f);
    405:       auto file = static_cast< CodeFile* >(*f);
    459:       auto file = static_cast< CodeFile* >(*f);
    485:       auto file = static_cast< CodeFile* >(*f);
    511:    auto& dirSet = static_cast< const CodeDirSet* >(that)->Items();
    518:       auto file = static_cast< CodeFile* >(*f);
    558:       auto file = static_cast< CodeFile* >(*f);
    585:       auto file = static_cast< CodeFile* >(*f);
    739:       auto file = static_cast< CodeFile* >(*f);
    767:       auto file = static_cast< CodeFile* >(*f);
    876:       files.push_back(static_cast<CodeFile*>(*f));
    903:       auto file = static_cast< CodeFile* >(*f);
    983:       auto file = static_cast< CodeFile* >(*f);
    1010:       auto file = static_cast< CodeFile* >(*f);
    1040:       auto file = static_cast< CodeFile* >(*f);
  W008 Cast removes const qualification
    606:    LibrarySet* nbSet = (LibrarySet*) this;
    634:    LibrarySet* nsSet = (LibrarySet*) this;
* W106 Function does not invoke Debug::ft
    93: static bool IsSortedByFileLevel(const FileLevel& item1, const FileLevel& item2)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeFileSet.h
* W042 Member could be private
    109:    void to_str(stringVector& strings, bool verbose) const override;
  W075 Virtual function is public
    109:    void to_str(stringVector& strings, bool verbose) const override;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.cpp
  W007 Cast down the inheritance hierarchy
    122:       auto item = static_cast< CxxNamed* >(*i);
    148:       auto item = static_cast< CxxNamed* >(*i);
    176:       auto item = static_cast< CxxNamed* >(*i);
    198:       auto item = static_cast< CxxNamed* >(*i);
    217:       auto item = static_cast< CxxScoped* >(*i);
    238:       auto item = static_cast< CxxScoped* >(*i);
    260:       auto item = static_cast< CxxNamed* >(*i);
* W106 Function does not invoke Debug::ft
    55: void CodeItemSet::CopyItems(const CxxNamedSet& items)
    67: void CodeItemSet::CopyUsages(const CxxUsageSets& usages)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeItemSet.h
* W042 Member could be private
    64:    void to_str(stringVector& strings, bool verbose) const override;
  W075 Virtual function is public
    64:    void to_str(stringVector& strings, bool verbose) const override;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeTypes.cpp
* W106 Function does not invoke Debug::ft
    406: size_t IndentSize()
    413: bool IsAccessControl(const std::string& s)
    426: size_t LineLengthMax()
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.cpp
  W005 Functional cast
    225:          << spaces(3) << LineType(t) << CRLF;
    236:          *stream << (Attrs_.at(Warning(w)).fixable_ ? '*' : SPACE);
    237:          *stream << setw(5) << WarningCode(Warning(w)) << setw(6)
    238:             << WarningCounts_[w] << spaces(2) << Warning(w) << CRLF;
    297:          *stream << (Attrs_.at(Warning(w)).fixable_ ? '*' : SPACE);
  W007 Cast down the inheritance hierarchy
    206:       auto file = static_cast< CodeFile* >(*f);
    1005:       auto name = static_cast<const Friend*>(item_)->ScopedName(true);
    1027:       auto data = static_cast< const Data* >(item_);
    1069:       auto func = static_cast< Function* >(item_);
    1149:       auto cls = static_cast< const Class* >(item_);
    1173:       auto cls = static_cast< const Class* >(item_);
    1204:          auto func = static_cast< const Function* >(item_);
  W008 Cast removes const qualification
    95:    item_(const_cast< CxxToken* >(item)),
* W106 Function does not invoke Debug::ft
    343: bool CodeWarning::HasCodeToDisplay() const
    350: bool CodeWarning::HasInfoToDisplay() const
    812: bool CodeWarning::IsInformational() const
    819: bool CodeWarning::IsSortedByFile
    838: bool CodeWarning::IsSortedByType
    857: bool CodeWarning::IsSortedToFix
    876: void CodeWarning::ItemDeleted(const CxxToken* item) const
    886: size_t CodeWarning::Line() const
    954: bool CodeWarning::Preserve() const
    981: bool CodeWarning::Suppress() const
    1243: bool CodeWarning::WasResolved() const
C:\Users\Greg\Documents\rsc\rsc\src\ct\CodeWarning.h
* W020 Using statement in header
    38: using NodeBase::word;
  W082 Adjacent arguments have the same type
    64:    WarningAttrs(bool fixable, bool preserve, NodeBase::c_string expl);
    143:    void UpdatePos(EditorAction action,
C:\Users\Greg\Documents\rsc\rsc\src\ct\CtIncrement.cpp
  W005 Functional cast
    1321:       Context::EraseTracepoint(file, line - 1, Tracepoint::Action(mode));
    1336:    Context::InsertTracepoint(file, line - 1, Tracepoint::Action(mode));
  W007 Cast down the inheritance hierarchy
    1083:          auto dir = static_cast< CodeDir* >(*d);
    1106:          auto file = static_cast< CodeFile* >(*f);
* W043 Member could be protected
    93:    static LibrarySet* Evaluate(CliThread& cli);
C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.cpp
  W005 Functional cast
    575:       if(Attrs[i].symbol.compare(sym) == 0) return Cxx::Operator(i);
    623:          oper = Cxx::Operator(i);
    672:       Attrs[ValidIntDigits[i]].intValue = int8_t(i);
    678:       Attrs[ValidHexDigits[i]].hexValue = int8_t(h);
    683:       Attrs[ValidOctDigits[i]].octValue = int8_t(i);
* W099 Line contains adjacent spaces
    400:    CxxWord("D",   "D",    "D",  F),  // ALIGNAS
    401:    CxxWord("@",   "@",    "@",  T),  // ASM
    402:    CxxWord("-",   "-",    "D",  F),  // AUTO
    403:    CxxWord("-",   "-",    "b",  T),  // BREAK
    404:    CxxWord("-",   "-",    "c",  T),  // CASE
    405:    CxxWord("C",   "C",    "-",  T),  // CLASS
    406:    CxxWord("DP",  "DP",   "D",  F),  // CONST
    407:    CxxWord("DP",  "DP",   "D",  F),  // CONSTEXPR
    408:    CxxWord("-",   "-",    "n",  T),  // CONTINUE
    409:    CxxWord("-",   "-",    "o",  T),  // DEFAULT
    410:    CxxWord("-",   "-",    "d",  T),  // DO
    411:    CxxWord("E",   "E",    "E",  T),  // ENUM
    412:    CxxWord("-",   "P",    "-",  F),  // EXPLICIT
    413:    CxxWord("DP",  "-",    "-",  F),  // EXTERN
    414:    CxxWord("-",   "-",    "-",  F),  // FINAL
    415:    CxxWord("-",   "-",    "f",  T),  // FOR
    416:    CxxWord("-",   "F",    "-",  T),  // FRIEND
    417:    CxxWord("-",   "-",    "g",  T),  // GOTO
    418:    CxxWord("H",   "H",    "H",  F),  // HASH
    419:    CxxWord("-",   "-",    "i",  T),  // IF
    420:    CxxWord("P",   "P",    "-",  F),  // INLINE
    421:    CxxWord("-",   "D",    "-",  F),  // MUTABLE
    422:    CxxWord("N",   "-",    "-",  T),  // NAMESPACE
    423:    CxxWord("-",   "P",    "-",  F),  // OPERATOR
    424:    CxxWord("-",   "-",    "-",  F),  // OVERRIDE
    425:    CxxWord("-",   "A",    "-",  T),  // PRIVATE
    426:    CxxWord("-",   "A",    "-",  T),  // PROTECTED
    427:    CxxWord("-",   "A",    "-",  T),  // PUBLIC
    428:    CxxWord("-",   "-",    "r",  T),  // RETURN
    429:    CxxWord("DP",  "DP",   "D",  F),  // STATIC
    430:    CxxWord("$",   "$",    "$",  T),  // STATIC_ASSERT
    431:    CxxWord("C",   "C",    "-",  T),  // STRUCT
    432:    CxxWord("-",   "-",    "s",  T),  // SWITCH
    433:    CxxWord("DCP", "DCFP", "-",  F),  // TEMPLATE
    434:    CxxWord("D",   "D",    "D",  F),  // THREAD_LOCAL
    435:    CxxWord("-",   "-",    "t",  T),  // TRY
    436:    CxxWord("T",   "T",    "T",  T),  // TYPEDEF
    437:    CxxWord("C",   "C",    "-",  T),  // UNION
    438:    CxxWord("U",   "U",    "U",  T),  // USING
    439:    CxxWord("-",   "P",    "-",  F),  // VIRTUAL
    440:    CxxWord("DP",  "DP",   "D",  F),  // VOLATILE
    441:    CxxWord("-",   "-",    "w",  T),  // WHILE
    442:    CxxWord("-",   "P",    "-",  F),  // NVDTOR
    443:    CxxWord("DP",  "DP",   "xD", F)   // NIL_KEYWORD
    471:    CxxOp(           SCOPE_STR, 2, 18, F, F, F, XN),  // SCOPE_RESOLUTION
    472:    CxxOp(                 ".", 2, 17, F, F, F, NN),  // REFERENCE_SELECT
    473:    CxxOp(                "->", 2, 17, T, F, F, NN),  // POINTER_SELECT
    474:    CxxOp(                 "[", 2, 17, T, F, F, NN),  // ARRAY_SUBSCRIPT
    475:    CxxOp(                 "(", 0, 17, F, F, F, NN),  // FUNCTION_CALL
    476:    CxxOp(                "++", 1, 17, T, F, F, NX),  // POSTFIX_INCREMENT
    477:    CxxOp(                "--", 1, 17, T, F, F, NX),  // POSTFIX_DECREMENT
    478:    CxxOp(         DEFINED_STR, 1, 17, F, F, F, XN),  // DEFINED
    479:    CxxOp(          TYPEID_STR, 1, 17, F, F, F, XN),  // TYPE_NAME
    480:    CxxOp(      CONST_CAST_STR, 2, 17, F, F, F, XN),  // CONST_CAST
    481:    CxxOp(    DYNAMIC_CAST_STR, 2, 17, F, F, F, XN),  // DYNAMIC_CAST
    483:    CxxOp(     STATIC_CAST_STR, 2, 17, F, F, F, XN),  // STATIC_CAST
    484:    CxxOp(          SIZEOF_STR, 1, 16, F, T, F, XN),  // SIZEOF_TYPE
    485:    CxxOp(         ALIGNOF_STR, 1, 16, F, T, F, XN),  // ALIGNOF_TYPE
    486:    CxxOp(        NOEXCEPT_STR, 1, 16, F, T, F, XN),  // NOEXCEPT
    487:    CxxOp(                "++", 1, 16, T, T, F, XN),  // PREFIX_INCREMENT
    488:    CxxOp(                "--", 1, 16, T, T, F, XN),  // PREFIX_DECREMENT
    489:    CxxOp(                 "~", 1, 16, T, T, F, XN),  // ONES_COMPLEMENT
    490:    CxxOp(                 "!", 1, 16, T, T, F, XN),  // LOGICAL_NOT
    491:    CxxOp(                 "+", 1, 16, T, T, F, XN),  // UNARY_PLUS
    492:    CxxOp(                 "-", 1, 16, T, T, F, XN),  // UNARY_MINUS
    493:    CxxOp(                 "&", 1, 16, T, T, F, XN),  // ADDRESS_OF
    494:    CxxOp(                 "*", 1, 16, T, T, F, XN),  // INDIRECTION
    495:    CxxOp(             NEW_STR, 0, 16, T, T, F, XX),  // OBJECT_CREATE
    496:    CxxOp(       NEW_ARRAY_STR, 0, 16, T, T, F, XX),  // OBJECT_CREATE_ARRAY
    497:    CxxOp(          DELETE_STR, 1, 16, T, T, F, XX),  // OBJECT_DELETE
    498:    CxxOp(    DELETE_ARRAY_STR, 1, 16, T, T, F, XX),  // OBJECT_DELETE_ARRAY
    499:    CxxOp(                 "(", 2, 16, T, T, F, SN),  // CAST
    500:    CxxOp(                ".*", 2, 15, F, F, F, NN),  // REFERENCE_SELECT_MEMBER
    501:    CxxOp(               "->*", 2, 15, T, F, F, NN),  // POINTER_SELECT_MEMBER
    502:    CxxOp(                 "*", 2, 14, T, F, T, SS),  // MULTIPLY
    503:    CxxOp(                 "/", 2, 14, T, F, F, SS),  // DIVIDE
    504:    CxxOp(                 "%", 2, 14, T, F, F, SS),  // MODULO
    505:    CxxOp(                 "+", 2, 13, T, F, T, SS),  // ADD
    506:    CxxOp(                 "-", 2, 13, T, F, F, SS),  // SUBTRACT
    507:    CxxOp(                "<<", 2, 12, T, F, F, SS),  // LEFT_SHIFT
    508:    CxxOp(                ">>", 2, 12, T, F, F, SS),  // RIGHT_SHIFT
    509:    CxxOp(                 "<", 2, 11, T, F, T, SS),  // LESS
    510:    CxxOp(                "<=", 2, 11, T, F, T, SS),  // LESS_OR_EQUAL
    511:    CxxOp(                 ">", 2, 11, T, F, T, SS),  // GREATER
    512:    CxxOp(                ">=", 2, 11, T, F, T, SS),  // GREATER_OR_EQUAL
    513:    CxxOp(                "==", 2, 10, T, F, T, SS),  // EQUALITY
    514:    CxxOp(                "!=", 2, 10, T, F, T, SS),  // INEQUALITY
    515:    CxxOp(                 "&", 2,  9, T, F, T, SS),  // BITWISE_AND
    516:    CxxOp(                 "^", 2,  8, T, F, T, SS),  // BITWISE_XOR
    517:    CxxOp(                 "|", 2,  7, T, F, T, SS),  // BITWISE_OR
    518:    CxxOp(                "&&", 2,  6, T, F, T, SS),  // LOGICAL_AND
    519:    CxxOp(                "||", 2,  5, T, F, T, SS),  // LOGICAL_OR
    520:    CxxOp(                 "?", 3,  4, F, F, F, SS),  // CONDITIONAL
    521:    CxxOp(                 "=", 2,  3, T, T, F, SS),  // ASSIGN
    522:    CxxOp(                "*=", 2,  3, T, T, F, SS),  // MULTIPLY_ASSIGN
    523:    CxxOp(                "/=", 2,  3, T, T, F, SS),  // DIVIDE_ASSIGN
    524:    CxxOp(                "%=", 2,  3, T, T, F, SS),  // MODULO_ASSIGN
    525:    CxxOp(                "+=", 2,  3, T, T, F, SS),  // ADD_ASSIGN
    526:    CxxOp(                "-=", 2,  3, T, T, F, SS),  // SUBTRACT_ASSIGN
    527:    CxxOp(               "<<=", 2,  3, T, T, F, SS),  // LEFT_SHIFT_ASSIGN
    528:    CxxOp(               ">>=", 2,  3, T, T, F, SS),  // RIGHT_SHIFT_ASSIGN
    529:    CxxOp(                "&=", 2,  3, T, T, F, SS),  // BITWISE_AND_ASSIGN
    530:    CxxOp(                "^=", 2,  3, T, T, F, SS),  // BITWISE_XOR_ASSIGN
    531:    CxxOp(                "|=", 2,  3, T, T, F, SS),  // BITWISE_OR_ASSIGN
    532:    CxxOp(           THROW_STR, 0,  2, F, T, F, SS),  // THROW
    533:    CxxOp(                 ",", 2,  1, F, F, F, NS),  // STATEMENT_SEPARATOR
    534:    CxxOp(                 "$", 0,  0, F, F, F, XX),  // START_OF_EXPRESSION
    535:    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX),  // FALSE
    536:    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX),  // TRUE
    537:    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX),  // NULLPTR
    538:    CxxOp(           ERROR_STR, 0,  0, F, F, F, XX)   // NIL_OPERATOR
* W106 Function does not invoke Debug::ft
    89: Cxx::Access FindAccessControl(const std::string& s)
    810: static void EraseTemplateArgs
    842: static void Union(CxxNamedSet& lhs, const CxxNamedSet& rhs)
    852: void CxxUsageSets::AddBase(CxxNamed* item)
    860: void CxxUsageSets::AddDirect(CxxNamed* item)
    868: void CxxUsageSets::AddForward(CxxNamed* item)
    879: void CxxUsageSets::AddIndirect(CxxNamed* item)
    887: void CxxUsageSets::AddInherit(CxxNamed* item)
    895: void CxxUsageSets::AddUser(CxxNamed* item)
C:\Users\Greg\Documents\rsc\rsc\src\ct\Cxx.h
* W028 Unused data
    448:    constexpr char Unchecked = ' ';  // spacing not determined
* W042 Member could be private
    543:    Numeric(NumericType type, size_t width, bool sign) :
  W082 Adjacent arguments have the same type
    619:    SymbolView(Accessibility a, TypeMatch m, Cxx::Access c,
* W092 Function could be free
    463:    static void UpdateOperator(Cxx::Operator& oper, size_t args); // CxxScope.cpp
* W127 Data could be free
    391:    static const CxxWord Attrs[Cxx::NIL_KEYWORD + 1]; // Parser.cpp
    585:    static const Numeric Short; // CxxRoot.cpp
    586:    static const Numeric uChar; // CxxRoot.cpp
    590:    static const Numeric uShort; // CxxRoot.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.cpp
  W007 Cast down the inheritance hierarchy
    108:       auto cls = static_cast< Class* >(call->Via()->Root());
    281:          static_cast< const Function* >(item)->IsInline())
    1241:       return static_cast< ClassInst* >(list.front());
    1251:    auto area = static_cast<CxxArea*>(GetScope());
    1262:          auto c = static_cast< Class* >(*s);
    2671:       auto func = static_cast< const Function* >(item);
    2713:       auto func = static_cast< const Function* >(item);
    2722:       return tmplt_->FindFriend(static_cast< const CxxScope* >(ref));
  W008 Cast removes const qualification
    1363:       auto self = const_cast< Class* >(this);
    1561:    return const_cast< Class* >(this);
    1725:    return const_cast< Class* >(this);
    2667:       return const_cast< ClassInst* >(this);
* W106 Function does not invoke Debug::ft
    69: static TypeMatch FindMin(const std::vector< TypeMatch >& matches)
    1558: Class* Class::GetClassTemplate() const
    1594: Cxx::Access Class::GetCurrAccess() const
    1611: void Class::GetDecls(CxxNamedSet& items)
    1722: CxxScope* Class::GetTemplate() const
    2196: Class* Class::OuterClass() const
    3308: const FunctionPtrVector* CxxArea::FuncVector(const string& name) const
    3326: void CxxArea::GetDecls(CxxNamedSet& items)
    3366: void CxxArea::InsertFunc(Function* func)
* W117 Line can merge with the next line and be under the length limit
    686:       attrs.test(HasPublicMemberFunction) ||
    717:       attrs.test(HasPublicStaticData) ||
    724:          attrs.test(HasInstantiations) ||
  W119 Argument passed by value is modified
    132/3:    (const CxxScoped* member, const CxxScope* scope, SymbolView* view)
    2781/2:    const CxxScope* scope, CodeFile* file, SymbolView& view) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxArea.h
  W004 C-style cast
    529:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    894:    CxxScope* GetTemplateInstance() const override { return (CxxScope*) this; }
  W007 Cast down the inheritance hierarchy
    987:       const { return static_cast< Namespace* >(GetScope()); }
  W008 Cast removes const qualification
    137:    CxxArea* GetArea() const override { return const_cast< CxxArea* >(this); }
    529:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    574:    Class* GetClass() const override { return const_cast< Class* >(this); }
    894:    CxxScope* GetTemplateInstance() const override { return (CxxScope*) this; }
    1031:       { return const_cast< Namespace* >(this); }
* W042 Member could be private
    92:    Typedef* FindType(const std::string& name) const;
    174:    Enum* FindEnum(const std::string& name) const;
    178:    Enumerator* FindEnumerator(const std::string& name) const;
    392:    void FindCtors(FunctionVector& ctors) const;
    408:    FunctionDefinition GetFuncDefinition(FunctionRole role) const;
    520:    bool AddAnonymousUnion(const ClassPtr& cls) override;
    992:    Namespace* FindNamespace(const std::string& name) const;
* W043 Member could be protected
    68:    const ClassPtrVector* Classes() const { return &classes_; }
    70:    const EnumPtrVector* Enums() const { return &enums_; }
    71:    const ForwardPtrVector* Forws() const { return &forws_; }
    74:    const TypedefPtrVector* Types() const { return &types_; }
    75:    const AsmPtrVector* Assembly() const { return &assembly_; }
    76:    const StaticAssertPtrVector* Asserts() const { return &asserts_; }
* W060 Base class constructor is public
    259:    Class(QualNamePtr& name, Cxx::ClassTag tag);
  W075 Virtual function is public
    102:    virtual Function* FindFunc(const std::string& name,
    110:    virtual Function* MatchFunc(const Function* curr, bool base) const;
    114:    virtual CxxScoped* FindItem(const std::string& name) const;
    284:    virtual ClassInst* EnsureInstance(const TypeName* type);
    297:    virtual Class* BaseClass()
    302:    virtual BaseDecl* GetBaseDecl() const { return base_.get(); }
    341:    virtual Class* GetClassTemplate() const;
    356:    virtual bool DerivesFrom(const Class* cls) const;
    520:    bool AddAnonymousUnion(const ClassPtr& cls) override;
    622:    CxxTokenVector Items() const override;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxCharLiteral.h
* W020 Using statement in header
    35: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.cpp
  W007 Cast down the inheritance hierarchy
    1018:       auto macro = static_cast< Macro* >(ref_);
    1031:       auto macro = static_cast< Macro* >(ref_);
* W106 Function does not invoke Debug::ft
    46: static void AlignLeft(ostream& stream, const string& prefix)
    58: bool IncludesAreSorted(const IncludePtr& incl1, const IncludePtr& incl2)
    193: CxxToken* Define::AutoType() const
    936: bool Macro::WasRead()
    974: CxxScope* MacroName::GetScope() const
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxDirective.h
* W042 Member could be private
    270:    virtual CxxToken* GetValue() const = 0;
    319:    CxxToken* RootType() const override { return GetValue(); }
* W043 Member could be protected
    865:    const std::string& GetText() const { return text_; }
  W050 Data is not private
    340:    size_t refs_ : 16;
  W075 Virtual function is public
    55:    virtual bool IsIncludeGuard() const { return false; }
    270:    virtual CxxToken* GetValue() const = 0;
    275:    virtual bool IsDefined() const { return true; }
    281:    virtual void SetExpr(ExprPtr& rhs);
    319:    CxxToken* RootType() const override { return GetValue(); }
    465:    virtual bool AddElif(Elif* e) { return false; }
    469:    virtual bool AddElse(const Else* e) { return false; }
    473:    virtual bool AddEndif(const Endif* e) { return false; }
    477:    virtual bool HasCompiledCode() const { return compile_; }
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.cpp
  W005 Functional cast
    1769:             return TypeMatch(match - 1);
    2199:    if(item_->GetTypeSpec()->Tags()->PtrCount(false) >= TagCount(ptrs))
  W007 Cast down the inheritance hierarchy
    1723:          auto derived = static_cast< const Class* >(root);
    1834:       auto thisClass = static_cast< Class* >(thisRoot);
    1842:             auto thatClass = static_cast< Class* >(thatRoot);
    1999:    if(AutoType_.SetAutoTypeOn(*static_cast< FuncData* >(item_)))
    2053:       auto type = static_cast< TypeSpec* >(item_);
    2063:       spec->SetReferent(static_cast< CxxScoped* >(item_), nullptr);
    2249:          static_cast< Class* >(root)->BlockCopied(this);
  W075 Virtual function is public
    126:    bool Display(ostream& stream, const string& opts) override;
    138:    bool Display(ostream& stream, const string& opts) override;
    154:    bool Display(ostream& stream, const string& opts) override;
    170:    bool Display(ostream& stream, const string& opts) override;
    198:    bool Display(ostream& stream, const string& opts) override;
* W106 Function does not invoke Debug::ft
    59: static bool CompilingTemplateFunction()
    335: TypeName* Context::FindXrefItem(const string& name)
    347: const Parser* Context::GetParser()
    355: XrefUpdater Context::GetXrefUpdater()
    384: void Context::OnLine(size_t line, Phase phase)
    419: bool Context::OptionIsOn(char opt)
    447: bool Context::ParsingSourceCode()
    455: bool Context::ParsingTemplate()
    468: bool Context::ParsingTemplateInstance()
    493: void Context::PopXrefFrame()
    511: void Context::PushScope(CxxScope* scope, bool hidden)
    520: void Context::PushXrefFrame(XrefUpdater updater)
    527: void Context::PushXrefItem(TypeName* item)
    549: CxxScope* Context::Scope()
    600: void Context::SetOptions(const std::string& opts)
    643: void Context::SetPos(size_t pos)
    658: void Context::SetPos(const CxxLocation& loc)
    1079: OptionalCode* ParseFrame::Optional() const
    1270: CxxScope* ParseFrame::Scope() const
    1277: Cxx::Access ParseFrame::ScopeAccess() const
    1284: Cxx::Access ParseFrame::SetAccess(Cxx::Access access)
    1688: bool StackArg::IsBool() const
    2394: TypeName* XrefFrame::FindItem(const string& name) const
    2406: void XrefFrame::PushItem(TypeName* item)
  W107 Function does not invoke Debug::ft as first statement
    2332:    Debug::ft("Tracepoint.OnLine");
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxExecute.h
  W026 Unused argument
    935/1:    static void Shutdown(NodeBase::RestartLevel level);
    939/1:    static void Startup(NodeBase::RestartLevel level) { }
* W032 Unused function
    160:    size_t Arrays() const;
    850:    static bool ParsingTemplate();
* W042 Member could be private
    164:    size_t Refs() const;
    747:    static Cxx::Access ScopeAccess() { return Frame_->ScopeAccess(); }
    878:    static bool OptionIsOn(char opt);
    886:    static void Trace(CxxTrace::Action act, const CodeFile& file);
  W050 Data is not private
    333:    CxxToken* item_;
  W082 Adjacent arguments have the same type
    287:    TypeMatch CalcMatchWith(const StackArg& that,
    342:    TypeMatch MatchWith(const StackArg& that,
* W092 Function could be free
    743:    static bool AtFileScope(); // CxxToken.cpp
    758:    static Cxx::Access ScopeVisibility(); // CxxArea.cpp
    816:    static void WasCalled(Function* func); // CxxScope.cpp
    850:    static bool ParsingTemplate(); // CxxExecute.cpp
    858:    static void PushXrefFrame(XrefUpdater updater); // CxxScope.cpp
    862:    static void PopXrefFrame(); // CxxScope.cpp
    870:    static void PushXrefItem(TypeName* item); // CxxNamed.cpp
    874:    static TypeName* FindXrefItem(const std::string& name); // CxxScoped.cpp
    884:    static void Trace(CxxTrace::Action act, const CxxToken* token); // CxxExecute.cpp
    885:    static void Trace(CxxTrace::Action act, const StackArg& arg); // CxxExecute.cpp
    886:    static void Trace(CxxTrace::Action act, const CodeFile& file); // CxxExecute.cpp
    887:    static void Trace(CxxTrace::Action act, NodeBase::word err, // CxxExecute.cpp
    892:    static void InsertTracepoint // CtIncrement.cpp
    897:    static void EraseTracepoint // CtIncrement.cpp
    902:    static void ClearTracepoints(); // CtIncrement.cpp
    917:    static void DisplayTracepoints // CtIncrement.cpp
    939:    static void Startup(NodeBase::RestartLevel level) { } // CtModule.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxLocation.cpp
* W106 Function does not invoke Debug::ft
    41: void CxxLocation::SetLoc(CodeFile* file, size_t pos)
    49: void CxxLocation::SetLoc(CodeFile* file, size_t pos, bool internal)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxLocation.h
  W082 Adjacent arguments have the same type
    76:    void UpdatePos(EditorAction action, size_t begin, size_t count, size_t from);
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.cpp
  W005 Functional cast
    4365:    if(TagCount(n) >= ptrs_) return false;
    4383:    if(TagCount(n) >= ptrs_) return false;
    4454:       if(TagCount(n) >= ptrs_) ptrs_ = n + 1;
  W007 Cast down the inheritance hierarchy
    100:             static_cast< Function* >(tfunc)->SetTemplateParm();
    474:          space = static_cast< Namespace* >(item);
    498:          cls = static_cast< Class* >(item);
    552:          item = static_cast< Enum* >(item)->FindEnumerator(name);
    563:          auto tdef = static_cast< Typedef* >(item);
    568:          item = static_cast< CxxScoped* >(root);
    855:    return static_cast< Class* >(root);
    1301:    return (static_cast< Class* >(root)->FindCtor(nullptr) == nullptr);
    2190:    auto cls = (type == Cxx::Class ? static_cast< Class* >(inner) : nullptr);
    2423:       auto func = static_cast< Function* >(ref);
    2852:       TypeSpecPtr spec(static_cast< TypeSpec* >(spec_->Clone()));
    2857:       ExprPtr expr(static_cast<Expression*>(expr_->Clone()));
    3352:          TemplateArgPtr arg(static_cast< TemplateArg* >((*a)->Clone()));
    3657:          auto e = static_cast<const Enum*>(item);
  W008 Cast removes const qualification
    1090:    return const_cast< DataSpec* >(this);
    1656:    const_cast< DataSpec* >(this)->FindReferent();
    3546:    return const_cast< TypeName* >(this);
* W106 Function does not invoke Debug::ft
    204: CxxArea* CxxNamed::GetArea() const
    213: Class* CxxNamed::GetClass() const
    244: CodeFile* CxxNamed::GetDistinctDeclFile() const
    259: CodeFile* CxxNamed::GetImplFile() const
    268: void CxxNamed::GetScopedNames(stringVector& names, bool templates) const
    275: Namespace* CxxNamed::GetSpace() const
    284: void CxxNamed::Instantiating(CxxScopedVector& locals) const
    633: void CxxNamed::strName(ostream& stream, bool fq, const QualName* name) const
    766: const TemplateArgPtrVector* DataSpec::Args() const
    1020: TypeTags DataSpec::GetAllTags() const
    1088: TypeSpec* DataSpec::GetTypeSpec() const
    1225: bool DataSpec::IsAutoDecl() const
    1292: bool DataSpec::IsPOD() const
    1651: CxxScoped* DataSpec::Referent() const
    2008: bool DataSpec::VerifyReferents() const
    2082: const TemplateArgPtrVector* QualName::Args() const
    2134: TypeName* QualName::At(size_t n) const
    2342: CxxScope* QualName::GetScope() const
    2373: TypeName* QualName::GetTemplatedName() const
    2461: TypeName* QualName::Last() const
    2683: size_t QualName::Size() const
    2745: bool QualName::VerifyReferents() const
    2977: CxxScoped* TemplateArg::GetReferent() const
    3297: bool TemplateArg::VerifyReferents() const
    3381: const TemplateArgPtrVector* TypeName::Args() const
    3440: CxxScoped* TypeName::DirectType() const
    3537: TypeName* TypeName::GetTemplatedName() const
    3772: void TypeName::PushBack(TypeNamePtr& type)
    4074: bool TypeName::VerifyReferents() const
    4354: int TypeTags::IsConstPtr() const
    4363: bool TypeTags::IsConstPtr(size_t n) const
    4372: int TypeTags::IsVolatilePtr() const
    4381: bool TypeTags::IsVolatilePtr(size_t n) const
    4421: TagCount TypeTags::PtrCount(bool arrays) const
  W119 Argument passed by value is modified
    2134/1: TypeName* QualName::At(size_t n) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxNamed.h
  W004 C-style cast
    1247:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    1455:    CxxToken* RootType() const override { return (CxxToken*) Referent(); }
  W008 Cast removes const qualification
    738:       { return const_cast< QualName* >(this); }
    1247:    CxxToken* AutoType() const override { return (CxxToken*) this; }
* W042 Member could be private
    265:    virtual bool ResolveTemplate
    625:    TypeName* Last() const;
    792:    bool ResolveTemplate
    936:    bool IsUnboundedArray() const { return array_; }
    1197:    DataSpec(const DataSpec& that);
* W043 Member could be protected
    211:    void DisplayReferent(std::ostream& stream, bool fq) const;
    221:    void strName(std::ostream& stream, bool fq, const QualName* name) const;
    1033:    TypeSpecUser GetUserType() const { return user_; }
  W050 Data is not private
    980:    bool ptrDet_: 1;
    984:    bool refDet_: 1;
  W075 Virtual function is public
    58:    virtual bool IsDeclaredInFunction() const { return false; }
    64:    virtual void SetTemplateParms(TemplateParmsPtr& parms);
    69:    virtual TemplateParms* GetTemplateParms() const { return nullptr; }
    79:    virtual std::string QualifiedName(bool scopes, bool templates)
    85:    virtual std::string ScopedName(bool templates) const;
    91:    virtual void GetScopedNames(stringVector& names, bool templates) const;
    96:    virtual Function* GetFunction() const { return nullptr; }
    103:    virtual CodeFile* GetDeclFile() const { return GetFile(); }
    108:    virtual CodeFile* GetDefnFile() const { return nullptr; }
    131:    virtual CxxScoped* DirectType() const { return Referent(); }
    135:    virtual void FindReferent();
    141:    virtual void SetReferent(CxxScoped* item, const SymbolView* view) const;
    145:    virtual void SetAsReferent(const CxxNamed* user) { }
    152:    virtual StackArg NameToArg(Cxx::Operator op, TypeName* name);
    157:    virtual StackArg MemberToArg
    164:    virtual bool NamesReferToArgs(const NameVector& names,
    171:    virtual std::string ArgString(const TemplateParmToArgMap& tmap) const;
    177:    virtual void Instantiating(CxxScopedVector& locals) const;
    189:    virtual void GetDirectClasses(CxxUsageSets& symbols);
    196:    virtual void GetDirectTemplateArgs(CxxUsageSets& symbols) const;
    201:    virtual bool ItemIsTemplateArg(const CxxNamed* item) const;
    206:    virtual std::string XrefName(bool templates) const;
    494:    bool ResolveTypedef(Typedef* type, size_t n) const override;
    792:    bool ResolveTemplate
    797:    bool ResolveTypedef(Typedef* type, size_t n) const override;
    1041:    virtual Function* GetFuncSpec() const { return nullptr; }
    1050:    virtual TypeTags* Tags() = 0;
    1051:    virtual const TypeTags* Tags() const = 0;
    1055:    virtual void AddArray(ArraySpecPtr& array) = 0;
    1061:    virtual TagCount Ptrs(bool arrays) const = 0;
    1067:    virtual TagCount Refs() const = 0;
    1072:    virtual TagCount Arrays() const = 0;
    1076:    virtual bool HasArrayDefn() const = 0;
    1080:    virtual void EnteringScope(const CxxScope* scope) = 0;
    1084:    virtual void EnterArrays() const = 0;
    1089:    virtual TypeTags GetAllTags() const = 0;
    1094:    virtual std::string TypeTagsString(const TypeTags& tags) const = 0;
    1099:    virtual void DisplayTags(std::ostream& stream) const = 0;
    1103:    virtual void DisplayArrays(std::ostream& stream) const = 0;
    1109:    virtual void SetPtrs(TagCount count) = 0;
    1114:    virtual bool MatchesExactly(const TypeSpec* that) const = 0;
    1118:    virtual void SetTemplateRole(TemplateRole role) const { role_ = role; }
    1122:    virtual void SetUserType(TypeSpecUser user) const { user_ = user; }
    1133:    virtual TypeMatch MatchTemplate(const TypeSpec* that,
    1140:    virtual TypeMatch MatchTemplateArg(const TypeSpec* that) const = 0;
    1145:    virtual std::string AlignTemplateArg(const TypeSpec* thatArg) const = 0;
    1149:    virtual void GetNames(stringVector& names) const = 0;
  W082 Adjacent arguments have the same type
    378:    TypeMatch MatchTemplate(const TypeName* that,
    682:    TypeMatch MatchTemplate(const QualName* that,
    893:    bool SetPointer(size_t n, bool readonly, bool unstable);
    1133:    virtual TypeMatch MatchTemplate(const TypeSpec* that,
    1568:    TypeMatch MatchTemplate(const TemplateArg* that, stringVector& tmpltParms,
* W127 Data could be free
    1201:    static const TypeSpecPtr Bool; // CxxExecute.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.cpp
  W004 C-style cast
    4638:    if(tmplt_ != nullptr) return (CxxScope*) this;
  W007 Cast down the inheritance hierarchy
    89:             auto farg = static_cast< Function* >(a->item_);
    904:       auto cls = static_cast<const Class*>(scope);
    1693:          auto op = static_cast< Operation* >(expr);
    1834:    auto item = static_cast< Data* >(FindTemplateAnalog(this));
    1848:    auto item = static_cast< Data* >(FindTemplateAnalog(this));
    1889:    auto item = static_cast< Data* >(FindTemplateAnalog(this));
    1904:    auto item = static_cast< Data* >(FindTemplateAnalog(this));
    1988:          static_cast< Block* >(GetScope())->EraseItem(this);
    2004:          static_cast< Block* >(GetScope())->ReplaceItem(this, next_.release());
    3667:    else if(!static_cast< Function* >(item)->virtual_)
    4435:       func = static_cast< Function* >(inst->FindTemplateAnalog(this));
    4448:       auto i = FindArg(static_cast< const Argument* >(item), false);
    4495:    return static_cast< Function* >((*cti)->FindInstanceAnalog(this));
    5201:    auto that = static_cast< const Argument* >(FindTemplateAnalog(arg));
    5656:    auto func = static_cast< Function* >(FindTemplateAnalog(this));
    5668:    auto func = static_cast< Function* >(FindTemplateAnalog(this));
    5887:                auto item = static_cast< CxxNamed* >(args.front().item_);
    6076:       auto func = static_cast< Function* >(cls->FindTemplateAnalog(this));
  W008 Cast removes const qualification
    3033:    return FoundFunc(const_cast< Function* >(this), args);
    4404:    auto prev = const_cast< Function* >(this);
    4628:    if(IsTemplate()) return const_cast< Function* >(this);
    4638:    if(tmplt_ != nullptr) return (CxxScope*) this;
  W082 Adjacent arguments have the same type
    185: static TypeMatch MatchTemplate(const string& thisType,
* W106 Function does not invoke Debug::ft
    114: bool FuncDefnsAreSorted(const Function* func1, const Function* func2)
    146: FunctionVector FuncsInArea(const FunctionVector& defns, const CxxArea* area)
    267: bool Block::CrlfOver(Form form) const
    408: CxxToken* Block::FirstStatement() const
    416: Function* Block::GetFunction() const
    876: void ClassData::GetDecls(CxxNamedSet& items)
    985: void ClassData::SetMemInit(const MemberInit* init)
    1520: CodeFile* Data::GetDeclFile() const
    1527: const Data* Data::GetDefn() const
    1536: CodeFile* Data::GetDefnFile() const
    1579: TypeName* Data::GetTemplatedName() const
    1728: bool Data::IsConst() const
    1885: bool Data::WasRead()
    2246: const TemplateArgPtrVector* FuncSpec::Args() const
    2271: TypeSpec* FuncSpec::Clone() const
    2293: void FuncSpec::EnterArrays() const
    2310: void FuncSpec::FindReferent()
    2318: TypeTags FuncSpec::GetAllTags() const
    2325: void FuncSpec::GetNames(stringVector& names) const
    2333: TypeName* FuncSpec::GetTemplatedName() const
    2340: TypeSpec* FuncSpec::GetTypeSpec() const
    2347: bool FuncSpec::HasArrayDefn() const
    2354: void FuncSpec::Instantiating(CxxScopedVector& locals) const
    2362: bool FuncSpec::ItemIsTemplateArg(const CxxNamed* item) const
    2370: bool FuncSpec::MatchesExactly(const TypeSpec* that) const
    2378: TypeMatch FuncSpec::MatchTemplate(const TypeSpec* that,
    2388: TypeMatch FuncSpec::MatchTemplateArg(const TypeSpec* that) const
    2396: bool FuncSpec::NamesReferToArgs(const NameVector& names,
    2422: TagCount FuncSpec::Ptrs(bool arrays) const
    2429: TagCount FuncSpec::Refs() const
    2463: void FuncSpec::SetReferent(CxxScoped* item, const SymbolView* view) const
    2471: const TypeTags* FuncSpec::Tags() const
    2478: TypeTags* FuncSpec::Tags()
    2879: uint32_t Function::CalcHash() const
    4500: FunctionRole Function::FuncRole() const
    4537: FunctionType Function::FuncType() const
    4548: Cxx::Access Function::GetAccess() const
    4556: CodeFile* Function::GetDeclFile() const
    4563: void Function::GetDecls(CxxNamedSet& items)
    4570: const Function* Function::GetDefn() const
    4579: Function* Function::GetDefn()
    4588: CodeFile* Function::GetDefnFile() const
    4597: CxxScope* Function::GetScope() const
    4625: CxxScope* Function::GetTemplate() const
    4636: CxxScope* Function::GetTemplateInstance() const
    4644: TemplateType Function::GetTemplateType() const
    5153: bool Function::IsImplemented() const
    5376: size_t Function::LogOffsetToArgIndex(word offset) const
    6083: bool Function::WasRead()
    6288: void SpaceData::GetDecls(CxxNamedSet& items)
    6374: void SpaceDefn::GetDecls(CxxNamedSet& items)
  W119 Argument passed by value is modified
    5434/2:    const CxxScope* scope, CodeFile* file, SymbolView& view) const
    5674/1: void Function::SetOperator(Cxx::Operator oper)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScope.h
  W004 C-style cast
    392:    CxxToken* AutoType() const override { return (CxxToken*) this; }
  W008 Cast removes const qualification
    392:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    1418:       { return const_cast< Function* >(this); }
  W026 Unused argument
    84/3:       const CxxNamed* item, const CxxScope* scope) const { return nullptr; }
* W030 Unused enumerator
    147:       Multiple   // two statements or more
* W032 Unused function
    1212:    bool IsFinal() const { return GetDecl()->final_; }
* W042 Member could be private
    355:    const Data* GetDecl() const { return (defn_ ? mate_ : this); }
    360:    const Data* GetDefn() const;
    1152:    bool IsDefaulted() const { return GetDefn()->defaulted_; }
    1206:    Function* GetBase() const { return GetDecl()->base_; }
    1272:    size_t MaxArgs() const { return args_.size(); }
    1337:    bool IsInvokedInBase() const;
    1366:    void CheckAccessControl() const override;
    1370:    void CheckIfHiding() const override;
* W043 Member could be protected
    73:    void ReplaceTemplateParms(std::string& code,
    335:    bool IsThreadLocal() const { return thread_local_; }
    339:    bool IsConstexpr() const { return constexpr_; }
    343:    bool WasInited() const { return GetDecl()->inited_; }
  W075 Virtual function is public
    78:    virtual Cxx::Access GetCurrAccess() const { return Cxx::Private; }
    83:    virtual Using* GetUsingFor(const std::string& fqName, size_t prefix,
    91:    virtual void AccessibilityOf
    379:    virtual void Promote
    384:    virtual bool IsUnionMember() const { return false; }
    1366:    void CheckAccessControl() const override;
    1370:    void CheckIfHiding() const override;
  W082 Adjacent arguments have the same type
    379:    virtual void Promote
* W092 Function could be free
    177:    static void AddUsing(Using* use); // CxxScoped.cpp
    182:    static void RemoveUsing(const Using* use); // CxxScoped.cpp
    186:    static void ResetUsings(); // CxxExecute.cpp
    2032:    TypeSpec* Clone() const override; // CxxScope.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.cpp
  W004 C-style cast
    1875:    return (CxxToken*) this;
    2105:    return (CxxToken*) this;
    2908:    return (CxxToken*) this;
    3002:    return (CxxScoped*) this;
    3015:    return (CxxToken*) this;
  W007 Cast down the inheritance hierarchy
    93:          auto func = static_cast< Function* >(GetScope());
    201:       auto& fname = static_cast< Function* >(GetScope())->Name();
    217:    auto cls = static_cast< Class* >(ref);
    241:    auto func = static_cast< Function* >(GetScope());
    305:       auto item = static_cast< Argument* >(FindTemplateAnalog(this));
    344:    auto item = static_cast< Argument* >(FindTemplateAnalog(this));
    356:    auto item = static_cast< Argument* >(FindTemplateAnalog(this));
    392:    GetClass()->EraseSubclass(static_cast< Class* >(GetScope()));
    422:    GetClass()->AddSubclass(static_cast< Class* >(Context::Scope()));
    456:    return static_cast< Class* >(name_->GetReferent());
    1177:          ref = static_cast< const Function* >(ref)->FindRootFunc();
    1529:    auto item = static_cast< Enum* >(FindTemplateAnalog(this));
    1799:    auto item = static_cast< Enumerator* >(FindTemplateAnalog(this));
    1835:    auto item = static_cast< Enumerator* >(FindTemplateAnalog(this));
    2030:    auto item = static_cast< Forward* >(FindTemplateAnalog(this));
    2152:    static_cast< Class* >(grantor_)->EraseFriend(this);
    2251:          space = static_cast< Namespace* >(item);
    2264:          cls = static_cast< Class* >(item);
    2303:          auto tdef = static_cast< Typedef* >(item);
    2308:          item = static_cast< CxxScoped* >(root);
    2496:    auto item = static_cast< Friend* >(grantor_->FindTemplateAnalog(this));
    2641:       static_cast< CxxArea* >(scope)->AddFunc(func);
    2763:    auto func = static_cast< Function* >(GetScope());
    2847:    ref_ = static_cast< ClassData* >(cls->FindData(name_));
    3577:    auto item = static_cast< Typedef* >(FindTemplateAnalog(this));
    3768:          auto item = static_cast< Using* >(FindTemplateAnalog(this));
  W008 Cast removes const qualification
    728:    if(n == 0) return const_cast< CxxScoped* >(this);
    1875:    return (CxxToken*) this;
    2105:    return (CxxToken*) this;
    2542:    const_cast< Friend* >(this)->FindReferent();
    2568:    const_cast< Friend* >(this)->SetScope(decl->GetSpace());
    2579:    const_cast< Friend* >(this)->SetScope(scope);
    2908:    return (CxxToken*) this;
    3002:    return (CxxScoped*) this;
    3015:    return (CxxToken*) this;
* W106 Function does not invoke Debug::ft
    454: Class* BaseDecl::GetClass() const
    578: void CxxScoped::AddFiles(LibItemSet& imSet) const
    806: bool CxxScoped::IsAuto() const
    815: bool CxxScoped::IsClassMember() const
    829: bool CxxScoped::IsConst() const
    838: bool CxxScoped::IsConstPtr() const
    847: bool CxxScoped::IsConstPtr(size_t n) const
    856: bool CxxScoped::IsDeclaredInFunction() const
    864: bool CxxScoped::IsDefinedIn(const CxxArea* area) const
    877: bool CxxScoped::IsIndirect(bool arrays) const
    1141: void CxxScoped::UpdateReference(CxxToken* item, bool insert) const
    1198: CxxTokenVector CxxScoped::XrefItems() const
    1433: void Enum::GetDecls(CxxNamedSet& items)
    1454: TypeSpec* Enum::GetTypeSpec() const
    1693: void Enumerator::GetDecls(CxxNamedSet& items)
    1871: CxxToken* Forward::AutoType() const
    1953: void Forward::GetDecls(CxxNamedSet& items)
    2101: CxxToken* Friend::AutoType() const
    2373: void Friend::GetDecls(CxxNamedSet& items)
    2390: Function* Friend::GetFunction() const
    2399: QualName* Friend::GetQualName() const
    2408: CxxScoped* Friend::GetReferent() const
    2842: CxxScoped* MemberInit::Referent() const
    2900: CxxToken* TemplateParm::AutoType() const
    2994: CxxScoped* TemplateParm::Referent() const
    3007: CxxToken* TemplateParm::RootType() const
    3300: const TemplateArgPtrVector* Typedef::Args() const
    3458: void Typedef::GetDecls(CxxNamedSet& items)
    3474: TypeName* Typedef::GetTemplatedName() const
    3489: void Typedef::Instantiating(CxxScopedVector& locals) const
    3607: bool Typedef::VerifyReferents() const
  W119 Argument passed by value is modified
    3816/1: void Using::SetScope(CxxScope* scope)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxScoped.h
  W004 C-style cast
    206:    CxxScoped* Referent() const override { return (CxxScoped*) this; }
    605:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    1532:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    1629:    CxxToken* AutoType() const override { return (CxxToken*) this; }
  W008 Cast removes const qualification
    206:    CxxScoped* Referent() const override { return (CxxScoped*) this; }
    605:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    1532:    CxxToken* AutoType() const override { return (CxxToken*) this; }
    1629:    CxxToken* AutoType() const override { return (CxxToken*) this; }
  W026 Unused argument
    1798/3:       (const std::string& fqName, size_t prefix, const CxxScope* scope) const;
* W042 Member could be private
    70:    bool IsClassMember() const;
    79:    bool IsSubscopeOf(const std::string& fqSuper) const;
    137:    bool Contains(const CxxToken* item) const;
    614:    void CheckAccessControl() const override;
    1136:    bool ResolveTemplate
    1873:    bool ResolveTypedef(Typedef* type, size_t n) const override { return false; }
* W043 Member could be protected
    106:    CxxScoped* FindInheritedName() const;
    125:    virtual bool IsUnused() const { return false; }
    142:    void DisplayFiles(std::ostream& stream) const;
  W075 Virtual function is public
    59:    virtual bool NameRefersToItem(const std::string& name,
    88:    virtual void AccessibilityTo(const CxxScope* scope, SymbolView& view) const;
    97:    virtual void RecordAccess(Cxx::Access access) const;
    110:    virtual void AddFiles(LibItemSet& imSet) const;
    115:    virtual void UpdateReference(CxxToken* item, bool insert) const;
    125:    virtual bool IsUnused() const { return false; }
    131:    virtual bool CheckIfUnused(Warning warning) const;
    614:    void CheckAccessControl() const override;
    1136:    bool ResolveTemplate
    1873:    bool ResolveTypedef(Typedef* type, size_t n) const override { return false; }
  W082 Adjacent arguments have the same type
    236:    bool GetBracedSpan(size_t& begin, size_t& left, size_t& end) const;
    1788:    Using(QualNamePtr& name, bool space, bool added = false);
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.cpp
  W007 Cast down the inheritance hierarchy
    371:    static_cast< Block* >(GetScope())->EraseItem(this);
    1153:             static_cast< Class* >(result.item_)->InvokeCopyCtor();
* W106 Function does not invoke Debug::ft
    377: void CxxStatement::EnterBlock()
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStatement.h
  W082 Adjacent arguments have the same type
    59:    bool GetSeqSpan(size_t begin, size_t& left, size_t& end) const;
    64:    bool GetParSpan(size_t& begin, size_t& left, size_t& end) const;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.cpp
  W082 Adjacent arguments have the same type
    40: static size_t FindTemplateBegin(const string& name, size_t pos, size_t depth);
  W119 Argument passed by value is modified
    217/2: static size_t FindTemplateBegin(const string& name, size_t pos, size_t depth)
    239/2: static size_t FindTemplateEnd(const string& name, size_t pos)
    762/5:    const string& s2, size_t begin, size_t end, char c)
    798/3: size_t rfind_first_not_of(const string& str, const string& chars, size_t off)
    812/2: size_t rfind_first_of(const string& str, size_t off, const string& chars)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxString.h
* W032 Unused function
    46:    size_t rfind_first_of
    114:    std::string& Prefix(std::string&& scope,
  W082 Adjacent arguments have the same type
    53:    size_t rfind_first_not_of(const std::string& str,
    139:    size_t CompareScopes
    182:    size_t Replace(std::string& code, const std::string& s1,
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxStrLiteral.h
* W020 Using statement in header
    41: using namespace NodeBase;
* W042 Member could be private
    78:    static DataPtr CreateRef()
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.cpp
  W004 C-style cast
    375:    CodeFile* itemFile = (CodeFile*) UINTPTR_MAX;
  W007 Cast down the inheritance hierarchy
    543:    return static_cast< Macro* >(macros.front());
    580:       if((*s)->ScopedName(false) == name) return static_cast< CxxScope* >(*s);
    588:       if((*c)->ScopedName(false) == name) return static_cast< CxxScope* >(*c);
    596:       if(pos != string::npos) return static_cast< CxxScope* >(*s);
    602:       if(pos != string::npos) return static_cast< CxxScope* >(*c);
* W106 Function does not invoke Debug::ft
    251: template< typename T > void GetSymbols
    263: static bool IsSortedByScope(const CxxScoped* item1, const CxxScoped* item2)
    276: static bool IsSortedForXref(const CxxScoped* item1, const CxxScoped* item2)
    415: void CxxSymbols::EraseClass(const Class* cls)
    422: void CxxSymbols::EraseData(const Data* data)
    429: void CxxSymbols::EraseEnum(const Enum* item)
    436: void CxxSymbols::EraseEtor(const Enumerator* etor)
    443: void CxxSymbols::EraseForw(const Forward* forw)
    450: void CxxSymbols::EraseFriend(const Friend* frnd)
    457: void CxxSymbols::EraseFunc(const Function* func)
    464: void CxxSymbols::EraseMacro(const Macro* macro)
    471: void CxxSymbols::EraseSpace(const Namespace* space)
    478: void CxxSymbols::EraseTerm(const Terminal* term)
    485: void CxxSymbols::EraseType(const Typedef* type)
    822: void CxxSymbols::FindTerminal(const string& name, SymbolVector& list) const
    829: void CxxSymbols::InsertClass(Class* cls)
    836: void CxxSymbols::InsertData(Data* data)
    843: void CxxSymbols::InsertEnum(Enum* item)
    850: void CxxSymbols::InsertEtor(Enumerator* etor)
    857: void CxxSymbols::InsertForw(Forward* forw)
    864: void CxxSymbols::InsertFriend(Friend* frnd)
    871: void CxxSymbols::InsertFunc(Function* func)
    878: void CxxSymbols::InsertMacro(Macro* macro)
    885: void CxxSymbols::InsertSpace(Namespace* space)
    892: void CxxSymbols::InsertTerm(Terminal* term)
    899: void CxxSymbols::InsertType(Typedef* type)
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxSymbols.h
* W090 Function could be const
    152:    void InsertClass(Class* cls);
    153:    void InsertData(Data* data);
    154:    void InsertEtor(Enumerator* etor);
    155:    void InsertEnum(Enum* item);
    156:    void InsertForw(Forward* forw);
    157:    void InsertFriend(Friend* frnd);
    158:    void InsertFunc(Function* func);
    159:    void InsertMacro(Macro* macro);
    160:    void InsertSpace(Namespace* space);
    161:    void InsertTerm(Terminal* term);
    162:    void InsertType(Typedef* type);
    166:    void EraseClass(const Class* cls);
    167:    void EraseData(const Data* data);
    168:    void EraseEtor(const Enumerator* etor);
    169:    void EraseEnum(const Enum* item);
    170:    void EraseForw(const Forward* forw);
    171:    void EraseFriend(const Friend* frnd);
    172:    void EraseFunc(const Function* func);
    173:    void EraseMacro(const Macro* macro);
    174:    void EraseSpace(const Namespace* space);
    175:    void EraseTerm(const Terminal* term);
    176:    void EraseType(const Typedef* type);
* W106 Function does not invoke Debug::ft
    258: template< typename T > void EraseSymbol(const CxxScoped* item,
    278: template< typename T > void ListSymbols(const std::string& name,
  W110 Override of Base.Display not found
    97: class CxxSymbols: public NodeBase::Base
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.cpp
  W007 Cast down the inheritance hierarchy
    949:    auto oper = static_cast< Operation* >(item.get());
    975:          auto ante = static_cast< Operation* >(prev.get());
    1034:       auto oper = static_cast< Operation* >(item.get());
    1067:    auto oper = static_cast< Operation* >(prev.get());
    1094:    auto oper = static_cast< Operation* >(item.get());
    1152:    auto oper = static_cast< Operation* >(item.get());
    1175:       auto ante = static_cast< Operation* >(prev.get());
    1336:    Context::PushOp(static_cast< Operation* >(StartOfExpr.get()));
    1884:       inClass = static_cast< Class* >(inRoot);
    1889:       outClass = static_cast< Class* >(outRoot);
    1930:    auto call = static_cast< Operation* >(args_.front().get());
    2325:       func = static_cast< Function* >(proc.item_);
    2339:       cls = static_cast< Class* >(proc.item_);
    2440:    auto cls = static_cast< Class* >(arg.item_->Root());
    2478:       auto newCall = static_cast< Operation* >(args_.front().get());
    2499:    auto cls = static_cast< Class* >(spec.item_->Root());
    2520:       auto ctorCall = static_cast< Operation* >(args_[2].get());
    2544:       cls = static_cast< Class* >(root);
    2746:       area = static_cast< Class* >(targ);
    3116:    auto cls = static_cast< Class* >(root);
    3183:          mem = static_cast< Function* >(mem)->InstantiateFunction(tmplt);
  W008 Cast removes const qualification
    779:       const_cast< CxxToken* >(this) : nullptr);
    824:    CxxToken* prev = const_cast< CxxToken* >(this);
  W082 Adjacent arguments have the same type
    47: static bool GetSpanFailure(size_t& begin, size_t& left, size_t& end)
* W106 Function does not invoke Debug::ft
    59: bool IsSortedByFilePos(const CxxToken* item1, const CxxToken* item2)
    90: bool IsSortedByPos(const CxxToken* item1, const CxxToken* item2)
    701: CxxScope* CxxToken::GetTemplateInstance() const
    710: bool CxxToken::IsInTemplateInstance() const
    717: bool CxxToken::IsPointer(bool arrays) const
    909: bool CxxToken::VerifyReferents() const
    1382: Numeric FloatLiteral::GetNumeric() const
    1441: Numeric IntLiteral::BaseNumeric() const
    1587: CxxToken* Literal::AutoType() const
    1619: CxxToken* Literal::RootType() const
    1635: Cxx::ItemType Literal::Type() const
* W117 Line can merge with the next line and be under the length limit
    2767:    auto sName = (del ?
    2777:          auto vName = (del ?
  W119 Argument passed by value is modified
    730/2:    const CxxToken* item, word offset, const string& info) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxToken.h
  W008 Cast removes const qualification
    515:    virtual CxxToken* RootType() const { return const_cast< CxxToken* >(this); }
* W042 Member could be private
    502:    virtual bool GetSpan(size_t& begin, size_t& left, size_t& end) const;
* W043 Member could be protected
    476:    std::string strLocation() const;
  W075 Virtual function is public
    72:    virtual void Delete();
    76:    virtual void SetLoc(CodeFile* file, size_t pos) const;
    85:    virtual void SetContext(size_t pos);
    95:    virtual void CopyContext(const CxxToken* that, bool internal);
    101:    virtual CxxToken* Clone() const;
    106:    virtual StackArg ResultType() const;
    134:    virtual Cxx::ItemType Type() const { return Cxx::Undefined; }
    138:    virtual void SetScope(CxxScope* scope) { }
    143:    virtual CxxScope* GetScope() const { return nullptr; }
    149:    virtual bool IsForward() const { return false; }
    153:    virtual QualName* GetQualName() const { return nullptr; }
    159:    virtual std::string TypeString(bool arg) const;
    163:    virtual TypeSpec* GetTypeSpec() const { return nullptr; }
    169:    virtual Class* DirectClass() const;
    173:    virtual bool IsConst() const { return false; }
    177:    virtual bool IsVolatile() const { return false; }
    181:    virtual bool IsConstPtr() const { return false; }
    185:    virtual bool IsVolatilePtr() const { return false; }
    189:    virtual bool IsConstPtr(size_t n) const { return false; }
    193:    virtual bool IsVolatilePtr(size_t n) const { return false; }
    201:    virtual bool IsStatic() const { return true; }
    205:    virtual bool IsExtern() const { return false; }
    209:    virtual void SetAccess(Cxx::Access access) { }
    213:    virtual Cxx::Access GetAccess() const { return Cxx::Public; }
    218:    virtual bool IsAuto() const { return false; }
    223:    virtual bool IsIndirect(bool arrays) const { return false; }
    227:    virtual void Creating() { }
    232:    virtual void Instantiate() { }
    236:    virtual bool IsInitializing() const { return false; }
    241:    virtual CxxToken* AutoType() const { return nullptr; }
    246:    virtual Namespace* GetSpace() const { return nullptr; }
    251:    virtual CxxArea* GetArea() const { return nullptr; }
    256:    virtual Class* GetClass() const { return nullptr; }
    261:    virtual CxxScope* GetMate() const { return nullptr; }
    266:    virtual Class* Declarer() const { return GetClass(); }
    270:    virtual CxxScope* GetTemplate() const { return nullptr; }
    274:    virtual const TemplateArgPtrVector* Args() const { return nullptr; }
    280:    virtual TypeName* GetTemplatedName() const;
    284:    virtual CxxScope* GetTemplateInstance() const;
    293:    virtual CxxScoped* FindTemplateAnalog(const CxxToken* item) const;
    298:    virtual Numeric GetNumeric() const { return Numeric::Nil; }
    303:    virtual void GetConvertibleTypes(StackArgVector& types, bool expl) { }
    307:    virtual CxxScoped* Referent() const { return nullptr; }
    312:    virtual bool VerifyReferents() const;
    320:    virtual bool EnterScope() { return true; }
    325:    virtual void EnterBlock();
    330:    virtual void ExitBlock() const { }
    336:    virtual bool AppendUnary() { return false; }
    340:    virtual CxxToken* Back() { return this; }
    345:    virtual bool WasRead() { return false; }
    357:    virtual bool WasWritten(const StackArg* arg, bool direct, bool indirect);
    362:    virtual bool SetNonConst() { return true; }
    367:    virtual void WasMutated(const StackArg* arg) { }
    373:    virtual void RecordUsage() { }
    377:    virtual void UpdateXref(bool insert) { }
    382:    virtual void GetUsages(const CodeFile& file, CxxUsageSets& symbols) { }
    399:    virtual CxxToken* PosToItem(size_t pos) const;
    404:    virtual bool LocateItem(const CxxToken* item, size_t& n)
    410:    virtual CxxScoped* FindNthItem(const std::string& name, size_t& n)
    415:    virtual void Check() const { }
    419:    virtual std::string Trace() const { return NodeBase::EMPTY_STR; }
    423:    virtual CxxTokenSet* Xref() const { return nullptr; }
    427:    virtual bool InLine() const { return true; }
    432:    virtual void Print
    456:    virtual bool IsPOD() const { return GetNumeric().IsPOD(); }
    471:    virtual void UpdatePos(EditorAction action,
    698:    virtual void PushBack(uint32_t c) = 0;
  W082 Adjacent arguments have the same type
    126:    bool GetSpan3(size_t& begin, size_t& left, size_t& end) const;
    357:    virtual bool WasWritten(const StackArg* arg, bool direct, bool indirect);
    471:    virtual void UpdatePos(EditorAction action,
    502:    virtual bool GetSpan(size_t& begin, size_t& left, size_t& end) const;
    871:    Function* FindNewOrDelete(const StackArg& arg, bool del, bool& pod) const;
C:\Users\Greg\Documents\rsc\rsc\src\ct\CxxVector.h
* W106 Function does not invoke Debug::ft
    47: template< typename T > size_t IndexOf
    62: template< class T > void SortAndDisplayItems
    91: template< class T > void SortAndDisplayItemPtrs
    125: template< class T > void EraseItem(std::vector< T* >& vec, const T* item)
    149: template< class T > void EraseItemPtr
C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.cpp
  W005 Functional cast
    1107:       if(int(begin) < info->depth) begin = info->depth;
    2150:    *Cli_->obuf << ": " << Warning(log.warning_);
  W007 Cast down the inheritance hierarchy
    266:       auto func = static_cast< const Function* >(item);
    735:    return static_cast< Namespace* >(scope);
    807:    auto defn = static_cast< Data* >(data->GetMate());
    900:    auto defn = static_cast< Function* >(func->GetMate());
    928:    auto func = static_cast< const Function* >(item);
    1166:    auto oper = static_cast< const Operation* >(log.item_);
    1447:    static_cast< Class* >(log.item_)->SetClassTag(Cxx::StructType);
    1496:          static_cast< Forward* >(*f)->SetClassTag(to);
    1538:    auto decl = static_cast< CxxScope* >(log.item_);
    1700:    auto item = static_cast< CxxScope* >(ParseFileItem(pos, space));
    1713:          auto tname = static_cast< const TypeName* >(*r);
    1727:       UpdateDebugFt(static_cast< Function* >(item));
    1763:    auto func = static_cast< const Function* >(log.item_);
    1833:    static_cast< Class* >(log.item_)->SetClassTag(Cxx::ClassType);
    2092:    auto decl = static_cast< Function* >(log.item_);
    2477:    static_cast< Function* >(log.item_)->SetExplicit(false);
    2573:    static_cast< ClassData* >(log.item_)->SetMutable(false);
    2609:    static_cast< Function* >(log.item_)->SetOverride(false);
    2630:    auto qname = static_cast< const QualName* >(log.item_);
    2694:    static_cast< Function* >(log.item_)->SetVirtual(false);
    2764:       usages.directs.erase(static_cast< CxxNamed* >(*i));
    2765:       usages.indirects.erase(static_cast< CxxNamed* >(*i));
    2837:          auto data = static_cast< const Data* >(*i);
    2851:             auto func = static_cast< const Function* >(*i);
    2865:             auto data = static_cast< const Data* >(*i);
    3015:    return FindSigEnd(static_cast< const Function* >(log.item_));
    3329:    auto data = static_cast< Data* >(log.item_);
    3396:    auto func = static_cast< Function* >(log.item_);
    3487:    auto data = static_cast< const Data* >(log.item_);
    4067:    auto data = static_cast< Data* >(aref);
    4074:    ReplaceImpl(static_cast< Function* >(log.item_));
    4225:    auto func = static_cast< Function* >(log.item_);
    4576:    auto cls = static_cast< Class* >(log.item_);
    4877:    auto cls = static_cast< Class* >(item);
    5318:       ns = static_cast< Namespace* >(ref)->OuterSpace();
    5394:    auto func = static_cast< const Function* >(log.item_);
    5475:    auto func = static_cast<const Function*>(log.item_);
    5485:       auto slit = static_cast< StrLiteral* >(arg);
    5499:    auto data = static_cast< SpaceData* >(arg->Referent());
    5506:    auto slit = static_cast< StrLiteral* >(file_->PosToItem(lpos));
    5533:    static_cast< Ifndef* >(log.item_)->ChangeName(guard);
    5598:    auto type = static_cast< TypeName* >(log.item_);
    6165:    static_cast< Function* >(log.item_)->SetExplicit(true);
    6214:    static_cast< Function* >(log.item_)->SetOverride(true);
    6318:    static_cast< Function* >(log.item_)->SetVirtual(true);
    6606:       auto items = GetItemsForDefn(static_cast< const CxxScope* >(next));
  W082 Adjacent arguments have the same type
    579: static void DebugFtNames(const Function* func, string& flit, string& fvar)
    949: static bool ItemIsUsedBetween(const CxxToken* item, size_t begin, size_t end)
    1006: static void Rename(string& code, const string& oldName, const string& newName)
* W106 Function does not invoke Debug::ft
    1990: size_t Editor::CommitCount() { return Commits_; }
    4857: static FunctionRole WarningToRole(Warning log)
  W119 Argument passed by value is modified
    1933/1: bool Editor::CodeFollowsImmediately(size_t pos) const
    1948/1: bool Editor::CommentFollows(size_t pos) const
    4376/1: word Editor::InsertForward(size_t pos,
    4544/1:    (size_t pos, const string& nspace, const string& forward)
    5170/2: CxxToken* Editor::ParseFileItem(size_t pos, Namespace* ns) const
    5363/1: void Editor::Rename(size_t pos, const string& oldName, const string& newName)
    6596/3:    const CxxToken* item, const CxxToken* next, ItemDefnAttrs& attrs) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\Editor.h
* W020 Using statement in header
    47: using namespace NodeBase;
    48: using std::string;
  W026 Unused argument
    170/1:    word ChangeCast(const CodeWarning& log);
    171/1:    word ChangeClassToNamespace(const CodeWarning& log);
    174/1:    word ChangeOperator(const CodeWarning& log);
    179/1:    word EraseCast(const CodeWarning& log);
    180/1:    word EraseClass(const CodeWarning& log);
    193/1:    word InsertCopyCtorCall(const CodeWarning& log);
    194/1:    word InsertDataInit(const CodeWarning& log);
    196/1:    word InsertDisplay(const CodeWarning& log);
    197/1:    word InsertEnumName(const CodeWarning& log);
    198/1:    word InsertFallthrough(const CodeWarning& log);
    203/1:    word InsertMemberInit(const CodeWarning& log);
    205/1:    word InsertPODCtor(const CodeWarning& log);
    206/1:    word InsertPureVirtual(const CodeWarning& log);
    208/1:    word MoveDefine(const CodeWarning& log);
    209/1:    word MoveMemberInit(const CodeWarning& log);
    213/1:    word ReplaceHeading(const CodeWarning& log);
    214/1:    word ReplaceName(const CodeWarning& log);
    418/1:    word FixInvokers(const CodeWarning& log);
    427/1:    word ChangeFunctionToMember(const Function* func, word offset);
    427/2:    word ChangeFunctionToMember(const Function* func, word offset);
    428/1:    word ChangeInvokerToMember(const Function* func, word offset);
    428/2:    word ChangeInvokerToMember(const Function* func, word offset);
    429/1:    word EraseArgument(const Function* func, word offset);
    429/2:    word EraseArgument(const Function* func, word offset);
    430/1:    word EraseDefaultValue(const Function* func, word offset);
    430/2:    word EraseDefaultValue(const Function* func, word offset);
    431/1:    word EraseParameter(const Function* func, word offset);
    431/2:    word EraseParameter(const Function* func, word offset);
    433/1:    word InsertArgument(const Function* func, word offset);
    433/2:    word InsertArgument(const Function* func, word offset);
    434/1:    word SplitVirtualFunction(const Function* func);
* W032 Unused function
    422:    word FixInvoker(const Function* func, const CodeWarning& log);
  W082 Adjacent arguments have the same type
    106:    void Rename(size_t pos, const string& oldName, const string& newName);
    262:    bool AdjustHorizontally(size_t pos, size_t len, const string& spacing);
    298:    word InsertForward(size_t pos, const string& nspace, const string& forward);
    303:    word InsertNamespaceForward(size_t pos,
    320:    static void ChangeForwards
    367:    void FindFreeItemPos(const Namespace* space, const string& name,
    377:    CxxItemVector FindDeclRange
    506:    void UpdateItemDefnAttrs(const CxxToken* prev,
    512:    word UpdateItemDefnLoc(const CxxToken* prev,
    567:    bool GetSpan(const CxxToken* item, size_t& begin, size_t& end);
    595:    size_t Replace(size_t pos, size_t count, const string& code);
    642:    void UpdatePos(EditorAction action,
* W088 Argument could be const
    507/4:       const CxxToken* item, const CxxToken* next, ItemDefnAttrs& attrs) const;
* W092 Function could be free
    118:    static size_t CommitCount(); // CodeFileSet.cpp
    154:    static void ReportFix(const CodeWarning* log, word rc); // Editor.cpp
    170:    word ChangeCast(const CodeWarning& log); // Editor.cpp
    171:    word ChangeClassToNamespace(const CodeWarning& log); // Editor.cpp
    174:    word ChangeOperator(const CodeWarning& log); // Editor.cpp
    179:    word EraseCast(const CodeWarning& log); // Editor.cpp
    180:    word EraseClass(const CodeWarning& log); // Editor.cpp
    193:    word InsertCopyCtorCall(const CodeWarning& log); // Editor.cpp
    194:    word InsertDataInit(const CodeWarning& log); // Editor.cpp
    196:    word InsertDisplay(const CodeWarning& log); // Editor.cpp
    197:    word InsertEnumName(const CodeWarning& log); // Editor.cpp
    198:    word InsertFallthrough(const CodeWarning& log); // Editor.cpp
    203:    word InsertMemberInit(const CodeWarning& log); // Editor.cpp
    205:    word InsertPODCtor(const CodeWarning& log); // Editor.cpp
    206:    word InsertPureVirtual(const CodeWarning& log); // Editor.cpp
    208:    word MoveDefine(const CodeWarning& log); // Editor.cpp
    209:    word MoveMemberInit(const CodeWarning& log); // Editor.cpp
    213:    word ReplaceHeading(const CodeWarning& log); // Editor.cpp
    214:    word ReplaceName(const CodeWarning& log); // Editor.cpp
    359:    static void QualifyClassItems // Editor.cpp
    418:    word FixInvokers(const CodeWarning& log); // Editor.cpp
    427:    word ChangeFunctionToMember(const Function* func, word offset); // Editor.cpp
    428:    word ChangeInvokerToMember(const Function* func, word offset); // Editor.cpp
    429:    word EraseArgument(const Function* func, word offset); // Editor.cpp
    430:    word EraseDefaultValue(const Function* func, word offset); // Editor.cpp
    431:    word EraseParameter(const Function* func, word offset); // Editor.cpp
    433:    word InsertArgument(const Function* func, word offset); // Editor.cpp
    434:    word SplitVirtualFunction(const Function* func); // Editor.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.cpp
  W005 Functional cast
    147:          type = LibTokenType(i);
* W099 Line contains adjacent spaces
    90:    OperatorInfo(" ",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpNil
    91:    OperatorInfo("(",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpLeftPar
    92:    OperatorInfo(")",  0, ERR_SET,  ERR_SET,  ERR_SET),   // OpRightPar
    93:    OperatorInfo("&",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpIntersection
    94:    OperatorInfo("-",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpDifference
    95:    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpUnion
    96:    OperatorInfo("|",  2, ANY_SET,  ANY_SET,  ANY_SET),   // OpAutoUnion
    97:    OperatorInfo("d",  1, DIR_SET,  ANY_SET,  ERR_SET),   // OpDirectories
    98:    OperatorInfo("f",  1, FILE_SET, ANY_SET,  ERR_SET),   // OpFiles
    111:    OperatorInfo("db", 1, ITEM_SET, ANY_SET,  ERR_SET),   // OpDeclaredBy
    114:    OperatorInfo("rb", 1, ITEM_SET, ANY_SET,  ERR_SET),   // OpReferencedBy
* W106 Function does not invoke Debug::ft
    133: const OperatorInfo* OperatorInfo::GetAttrs(LibTokenType type)
    141: bool OperatorInfo::GetType(const string& op, LibTokenType& type)
  W119 Argument passed by value is modified
    488/1: LibExprErr Interpreter::ApplyOperator(bool operand)
    599/1: LibrarySet* Interpreter::Error(LibExprErr err) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\Interpreter.h
* W092 Function could be free
    74:    static bool IsOperator(const std::string& s); // Library.cpp
  W110 Override of Base.Display not found
    48: class Interpreter : public NodeBase::Base
C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.cpp
  W005 Functional cast
    2305:          fp *= std::pow(10.0, int(num));
    2412:          oper = Cxx::Operator(match->second);
  W007 Cast down the inheritance hierarchy
    3194:          auto def = static_cast< Define* >(item);
* W106 Function does not invoke Debug::ft
    87: static IndentRule ClassifyIndent(string& id)
    810: word Lexer::CheckDepth(size_t n) const
    860: int Lexer::CheckLineMerge(size_t n) const
    1285: size_t Lexer::CurrBegin(size_t pos) const
    1311: size_t Lexer::CurrEnd(size_t pos) const
    2095: const LineInfo* Lexer::GetLineInfo(size_t pos) const
    2104: LineInfo* Lexer::GetLineInfo(size_t pos)
    2113: size_t Lexer::GetLineNum(size_t pos) const
    2137: size_t Lexer::GetLineStart(size_t line) const
    2214: bool Lexer::GetNthLine(size_t n, string& s) const
    2727: bool Lexer::LineHasTrailingCommentAt(size_t n, size_t offset) const
    2809: size_t Lexer::LineSize(size_t pos) const
    2852: size_t Lexer::NextBegin(size_t pos) const
    2967: size_t Lexer::NextPos(size_t pos) const
    3209: size_t Lexer::PrevBegin(size_t pos) const
    3285: void Lexer::SetDepth(int depth1, int depth2, bool merge)
  W119 Argument passed by value is modified
    1285/1: size_t Lexer::CurrBegin(size_t pos) const
    1344/1: size_t Lexer::Find(size_t pos, const string& str) const
    1361/3: size_t Lexer::FindClosing(char lhc, char rhc, size_t pos) const
    1473/2: size_t Lexer::FindFirstOf(const string& targs, size_t pos) const
    1592/1: size_t Lexer::FindLineEnd(size_t pos) const
    1633/1: size_t Lexer::FindNonBlank(size_t pos) const
    1650/1: size_t Lexer::FindWord(size_t pos, const string& id) const
    1996/2: size_t Lexer::GetHexNum(int64_t& num, size_t max)
    2019/1: bool Lexer::GetIncludeFile(size_t pos, string& file, bool& angle) const
    2644/1: size_t Lexer::LineFind(size_t pos, const string& str) const
    2676/1: size_t Lexer::LineFindFirstOf(size_t pos, const std::string& chars) const
    2707/1: size_t Lexer::LineFindNonBlank(size_t pos) const
    2884/1: string Lexer::NextIdentifier(size_t pos) const
    2930/1: size_t Lexer::NextLineIndentation(size_t pos) const
    2945/1: string Lexer::NextOperator(size_t pos) const
    2967/1: size_t Lexer::NextPos(size_t pos) const
    3103/1: bool Lexer::NoCodeFollows(size_t pos) const
    3209/1: size_t Lexer::PrevBegin(size_t pos) const
    3240/1: size_t Lexer::Rfind(size_t pos, const std::string& str) const
    3255/1: size_t Lexer::RfindFirstOf(size_t pos, const std::string& chars) const
    3270/1: size_t Lexer::RfindNonBlank(size_t pos) const
    3341/1: size_t Lexer::SkipCharLiteral(size_t pos) const
    3384/1: size_t Lexer::SkipStrLiteral(size_t pos, bool& fragmented) const
    3417/1: size_t Lexer::SkipTemplateSpec(size_t pos) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\Lexer.h
* W032 Unused function
    448:    size_t LineFindFirstOf(size_t pos, const std::string& chars) const;
* W042 Member could be private
    160:    bool Advance();
    364:    const LineInfo* GetLineInfo(size_t pos) const;
    414:    bool LineHasTrailingCommentAt(size_t n, size_t offset) const;
    452:    size_t LineRfindFirstOf(size_t pos, const std::string& chars) const;
    528:    NodeBase::word CheckDepth(size_t n) const;
* W043 Member could be protected
    376:    size_t PrevBegin(size_t pos) const;
    388:    LineType PosToType(size_t pos) const;
    392:    bool IsBlankLine(size_t pos) const;
    396:    size_t LineSize(size_t pos) const;
    400:    bool OnSameLine(size_t pos1, size_t pos2) const;
    405:    int CompareCode(size_t pos, const std::string& str) const;
    409:    size_t FindComment(size_t pos) const;
    424:    size_t LineFindNext(size_t pos) const;
    428:    bool IsFirstNonBlank(size_t pos) const;
    432:    bool NoCodeFollows(size_t pos) const;
    438:    size_t LineFind(size_t pos, const std::string& str) const;
    442:    size_t LineRfind(size_t pos, const std::string& str) const;
    456:    size_t LineFindNonBlank(size_t pos) const;
    460:    size_t LineRfindNonBlank(size_t pos) const;
    472:    size_t FindNonBlank(size_t pos) const;
  W050 Data is not private
    564:    std::string code_;
    568:    CodeFile* file_;
* W060 Base class constructor is public
    79:    Lexer();
  W082 Adjacent arguments have the same type
    257:    size_t FindClosing(char lhc, char rhc, size_t pos = std::string::npos) const;
    578:    LineType CalcLineType(size_t n, bool& cont, bool& c_comment);
    656:    void SetDepth(int depth1, int depth2, bool merge = true);
C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.cpp
  W007 Cast down the inheritance hierarchy
    668:             auto f = static_cast< const Function* >(elem);
C:\Users\Greg\Documents\rsc\rsc\src\ct\Library.h
* W020 Using statement in header
    46: using namespace NodeBase;
* W053 Data could be const
    237:    LibraryVarSet* varSet_;
  W082 Adjacent arguments have the same type
    74:    NodeBase::word Import
    108:    NodeBase::word Assign(CliThread& cli, const std::string& name,
    137:    NodeBase::word Rename(CliThread& cli, const std::string& oldName,
* W090 Function could be const
    80:    CodeFile* EnsureFile(const std::string& file, CodeDir* dir = nullptr);
    108:    NodeBase::word Assign(CliThread& cli, const std::string& name,
    125:    NodeBase::word Purge(const std::string& name, std::string& expl);
* W092 Function could be free
    137:    NodeBase::word Rename(CliThread& cli, const std::string& oldName, // CtIncrement.cpp
* W127 Data could be free
    151:    static NodeBase::fixed_string SubsDir; // CodeDir.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.cpp
* W106 Function does not invoke Debug::ft
    34: bool IsSortedByName(const LibraryItem* item1, const LibraryItem* item2)
    78: bool LibItemSort::operator()
C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryItem.h
  W027 Unused class
    77: struct LibItemSort
  W075 Virtual function is public
    44:    virtual const std::string& Name() const;
    48:    virtual void Rename(const std::string& name);
    52:    virtual void GetDecls(CxxNamedSet& items) { }
C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.cpp
* W106 Function does not invoke Debug::ft
    97: LibrarySet* LibrarySet::AffectedBy() const
    104: LibrarySet* LibrarySet::Affecters() const
    111: LibrarySet* LibrarySet::Assign(LibrarySet* that)
    128: LibrarySet* LibrarySet::CommonAffecters() const
    169: LibrarySet* LibrarySet::Create
    177: LibrarySet* LibrarySet::DeclaredBy() const
    184: LibrarySet* LibrarySet::Declarers() const
    191: LibrarySet* LibrarySet::Definitions() const
    198: LibrarySet* LibrarySet::Difference(const LibrarySet* that) const
    205: LibrarySet* LibrarySet::Directories() const
    230: LibrarySet* LibrarySet::FileName(const LibrarySet* that) const
    237: LibrarySet* LibrarySet::Files() const
    244: LibrarySet* LibrarySet::FileType(const LibrarySet* that) const
    269: LibrarySet* LibrarySet::FoundIn(const LibrarySet* that) const
    288: LibrarySet* LibrarySet::Implements() const
    295: LibrarySet* LibrarySet::Intersection(const LibrarySet* that) const
    302: bool LibrarySet::IsReadOnly() const
    309: bool LibrarySet::IsTemporary() const
    341: LibrarySet* LibrarySet::MatchString(const LibrarySet* that) const
    348: LibrarySet* LibrarySet::NeededBy() const
    355: LibrarySet* LibrarySet::Needers() const
    372: word LibrarySet::NotImplemented(string& expl) const
    384: LibrarySet* LibrarySet::OpError(c_string op) const
    412: LibrarySet* LibrarySet::ReferencedBy() const
    419: LibrarySet* LibrarySet::Referencers() const
    516: LibrarySet* LibrarySet::Union(const LibrarySet* that) const
    523: LibrarySet* LibrarySet::UsedBy(bool self) const
    530: LibrarySet* LibrarySet::Users(bool self) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\LibrarySet.h
* W065 Base class virtual destructor is not public
    196:    virtual ~LibrarySet();
  W075 Virtual function is public
    80:    virtual LibSetType GetType() const;
    86:    virtual NodeBase::word Check(NodeBase::CliThread& cli,
    93:    virtual NodeBase::word Count(std::string& result) const;
    99:    virtual NodeBase::word Countlines(std::string& result) const;
    105:    virtual NodeBase::word Fix(NodeBase::CliThread& cli,
    111:    virtual NodeBase::word Format(std::string& expl) const;
    119:    virtual NodeBase::word Parse
    126:    virtual NodeBase::word Scan(std::ostream& stream,
    133:    virtual NodeBase::word Sort(std::ostream& stream, std::string& expl) const;
    137:    virtual BuildOrder SortInBuildOrder() const;
    142:    virtual LibrarySet* Assign(LibrarySet* that);
    143:    virtual LibrarySet* Intersection(const LibrarySet* that) const;
    144:    virtual LibrarySet* Difference(const LibrarySet* that) const;
    145:    virtual LibrarySet* Union(const LibrarySet* that) const;
    146:    virtual LibrarySet* Directories() const;
    147:    virtual LibrarySet* Files() const;
    148:    virtual LibrarySet* FileName(const LibrarySet* that) const;
    149:    virtual LibrarySet* FileType(const LibrarySet* that) const;
    150:    virtual LibrarySet* MatchString(const LibrarySet* that) const;
    151:    virtual LibrarySet* FoundIn(const LibrarySet* that) const;
    152:    virtual LibrarySet* Implements() const;
    153:    virtual LibrarySet* UsedBy(bool self) const;
    154:    virtual LibrarySet* Users(bool self) const;
    155:    virtual LibrarySet* AffectedBy() const;
    156:    virtual LibrarySet* Affecters() const;
    157:    virtual LibrarySet* CommonAffecters() const;
    158:    virtual LibrarySet* NeededBy() const;
    159:    virtual LibrarySet* Needers() const;
    160:    virtual LibrarySet* DeclaredBy() const;
    161:    virtual LibrarySet* Declarers() const;
    162:    virtual LibrarySet* Definitions() const;
    163:    virtual LibrarySet* ReferencedBy() const;
    164:    virtual LibrarySet* Referencers() const;
  W120 Function returns non-const reference or pointer to member data
    76:    LibItemSet& Items() { return items_; }
C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryTypes.h
* W053 Data could be const
    64:    size_t level;    // the file's level in the build
* W054 Data could be const pointer
    63:    CodeFile* file;  // the file
C:\Users\Greg\Documents\rsc\rsc\src\ct\LibraryVarSet.h
* W042 Member could be private
    53:    void to_str(stringVector& strings, bool verbose) const override;
  W075 Virtual function is public
    53:    void to_str(stringVector& strings, bool verbose) const override;
C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.cpp
  W007 Cast down the inheritance hierarchy
    455:    auto op = static_cast< Operation* >(token.get());
    491:    auto op = static_cast< Operation* >(call.get());
    793:    auto brace = static_cast<BraceInit*>(token.get());
    860:    auto cast = static_cast< Operation* >(token.get());
    897:    auto c = static_cast< Catch* >(statement.get());
    1026:    static_cast< ClassData* >(data.get())->SetMutable(mute);
    1027:    static_cast< ClassData* >(data.get())->SetWidth(width);
    1185:    auto cond = static_cast< Operation* >(token.get());
    1458:    auto cast = static_cast< Operation* >(token.get());
    1619:    auto op = static_cast< Operation* >(token.get());
    1643:    auto delOp = static_cast< Operation* >(token.get());
    1669:    auto d = static_cast< Do* >(statement.get());
    1867:    auto f = static_cast< For* >(statement.get());
    1969:       static_cast< FuncData* >(data.get())->SetExpression(expr);
    1988:          typeSpec.reset(static_cast< TypeSpec* >(prev->GetTypeSpec()->Clone()));
    2021:          curr = static_cast< FuncData* >(data.get());
    2298:             static_cast< If* >(first)->SetElseIf();
    2304:    auto i = static_cast< If* >(statement.get());
    2466:    auto inner = static_cast< Namespace* >(outer)->EnsureNamespace(name);
    2508:    auto newOp = static_cast< Operation* >(token.get());
    2527:    static_cast< Operation* >(token.get())->SetNew();
    2579:    auto op = static_cast< Operation* >(token.get());
    2993:    static_cast< Return* >(statement.get())->AddExpr(expr);
    3038:    auto op = static_cast< Operation* >(token.get());
    3279:    auto op = static_cast< Operation* >(token.get());
    3303:    auto s = static_cast< Switch* >(statement.get());
    3417:    auto op = static_cast< Operation* >(token.get());
    3449:    auto t = static_cast< Try* >(statement.get());
    3507:    auto op = static_cast< Operation* >(token.get());
    3797:    auto w = static_cast< While* >(statement.get());
    4156:          auto op = static_cast< Operation* >(token)->Op();
  W008 Cast removes const qualification
    4417:       func->SetTemplate(const_cast< Function* >(tmplt));
  W082 Adjacent arguments have the same type
    71: static bool SetCompoundType
* W106 Function does not invoke Debug::ft
    301: size_t Parser::CurrPos() const
  W119 Argument passed by value is modified
    1100/2: bool Parser::GetCompoundType(const QualName* name, Cxx::Type type)
    2381/1: size_t Parser::GetLineNum(size_t pos) const
    4209/2: void Parser::Log(Warning warning, size_t pos) const
C:\Users\Greg\Documents\rsc\rsc\src\ct\Parser.h
  W082 Adjacent arguments have the same type
    482:    bool GetParExpr(ExprPtr& expr, bool omit, bool opt = false);
* W092 Function could be free
    171:    static void ResetStats(); // CtIncrement.cpp
    175:    static void DisplayStats(std::ostream& stream); // CtIncrement.cpp
    602:    static bool Backup(size_t cause); // Parser.cpp
    629:    static std::string Indent(); // Parser.cpp
C:\Users\Greg\Documents\rsc\rsc\src\ct\SetOperations.h
  W082 Adjacent arguments have the same type
    33:    void SetDifference
    42:    void SetIntersection
    51:    void SetUnion
C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.cpp
  W006 reinterpret_cast
    214:    auto em = reinterpret_cast< EM_Message* >(buff->PayloadPtr());
    513:    auto& dm = reinterpret_cast< const DM_Message& >(message);
    514:    auto tokens = reinterpret_cast< const Token* >(&dm.tokens);
    640:    auto& em = reinterpret_cast< const EM_Message& >(message);
    1293:       auto& rm = reinterpret_cast< const RM_Message& >(message);
    2082:    auto bm = reinterpret_cast< DipMessage* >(buff->PayloadPtr());
    2154:    auto im = reinterpret_cast< IM_Message* >(buff->PayloadPtr());
    2295:    auto dm = reinterpret_cast< DM_Message* >(buff->PayloadPtr());
    2299:    message.get_tokens(reinterpret_cast< Token* >(&dm->tokens), count);
* W106 Function does not invoke Debug::ft
    431: BaseBot::StartupResult BaseBot::initialise(const StartupParameters& parameters)
    438: BaseBot* BaseBot::instance()
* W117 Line can merge with the next line and be under the length limit
    1707:          (press->message == contents))
C:\Users\Greg\Documents\rsc\rsc\src\dip\BaseBot.h
* W020 Using statement in header
    39: using namespace NodeBase;
* W030 Unused enumerator
    61:       FIRST_BOT_SPECIFIC_ERROR
  W075 Virtual function is public
    90:    virtual bool process_command_line_parameter(char token, std::string& value);
    96:    virtual std::string report_command_line_parameters();
  W082 Adjacent arguments have the same type
    143:    void send_press_to_server(const TokenMessage& press_to,
    272:    virtual void process_not_ccd_message(const TokenMessage& message,
    501:    virtual void report_failed_press
* W090 Function could be const
    205:    virtual void process_ccd_message
    211:    virtual void process_drw_message(const TokenMessage& message);
    242:    virtual void process_out_message(const TokenMessage& message);
    250:    virtual void process_smr_message(const TokenMessage& message);
    267:    virtual void process_adm_message(const TokenMessage& message);
    272:    virtual void process_not_ccd_message(const TokenMessage& message,
    466:    virtual void process_hlo_message(const TokenMessage& message);
    471:    virtual void process_map_message(const TokenMessage& message);
    475:    virtual void process_mdf_message(const TokenMessage& message);
    483:    virtual void process_sco_message(const TokenMessage& message);
    487:    virtual void process_now_message(const TokenMessage& message);
    491:    virtual void process_slo_message(const TokenMessage& message);
* W092 Function could be free
    178:    void cancel_event(BotEvent event); // BaseBot.cpp
    523:    static void report_ccd(const Token& power, bool disorder); // BaseBot.cpp
    543:    static void report_out(const Token& power); // BaseBot.cpp
    555:    void report_exit(c_string reason); // BaseBot.cpp
    715:    static bool send_buff(DipIpBuffer& buff); // BaseBot.cpp
C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.cpp
  W006 reinterpret_cast
    187:    auto msg = reinterpret_cast< BM_Message* >(buff->PayloadPtr());
    216:    auto message = reinterpret_cast< const DipMessage* >(ipb->HeaderPtr());
  W007 Cast down the inheritance hierarchy
    203:    DipIpBufferPtr ipb(static_cast< DipIpBuffer* >(msg));
C:\Users\Greg\Documents\rsc\rsc\src\dip\BotThread.h
* W020 Using statement in header
    38: using namespace NodeBase;
* W053 Data could be const
    112:       BotEvent event;         // event
* W055 Data need not be mutable
    113:       mutable uint32_t secs;  // delay
C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.cpp
  W006 reinterpret_cast
    100:       auto message = reinterpret_cast< const DipMessage* >(buff_->HeaderPtr());
    129:    return reinterpret_cast< DipHeader* >(buff_->HeaderPtr());
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTrace.h
* W020 Using statement in header
    35: using namespace NodeBase;
* W032 Unused function
    72:    DipHeader* Header() const;
C:\Users\Greg\Documents\rsc\rsc\src\dip\BotTracer.h
* W020 Using statement in header
    30: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\dip\ConvoySubversion.cpp
* W106 Function does not invoke Debug::ft
    29: void ConvoySubversion::clear()  // <b>
    37: void ConvoySubversion::decrement()
C:\Users\Greg\Documents\rsc\rsc\src\dip\DipModule.h
* W020 Using statement in header
    30: using namespace NodeBase;
  W027 Unused class
    38: class DipModule : public Module
C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.cpp
  W006 reinterpret_cast
    62:       reinterpret_cast< const IM_Message* >(this)->Display(stream);
    65:       reinterpret_cast< const RM_Message* >(this)->Display(stream);
    68:       reinterpret_cast< const DM_Message* >(this)->Display(stream);
    71:       reinterpret_cast< const FM_Message* >(this)->Display(stream);
    74:       reinterpret_cast< const EM_Message* >(this)->Display(stream);
    77:       reinterpret_cast< const BM_Message* >(this)->Display(stream);
    198:       auto header = reinterpret_cast< const DipHeader* >(source);
    208:       auto header = reinterpret_cast< const DipHeader* >(payload);
    227:    auto msg = reinterpret_cast< DipHeader* >(buff.PayloadPtr());
    233:       auto im = reinterpret_cast< IM_Message* >(src);
    241:       auto dm = reinterpret_cast< DM_Message* >(src);
    252:       auto em = reinterpret_cast< EM_Message* >(src);
    279:    auto msg = reinterpret_cast< DipHeader* >(buff.PayloadPtr());
    288:       auto rm = reinterpret_cast< RM_Message* >(msg);
    299:       auto dm = reinterpret_cast< DM_Message* >(msg);
    310:       auto em = reinterpret_cast< EM_Message* >(msg);
    331:    auto header = reinterpret_cast< const DipHeader* >(payload);
    356:    auto msg = reinterpret_cast< BM_Message* >(buff->PayloadPtr());
  W007 Cast down the inheritance hierarchy
    274:    auto dipbuff = static_cast< DipIpBuffer* >(&buff);
    327:    DipIpBufferPtr dipbuff(static_cast< DipIpBuffer* >(buff.release()));
  W009 Pointer arithmetic
    211:       dest = payload + received;
C:\Users\Greg\Documents\rsc\rsc\src\dip\DipProtocol.h
* W020 Using statement in header
    39: using namespace NodeBase;
    40: using namespace NetworkBase;
* W028 Unused data
    162: constexpr ProtocolError IM_TIMEOUT = 0x01;
    163: constexpr ProtocolError IM_EXPECTED = 0x02;
    164: constexpr ProtocolError IM_WRONG_ENDIAN = 0x03;
    165: constexpr ProtocolError IM_WRONG_MAGIC_NUMBER = 0x04;
    166: constexpr ProtocolError IM_INCOMPATIBLE_VERSION = 0x05;
    167: constexpr ProtocolError IM_REPEATED = 0x06;
    168: constexpr ProtocolError IM_FROM_SERVER = 0x07;
    169: constexpr ProtocolError INVALID_MESSAGE_TYPE = 0x08;
    170: constexpr ProtocolError MESSAGE_TOO_SHORT = 0x09;
    171: constexpr ProtocolError DM_BEFORE_RM = 0x0A;
    172: constexpr ProtocolError RM_EXPECTED = 0x0B;
    173: constexpr ProtocolError RM_REPEATED = 0x0C;
    174: constexpr ProtocolError RM_FROM_CLIENT = 0x0D;
    175: constexpr ProtocolError DM_INVALID_TOKEN = 0x0E;
    197: constexpr BotEvent FIRST_BOT_BM_EVENT = 2;  // start of subclass events
* W053 Data could be const
    144:    DipHeader header;  // no parameters (length = 0)
    202:    byte_t first_payload_byte;  // for creating a pointer to the first byte
C:\Users\Greg\Documents\rsc\rsc\src\dip\DipTypes.h
* W020 Using statement in header
    26: using namespace NetworkBase;
    27: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.cpp
* W106 Function does not invoke Debug::ft
    282: bool MapAndUnits::can_move_to(const UnitOrder& unit, const Location& dest) const
    300: bool MapAndUnits::can_move_to_province
    562: TokenMessage MapAndUnits::encode_location(const Location& location) const
    839: TokenMessage MapAndUnits::encode_unit(const UnitOrder& unit) const
    1146: const LocationSet* MapAndUnits::get_neighbours(const Location& location) const
    1385: MapAndUnits* MapAndUnits::instance()
    2452: Token MapAndUnits::province_token(ProvinceId province) const
    2571: bool MapAndUnits::set_move_by_single_step_convoy_order
C:\Users\Greg\Documents\rsc\rsc\src\dip\MapAndUnits.h
* W020 Using statement in header
    35: using namespace NodeBase;
* W048 Data is write-only
    121:    bool game_started;                // set when the game has begun
    147:    word our_number_of_disbands;    // disbands required (negative for builds)
  W082 Adjacent arguments have the same type
    187:    bool set_support_to_move_order
    189:    bool set_convoy_order(ProvinceId unit, ProvinceId client, ProvinceId dest);
    190:    bool set_move_by_convoy_order(ProvinceId unit,
    192:    bool set_move_by_single_step_convoy_order
    271:    Location find_result_unit_initial_location(ProvinceId province,
    398:    bool has_route_to_province(const UnitOrder& unit, ProvinceId province,
* W092 Function could be free
    162:    static MapAndUnits* create_clone(); // MapAndUnits.cpp
    166:    static void delete_clone(MapAndUnits*& clone); // MapAndUnits.cpp
    259:    std::string display_retreat_result(const UnitOrder& unit) const; // BaseBot.cpp
C:\Users\Greg\Documents\rsc\rsc\src\dip\StartupParameters.h
* W020 Using statement in header
    21: using namespace NetworkBase;
C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.cpp
* W106 Function does not invoke Debug::ft
    32: Token::Token(const category_t cat, const subtoken_t sub)
    40: Token& Token::operator=(const Token& that)
    48: int Token::get_number() const
    57: bool Token::is_number() const
    64: bool Token::is_power() const
    71: bool Token::is_province() const
    118: Token::SeasonType Token::order_season() const
    129: PowerId Token::power_id() const
    137: ProvinceId Token::province_id() const
    260: Token power_token(PowerId power)
    273: Token province_token(ProvinceId province)
  W119 Argument passed by value is modified
    147/1: bool Token::set_number(int number)
C:\Users\Greg\Documents\rsc\rsc\src\dip\Token.h
* W020 Using statement in header
    27: using namespace NodeBase;
* W028 Unused data
    208: constexpr category_t CATEGORY_NUMBER_MIN = 0x00;
    209: constexpr category_t CATEGORY_NUMBER_MAX = 0x3F;
    210: constexpr category_t CATEGORY_BRACKET = 0x40;
    213: constexpr category_t CATEGORY_ORDER = 0x43;
    215: constexpr category_t CATEGORY_RESULT = 0x45;
    218: constexpr category_t CATEGORY_COMMAND = 0x48;
    219: constexpr category_t CATEGORY_PARAMETER = 0x49;
    220: constexpr category_t CATEGORY_PRESS = 0x4A;
* W042 Member could be private
    95:    bool is_number() const;
C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.cpp
* W106 Function does not invoke Debug::ft
    36: static void copy_tokens(Token* dest, const Token* source, int num)
    161: Token TokenMessage::at(size_t index) const
    168: void TokenMessage::clear()
    295: Token TokenMessage::front() const
    354: Token TokenMessage::operator[](size_t index) const
C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenMessage.h
* W032 Unused function
    48:    explicit TokenMessage(const Token* stream);
    141:    void set_as_ascii(const std::string& text);
* W042 Member could be private
    123:    size_t set_from(const Token* stream);
    128:    size_t set_from(const Token* stream, size_t length);
C:\Users\Greg\Documents\rsc\rsc\src\dip\TokenTextMap.cpp
* W106 Function does not invoke Debug::ft
    328: TokenTextMap* TokenTextMap::instance()
C:\Users\Greg\Documents\rsc\rsc\src\dip\WinterOrders.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    37: size_t WinterOrders::get_number_of_results() const
C:\Users\Greg\Documents\rsc\rsc\src\dip\WinterOrders.h
* W032 Unused function
    52:    size_t get_number_of_results() const;
C:\Users\Greg\Documents\rsc\rsc\src\launcher\RscLauncher.cpp
* W032 Unused function
    143: int main()
C:\Users\Greg\Documents\rsc\rsc\src\launcher\RscLauncher.win.cpp
  W056 Implicit constructor invoked: POD members not initialized
  i 38:    STARTUPINFOA si;
  i 39:    PROCESS_INFORMATION pi;
C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.cpp
  W006 reinterpret_cast
    58:    auto fake = reinterpret_cast< const Circuit* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\Circuit.h
* W020 Using statement in header
    32: using namespace NodeBase;
    33: using namespace SessionBase;
* W053 Data could be const
    93:    RegCell port_;
  W075 Virtual function is public
    72:    virtual std::string Name() const = 0;
    76:    virtual bool Supports(ProtocolId prid) const { return false; }
C:\Users\Greg\Documents\rsc\rsc\src\mb\MbModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\MbModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\mb\MbPools.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\MbPools.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaEndpt.h
* W020 Using statement in header
    34: using namespace NodeBase;
    35: using namespace SessionBase;
  W026 Unused argument
    109/1:    virtual void ProcessIcMsg(Message& msg);
* W032 Unused function
    58:    StateId GetState() const { return state_; }
    62:    virtual void SetState(StateId stid);
    72:    ProtocolSM* MgwPsm() const;
    78:    virtual void Deallocate();
    92:    explicit MediaEndpt(MediaPsm& psm);
* W042 Member could be private
    104:    virtual void EndOfTransaction();
  W075 Virtual function is public
    62:    virtual void SetState(StateId stid);
    78:    virtual void Deallocate();
* W077 Virtual function has no overrides
    62:    virtual void SetState(StateId stid);
    78:    virtual void Deallocate();
    104:    virtual void EndOfTransaction();
    109:    virtual void ProcessIcMsg(Message& msg);
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.cpp
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaFailureEvent.h
* W020 Using statement in header
    33: using namespace NodeBase;
    34: using namespace SessionBase;
  W027 Unused class
    42: class MediaFailureEvent : public Event
* W032 Unused function
    48:    MediaFailureEvent(ServiceSM& owner, MediaEndpt& mep);
    56:    MediaEndpt* Mep() const { return mep_; }
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.cpp
  W006 reinterpret_cast
    97:    reinterpret_cast< const MediaInfo* >(bytes)->Display(stream, prefix);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaParameter.h
* W020 Using statement in header
    31: using namespace NodeBase;
    32: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.cpp
  W006 reinterpret_cast
    529:       auto cxi = reinterpret_cast< MediaInfo* >(pptr->bytes);
  W007 Cast down the inheritance hierarchy
    228:    if(root->Sid() != TestServiceId) return static_cast< MediaSsm* >(root);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W106 Function does not invoke Debug::ft
    234: MediaPsm* MediaPsm::GetOgPsm() const
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaPsm.h
* W020 Using statement in header
    37: using namespace NodeBase;
    38: using namespace SessionBase;
* W032 Unused function
    120:    MediaEndpt* Mep() const { return mep_; }
* W042 Member could be private
    132:    Tone::Id GetOgTone() const { return ogTone_; }
    170:    void SetOgPort(Switch::PortId ogport);
    193:    void PrepareOgMsgq() override;
    197:    Event* ReceiveMsg(Message& msg) override;
  W075 Virtual function is public
    68:    virtual void SetOgPsm(MediaPsm* ogPsm);
    73:    virtual void SetOgTone(Tone::Id ogTone);
    78:    virtual void SetIcTone(Tone::Id icTone);
* W077 Virtual function has no overrides
    68:    virtual void SetOgPsm(MediaPsm* ogPsm);
    73:    virtual void SetOgTone(Tone::Id ogTone);
    78:    virtual void SetIcTone(Tone::Id icTone);
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.cpp
  W007 Cast down the inheritance hierarchy
    86:       auto mpsm = static_cast< MediaPsm* >(psm);
    108:       auto mpsm = static_cast< MediaPsm* >(psm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\MediaSsm.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
* W032 Unused function
    48:    virtual bool SetMgwPsm(ProtocolSM* psm);
  W075 Virtual function is public
    48:    virtual bool SetMgwPsm(ProtocolSM* psm);
* W077 Virtual function has no overrides
    48:    virtual bool SetMgwPsm(ProtocolSM* psm);
C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    85: Circuit* Switch::GetCircuit(PortId pid) const
C:\Users\Greg\Documents\rsc\rsc\src\mb\Switch.h
* W020 Using statement in header
    37: using namespace NodeBase;
* W042 Member could be private
    74:    static bool IsValidPort(PortId pid)
* W092 Function could be free
    74:    static bool IsValidPort(PortId pid) // Circuit.cpp
C:\Users\Greg\Documents\rsc\rsc\src\mb\ToneRegistry.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    77: Tone* ToneRegistry::GetTone(Tone::Id tid) const
C:\Users\Greg\Documents\rsc\rsc\src\mb\ToneRegistry.h
* W020 Using statement in header
    31: using namespace NodeBase;
* W092 Function could be free
    54:    static Switch::PortId ToneToPort(Tone::Id tid); // MediaPsm.cpp
C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.cpp
  W006 reinterpret_cast
    61:    auto fake = reinterpret_cast< const Tone* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\mb\Tones.h
  W005 Functional cast
    73:    Id Tid() const { return Id(tid_.GetId()); }
* W020 Using statement in header
    31: using namespace NodeBase;
* W032 Unused function
    73:    Id Tid() const { return Id(tid_.GetId()); }
  W037 Member hides inherited name
    77:    static ptrdiff_t CellDiff();
C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.cpp
  W006 reinterpret_cast
    118:    auto fake = reinterpret_cast< const Alarm* >(&local);
* W106 Function does not invoke Debug::ft
    203: AlarmStatus Alarm::Status() const
  W110 Override of Base.Display not found
    44: struct AlarmDynamic : public Permanent
C:\Users\Greg\Documents\rsc\rsc\src\nb\Alarm.h
* W053 Data could be const
    129:    RegCell aid_;
  W082 Adjacent arguments have the same type
    64:    Alarm(c_string name, c_string expl, uint32_t delay);
* W090 Function could be const
    113:    void SetStatus(AlarmStatus status);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.cpp
  W004 C-style cast
    43:    return (void*) ((const_ptr_t) ptr2 - diff);
    43:    return (void*) ((const_ptr_t) ptr2 - diff);
    50:    return (void*) ((const_ptr_t) ptr1 + diff);
    50:    return (void*) ((const_ptr_t) ptr1 + diff);
    108:    return ((const_ptr_t) ptr1 - (const_ptr_t) ptr2);
    108:    return ((const_ptr_t) ptr1 - (const_ptr_t) ptr2);
  W008 Cast removes const qualification
    43:    return (void*) ((const_ptr_t) ptr2 - diff);
    50:    return (void*) ((const_ptr_t) ptr1 + diff);
  W009 Pointer arithmetic
    43:    return (void*) ((const_ptr_t) ptr2 - diff);
    50:    return (void*) ((const_ptr_t) ptr1 + diff);
  W119 Argument passed by value is modified
    30/1: size_t find_first_one(uword n)
    55/1: size_t log2(size_t n, bool up)
    122/1: size_t round_to_2_exp_n(size_t n, size_t e, bool up)
C:\Users\Greg\Documents\rsc\rsc\src\nb\Algorithms.h
  W082 Adjacent arguments have the same type
    51:    uint64_t pack3(uint16_t a, uint16_t b, uint16_t c);
    55:    uint64_t pack4(uint16_t a, uint16_t b, uint16_t c, uint16_t d);
    63:    size_t round_to_2_exp_n(size_t n, size_t e, bool up);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Array.h
* W032 Unused function
    144:    const T& Back() const
    152:    T& Back()
    160:    const T& At(size_t index) const
    168:    T& At(size_t index)
    192:    const T* Data() const
* W099 Line contains adjacent spaces
    208:    inline static fn_name Array_ctor()    { return "Array.ctor"; }
    209:    inline static fn_name Array_dtor()    { return "Array.dtor"; }
    210:    inline static fn_name Array_Init()    { return "Array.Init"; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.cpp
  W006 reinterpret_cast
    95:    auto obj = reinterpret_cast< ObjectStruct* >(this);
    158:    auto obj = reinterpret_cast< const ObjectStruct* >(this);
  W008 Cast removes const qualification
    67:    objects.push_back(const_cast< Base* >(this));
* W106 Function does not invoke Debug::ft
    90: void Base::Nullify(size_t n)
    154: Base::vptr_t Base::Vptr() const
  W119 Argument passed by value is modified
    90/1: void Base::Nullify(size_t n)
C:\Users\Greg\Documents\rsc\rsc\src\nb\Base.h
* W043 Member could be protected
    75:    virtual void Display(std::ostream& stream,
    98:    void LogSubtended(std::ostream& stream,
  W075 Virtual function is public
    75:    virtual void Display(std::ostream& stream,
    93:    virtual void GetSubtended(std::vector< Base* >& objects) const;
    104:    virtual void ClaimBlocks();
    122:    virtual void Cleanup() { }
    129:    virtual void Startup(RestartLevel level) { }
    137:    virtual void Shutdown(RestartLevel level) { }
    141:    virtual MemoryType MemType() const { return MemPermanent; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\CallbackRequest.h
  W075 Virtual function is public
    44:    virtual void Callback() { }
* W090 Function could be const
    44:    virtual void Callback() { }
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.cpp
* W106 Function does not invoke Debug::ft
    88: void CfgBitParm::Explain(string& expl) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBitParm.h
* W042 Member could be private
    52:    virtual bool CurrValue() const = 0;
    56:    virtual bool NextValue() const = 0;
    70:    bool SetNext(c_string input) override;
  W082 Adjacent arguments have the same type
    48:    CfgBitParm(c_string key, c_string def, c_string expl);
  W141 Function could be moved to a subclass
    56:    virtual bool NextValue() const = 0; // CfgBoolParm
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgBoolParm.h
* W042 Member could be private
    68:    bool SetNextValue(bool value) override;
* W060 Base class constructor is public
    39:    CfgBoolParm(c_string key, c_string def, c_string expl);
  W075 Virtual function is public
    47:    bool CurrValue() const override { return curr_; }
  W082 Adjacent arguments have the same type
    39:    CfgBoolParm(c_string key, c_string def, c_string expl);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.cpp
* W106 Function does not invoke Debug::ft
    55: bool CfgFlagParm::CurrValue() const
    74: bool CfgFlagParm::NextValue() const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgFlagParm.h
* W042 Member could be private
    48:    bool CurrValue() const override;
    69:    bool SetNextValue(bool value) override;
  W075 Virtual function is public
    48:    bool CurrValue() const override;
  W082 Adjacent arguments have the same type
    39:    CfgFlagParm(c_string key, c_string def,
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.cpp
* W106 Function does not invoke Debug::ft
    68: void CfgIntParm::Explain(string& expl) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgIntParm.h
* W042 Member could be private
    62:    virtual bool SetNextValue(word value);
    84:    bool SetNext(c_string input) override;
* W053 Data could be const
    96:    word min_;
    100:    word max_;
* W060 Base class constructor is public
    39:    CfgIntParm(c_string key, c_string def, word min, word max, c_string expl);
* W077 Virtual function has no overrides
    62:    virtual bool SetNextValue(word value);
  W082 Adjacent arguments have the same type
    39:    CfgIntParm(c_string key, c_string def, word min, word max, c_string expl);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.cpp
  W006 reinterpret_cast
    135:    auto fake = reinterpret_cast< const CfgParm* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParm.h
* W042 Member could be private
    68:    c_string Key() const;
    100:    virtual std::string GetCurr() const = 0;
* W053 Data could be const
    158:    Q1Link link_;
  W075 Virtual function is public
    72:    virtual void Explain(std::string& expl) const { expl = expl_; }
* W077 Virtual function has no overrides
    114:    virtual std::string GetInput() const;
  W082 Adjacent arguments have the same type
    94:    CfgParm(c_string key, c_string def, c_string expl);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParmRegistry.cpp
* W106 Function does not invoke Debug::ft
    347: void CfgParmRegistry::ListParms(ostream& stream, const string& prefix) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgParmRegistry.h
* W042 Member could be private
    60:    CfgTuple* FindTuple(const std::string& key) const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgStrParm.cpp
* W106 Function does not invoke Debug::ft
    60: void CfgStrParm::Explain(string& expl) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgStrParm.h
* W032 Unused function
    61:    c_string NextValue() const { return next_.c_str(); }
* W060 Base class constructor is public
    40:    CfgStrParm(c_string key, c_string def, c_string expl);
  W082 Adjacent arguments have the same type
    40:    CfgStrParm(c_string key, c_string def, c_string expl);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.cpp
  W006 reinterpret_cast
    90:    auto fake = reinterpret_cast< const CfgTuple* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CfgTuple.h
* W053 Data could be const
    122:    Q1Link link_;
* W092 Function could be free
    92:    static const std::string& ValidValueChars(); // CfgParmRegistry.cpp
    97:    static const std::string& ValidBlankChars(); // CfgParmRegistry.cpp
* W127 Data could be free
    60:    static const char CommentChar; // CfgParmRegistry.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\CinThread.cpp
* W106 Function does not invoke Debug::ft
    65: void CinThread::ClearClient(const Thread* client)
  W107 Function does not invoke Debug::ft as first statement
    103:       Debug::ft(CinThread_Enter);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.cpp
  W004 C-style cast
    227:    return (Object*) addr;
  W006 reinterpret_cast
    93:    auto fake = reinterpret_cast< const Class* >(&local);
  W110 Override of Base.Display not found
    48: struct ClassDynamic : public Permanent
C:\Users\Greg\Documents\rsc\rsc\src\nb\Class.h
* W032 Unused function
    71:    virtual void Initialize();
    80:    virtual Object* Create();
    84:    virtual Object* GetQuasiSingleton();
    88:    virtual void FreeQuasiSingleton(Object* obj);
    143:    bool SetVptr(const Object& obj);
    150:    bool SetTemplate(Object& obj);
    158:    bool SetQuasiSingleton(Object& obj);
* W042 Member could be private
    75:    virtual MemoryType ObjType() const = 0;
    137:    virtual Object* New(size_t size);
  W075 Virtual function is public
    71:    virtual void Initialize();
    75:    virtual MemoryType ObjType() const = 0;
    80:    virtual Object* Create();
    84:    virtual Object* GetQuasiSingleton();
    88:    virtual void FreeQuasiSingleton(Object* obj);
* W077 Virtual function has no overrides
    71:    virtual void Initialize();
    75:    virtual MemoryType ObjType() const = 0;
    80:    virtual Object* Create();
    84:    virtual Object* GetQuasiSingleton();
    88:    virtual void FreeQuasiSingleton(Object* obj);
* W090 Function could be const
    71:    virtual void Initialize();
    88:    virtual void FreeQuasiSingleton(Object* obj);
    137:    virtual Object* New(size_t size);
    150:    bool SetTemplate(Object& obj);
    158:    bool SetQuasiSingleton(Object& obj);
C:\Users\Greg\Documents\rsc\rsc\src\nb\ClassRegistry.cpp
* W106 Function does not invoke Debug::ft
    89: Class* ClassRegistry::Lookup(ClassId cid) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliAppData.h
* W065 Base class virtual destructor is not public
    82:    virtual ~CliAppData();
  W075 Virtual function is public
    63:    virtual void EventOccurred(Event event);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliBuffer.cpp
* W053 Data could be const
    61:    istreamPtr file_;
* W106 Function does not invoke Debug::ft
    618: bool CliBuffer::ReadingFromFile() const
  W119 Argument passed by value is modified
    214/3:    (const CliThread& cli, const string& expl, std::streamsize p)
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliBuffer.h
* W042 Member could be private
    104:    bool ReadingFromFile() const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCharParm.h
* W060 Base class constructor is public
    40:    CliCharParm(c_string help, c_string chars,
  W082 Adjacent arguments have the same type
    40:    CliCharParm(c_string help, c_string chars,
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommand.h
* W042 Member could be private
    46:    static const char CommandSeparator;
* W043 Member could be protected
    51:    static fixed_string UnexpectedIndex;
  W075 Virtual function is public
    60:    virtual word ExplainCommand(std::ostream& stream, bool verbose) const;
    93:    Rc GetTextParmRc(id_t& i, std::string& s, CliThread& cli) const override;
  W082 Adjacent arguments have the same type
    103:    CliCommand(c_string comm, c_string help, uint32_t size = 32);
* W127 Data could be free
    46:    static const char CommandSeparator; // CliThread.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.cpp
  W006 reinterpret_cast
    73:    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
    173:    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
  W007 Cast down the inheritance hierarchy
    73:    auto& commands = reinterpret_cast< Registry< CliCommand >& >(Parms());
    173:    auto& commands = reinterpret_cast< const Registry< CliCommand >& >(Parms());
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCommandSet.h
* W043 Member could be protected
    44:    bool BindCommand(CliCommand& comm);
  W082 Adjacent arguments have the same type
    59:    CliCommandSet(c_string comm, c_string help, uint32_t size = 32);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliCookie.cpp
* W106 Function does not invoke Debug::ft
    118: uint32_t CliCookie::Index(uint32_t depth) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.cpp
  W006 reinterpret_cast
    102:    auto fake = reinterpret_cast< const CliIncrement* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIncrement.h
* W053 Data could be const
    110:    RegCell iid_;
  W075 Virtual function is public
    75:    virtual void Enter();
    80:    virtual void Exit();
* W077 Virtual function has no overrides
    80:    virtual void Exit();
  W082 Adjacent arguments have the same type
    102:    CliIncrement(c_string name, c_string help, uint32_t size = 32);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliIntParm.h
* W053 Data could be const
    71:    word min_;
    75:    word max_;
    79:    bool hex_;
* W060 Base class constructor is public
    45:    CliIntParm(c_string help, word min, word max,
  W082 Adjacent arguments have the same type
    45:    CliIntParm(c_string help, word min, word max,
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.cpp
  W006 reinterpret_cast
    113:    auto fake = reinterpret_cast< const CliParm* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliParm.h
* W043 Member could be protected
    131:    static fixed_string AnyStringParm;
    166:    bool GetBoolParm(bool& b, CliThread& cli) const;
    176:    bool GetCharParm(char& c, CliThread& cli) const;
    186:    bool GetPtrParm(void*& p, CliThread& cli) const;
    212:    bool GetTextParm(id_t& i, std::string& s, CliThread& cli) const;
    234:    bool GetFileName(std::string& s, CliThread& cli) const;
    246:    bool GetIdentifier(std::string& s, CliThread& cli,
    261:    bool IsOptional() const { return opt_; }
  W075 Virtual function is public
    143:    virtual CliParm* AccessParm(CliCookie& cookie, uint32_t depth) const;
    151:    virtual void Explain(std::ostream& stream, col_t indent) const;
    161:    virtual Rc GetIntParmRc(word& n, CliThread& cli) const;
    171:    virtual Rc GetBoolParmRc(bool& b, CliThread& cli) const;
    181:    virtual Rc GetCharParmRc(char& c, CliThread& cli) const;
    191:    virtual Rc GetPtrParmRc(void*& p, CliThread& cli) const;
    219:    virtual Rc GetTextParmRc(id_t& i, std::string& s, CliThread& cli) const;
    229:    virtual Rc GetStringRc(std::string& s, CliThread& cli) const;
    239:    virtual Rc GetFileNameRc(std::string& s, CliThread& cli) const;
    252:    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
  W082 Adjacent arguments have the same type
    246:    bool GetIdentifier(std::string& s, CliThread& cli,
    252:    virtual Rc GetIdentifierRc(std::string& s, CliThread& cli,
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliPtrParm.cpp
  W004 C-style cast
    91:          p = (void*) n;
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliStack.h
* W042 Member could be private
    68:    const CliCommand* FindCommand
* W117 Line can merge with the next line and be under the length limit
    68:    const CliCommand* FindCommand
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.cpp
  W119 Argument passed by value is modified
    39/2: CliText::CliText(c_string help, c_string text, bool opt, uint32_t size) :
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliText.h
* W042 Member could be private
    61:    c_string HelpText() const;
* W043 Member could be protected
    65:    const Registry< CliParm >& Parms() const { return parms_; }
* W060 Base class constructor is public
    49:    CliText(c_string help, c_string text, bool opt = false, uint32_t size = 32);
  W075 Virtual function is public
    69:    virtual bool BindParm(CliParm& parm);
  W082 Adjacent arguments have the same type
    49:    CliText(c_string help, c_string text, bool opt = false, uint32_t size = 32);
  W120 Function returns non-const reference or pointer to member data
    82:    Registry< CliParm >& Parms() { return parms_; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliTextParm.cpp
  W119 Argument passed by value is modified
    142/2: void CliTextParm::Explain(ostream& stream, col_t indent) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliTextParm.h
* W060 Base class constructor is public
    49:    explicit CliTextParm(c_string help, bool opt = false,
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.cpp
  W119 Argument passed by value is modified
    757/2:    (const string& expl, size_t begin, size_t end, col_t indent) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\CliThread.h
* W032 Unused function
    142:    word Result() const { return result_; }
  W050 Data is not private
    211:    std::unique_ptr< CliBuffer > ibuf;
    215:    ostringstreamPtr obuf;
  W082 Adjacent arguments have the same type
    99:    char CharPrompt(const std::string& prompt,
    106:    word IntPrompt(const std::string& prompt, word min, word max);
    251:    void Report1
  W120 Function returns non-const reference or pointer to member data
    190:    CliCookie& Cookie() { return cookie_; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\CoutThread.cpp
  W007 Cast down the inheritance hierarchy
    87:       auto req = static_cast< StreamRequest* >(msg);
C:\Users\Greg\Documents\rsc\rsc\src\nb\CoutThread.h
* W092 Function could be free
    48:    static void Spool(c_string s, bool eol = false); // CoutThread.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Daemon.cpp
  W006 reinterpret_cast
    75:    auto fake = reinterpret_cast< const Daemon* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Daemon.h
* W043 Member could be protected
    96:    id_t Did() const { return did_.GetId(); }
* W077 Virtual function has no overrides
    148:    virtual void Recover() { }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.cpp
* W106 Function does not invoke Debug::ft
    57: void Debug::Assert(bool condition, debug64_t errval)
    73: void Debug::ft(fn_name_arg func) NO_FT
    81: void Debug::ftnt(fn_name_arg func) NO_FT
* W130 Redundant scope
    91:    Debug::ft("Debug.GetSwFlags");
    101:    Debug::ft("Debug.noop");
    108:    Debug::ft("Debug.Progress");
    118:    Debug::ft("Debug.ResetSwFlags");
    127:    Debug::ftnt("Debug.SetSwFlag");
    146:    Debug::ftnt("Debug.SwFlagOn");
    163:    Debug::ftnt(Debug_SwLog);
    167:    Debug::ftnt(Debug_SwLog);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Debug.h
  W026 Unused argument
    117/1:    static void noop(debug64_t info = 0);
* W092 Function could be free
    105:    static void SetSwFlag(FlagId fid, bool value); // NtIncrement.cpp
    109:    static void ResetSwFlags(); // NtIncrement.cpp
    113:    static Flags GetSwFlags(); // NtIncrement.cpp
    117:    static void noop(debug64_t info = 0); // CxxExecute.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.cpp
  W006 reinterpret_cast
    99:    auto fake = reinterpret_cast<const Deferred*>(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Deferred.h
  W026 Unused argument
    89/1:    virtual void EventHasOccurred(Event event) = 0;
* W032 Unused function
    63:    void SendToThread(Thread* thread);
    67:    void Restart(uint32_t secs);
    93:    Base* Owner() const { return owner_; }
  W037 Member hides inherited name
    97:    static ptrdiff_t LinkDiff();
* W053 Data could be const
    105:    Q2Link link_;
* W090 Function could be const
    89:    virtual void EventHasOccurred(Event event) = 0;
C:\Users\Greg\Documents\rsc\rsc\src\nb\DeferredRegistry.h
* W032 Unused function
    52:    void EraseAll(const Base* owner);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Duration.h
* W028 Unused data
    59: constexpr uint32_t NS_TO_SECS = std::nano::den;
* W032 Unused function
    45: std::string to_string(const usecs_t& usecs);
    46: std::string to_string(const nsecs_t& nsecs);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Element.cpp
* W106 Function does not invoke Debug::ft
    199: bool Element::RunningInLab()
C:\Users\Greg\Documents\rsc\rsc\src\nb\Element.h
* W092 Function could be free
    50:    static bool IsUnnamed(); // ModuleRegistry.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\ElementException.h
* W032 Unused function
    53:    RestartReason Reason() const { return reason_; }
    57:    debug64_t Errval() const { return errval_; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Exception.cpp
  W107 Function does not invoke Debug::ft as first statement
    42:    Debug::ft("Exception.ctor");  //@
C:\Users\Greg\Documents\rsc\rsc\src\nb\Exception.h
* W065 Base class virtual destructor is not public
    69:    virtual ~Exception();
  W075 Virtual function is public
    51:    virtual void Display(std::ostream& stream, const std::string& prefix) const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.cpp
  W007 Cast down the inheritance hierarchy
    212:       auto req = static_cast< FileRequest* >(msg);
C:\Users\Greg\Documents\rsc\rsc\src\nb\FileThread.h
  W082 Adjacent arguments have the same type
    63:    static void Spool(const std::string& name,
* W092 Function could be free
    45:    static ostringstreamPtr CreateStream(); // CliThread.cpp
    58:    static void Spool(const std::string& name, ostringstreamPtr& stream, // FileThread.cpp
    63:    static void Spool(const std::string& name, // FileThread.cpp
    72:    static void Truncate(const std::string& name); // NbIncrement.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.cpp
  W004 C-style cast
    161:       auto base = (const Base*) obj;
  W119 Argument passed by value is modified
    75/4:    const string& prefix, const byte_t* bytes, size_t count)
    311/2: size_t strSkipSpaces(const std::string& str, size_t index)
C:\Users\Greg\Documents\rsc\rsc\src\nb\Formatters.h
* W032 Unused function
    53:    bool strToSize(const std::string& str, size_t& size);
  W082 Adjacent arguments have the same type
    99:    int strCompare
    111:    std::string strCenter(const std::string& s, size_t breadth, size_t blanks);
C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.cpp
  W007 Cast down the inheritance hierarchy
    569:       auto curr = static_cast< FunctionTrace* >(rec);
    583:       auto curr = static_cast< FunctionTrace* >(rec);
    602:       auto curr = static_cast< FunctionTrace* >(rec);
    630:       auto curr = static_cast< FunctionTrace* >(rec);
    677:       auto curr = static_cast< FunctionTrace* >(rec);
    796:       auto curr = static_cast< FunctionTrace* >(rec);
    818:       auto curr = static_cast< FunctionTrace* >(rec);
    836:       auto curr = static_cast< FunctionTrace* >(rec);
    909:       auto curr = static_cast< FunctionTrace* >(rec);
* W032 Unused function
    169:    PerThreadInfo()
* W106 Function does not invoke Debug::ft
    191: CtorChain::CtorChain(FunctionTrace* inner) :
    208: bool CtorChain::AddToPreviousChain(FunctionTrace* ctor)
    261: CtorChain::Action CtorChain::CalcAction
    329: TraceRecord* CtorChain::CheckForEndOfChains(const FunctionTrace* curr)
    348: bool CtorChain::CheckForInitializer(const FunctionTrace* curr)
    391: bool CtorChain::FunctionEndsChain(const FunctionTrace* curr) const
    409: TraceRecord* CtorChain::HandleCtor(FunctionTrace* ctor)
    458: void CtorChain::HandleFunction(FunctionTrace* func)
    485: void CtorChain::MoveOuterAboveInit()
    499: void CtorChain::MoveOuterAboveInner() const
    512: void CtorChain::SetOuter(FunctionTrace* outer)
C:\Users\Greg\Documents\rsc\rsc\src\nb\FunctionTrace.h
* W043 Member could be protected
    44:    FunctionTrace();
* W060 Base class constructor is public
    44:    FunctionTrace();
C:\Users\Greg\Documents\rsc\rsc\src\nb\Gate.cpp
* W047 Data is init-only
    50:    std::unique_lock< std::mutex > lock(mutex_);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.cpp
* W106 Function does not invoke Debug::ft
    157: void Heap::Freeing(void* addr, size_t size)
    173: bool Heap::IsFixedSize() const
    229: void Heap::Requested(size_t size, void* addr)
C:\Users\Greg\Documents\rsc\rsc\src\nb\Heap.h
* W042 Member could be private
    56:    virtual void* Addr() const = 0;
    103:    virtual size_t Overhead() const = 0;
    117:    size_t MaxInUse() const { return maxInUse_; }
    142:    bool IsFixedSize() const;
  W075 Virtual function is public
    56:    virtual void* Addr() const = 0;
    60:    virtual size_t Size() const = 0;
    64:    virtual MemoryType Type() const = 0;
    68:    virtual void* Alloc(size_t size) = 0;
    72:    virtual void Free(void* addr) = 0;
    77:    virtual size_t BlockToSize(const void* addr) const = 0;
    82:    virtual bool Validate(const void* addr) const = 0;
    86:    virtual bool CanBeProtected() const { return true; }
    93:    virtual int SetPermissions(MemoryProtection attrs);
    99:    virtual size_t CurrAvail() const = 0;
    103:    virtual size_t Overhead() const = 0;
C:\Users\Greg\Documents\rsc\rsc\src\nb\HeapCfg.h
* W032 Unused function
    55:    size_t GetMinSize(MemoryType type) const { return minSize_[type]; }
  W110 Override of Base.Display not found
    41: class HeapCfg : public Immutable
C:\Users\Greg\Documents\rsc\rsc\src\nb\InitFlags.cpp
* W106 Function does not invoke Debug::ft
    28: bool InitFlags::AllowBreak()
    39: bool InitFlags::CauseTimeout()
    48: bool InitFlags::SuspendRoot()
    55: bool InitFlags::TraceInit()
C:\Users\Greg\Documents\rsc\rsc\src\nb\InitThread.h
* W127 Data could be free
    75:    static const Flags RecreateMask; // Daemon.cpp
    76:    static const Flags ScheduleMask; // Thread.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.cpp
  W006 reinterpret_cast
    136:    auto fake = reinterpret_cast< const Log* >(&local);
* W106 Function does not invoke Debug::ft
    142: size_t Log::Count()
  W110 Override of Base.Display not found
    56: struct LogDynamic : public Permanent
C:\Users\Greg\Documents\rsc\rsc\src\nb\Log.h
* W042 Member could be private
    119:    static Log* Find(c_string groupName, LogId id, LogGroup*& group);
* W053 Data could be const
    185:    RegCell lid_;
* W090 Function could be const
    114:    void SetInterval(uint8_t interval);
* W092 Function could be free
    124:    static Log* Find(c_string log); // Log.cpp
    132:    static size_t Count(); // NbIncrement.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogBuffer.cpp
  W004 C-style cast
    314:    auto after = (ptr_t) next_ + size;
    327:       if(wrap && (after > (const_ptr_t) first)) return nullptr;
    334:       if(wrap || (after > (const_ptr_t) first)) return nullptr;
    508:       used = (const_ptr_t) next_ - (const_ptr_t) first;
    508:       used = (const_ptr_t) next_ - (const_ptr_t) first;
    510:       used = size_ - ((const_ptr_t) first - (const_ptr_t) next_);
    510:       used = size_ - ((const_ptr_t) first - (const_ptr_t) next_);
  W006 reinterpret_cast
    124:    SetNext(reinterpret_cast< Entry* >(buff_));
    341:       where = reinterpret_cast< Entry* >(buff_);
    349:    SetNext(reinterpret_cast< Entry* >(after));
    386:          SetNext(reinterpret_cast< Entry* >(buff_));
  W009 Pointer arithmetic
    314:    auto after = (ptr_t) next_ + size;
    315:    auto wrap = after >= (buff_ + size_);
    342:       after = buff_ + size;
* W106 Function does not invoke Debug::ft
    501: void LogBuffer::UpdateMax()
* W117 Line can merge with the next line and be under the length limit
    191:       stream << fileName_ << SPACE
  W119 Argument passed by value is modified
    99/1: LogBuffer::LogBuffer(size_t size) :
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.cpp
  W006 reinterpret_cast
    123:    auto fake = reinterpret_cast< const LogGroup* >(&local);
* W106 Function does not invoke Debug::ft
    182: void LogGroup::SetSuppressed(bool suppressed)
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroup.h
* W042 Member could be private
    76:    id_t Gid() const { return gid_.GetId(); }
    80:    bool Suppressed() const { return suppressed_; }
* W053 Data could be const
    137:    RegCell gid_;
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroupRegistry.cpp
* W106 Function does not invoke Debug::ft
    190: LogGroup* LogGroupRegistry::Group(id_t gid) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogGroupRegistry.h
* W032 Unused function
    62:    Log* FindLog(const std::string& name, LogId id) const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogThread.cpp
  W007 Cast down the inheritance hierarchy
    86:       (static_cast< CfgIntParm* >(reg->FindParm("NoSpoolingMessageCount")));
C:\Users\Greg\Documents\rsc\rsc\src\nb\LogThread.h
* W092 Function could be free
    67:    static void Spool(const std::string& str, const Log* log); // Log.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\MainArgs.cpp
* W106 Function does not invoke Debug::ft
    142: size_t MainArgs::Size()
C:\Users\Greg\Documents\rsc\rsc\src\nb\MainArgs.h
* W032 Unused function
    66:    static std::string Find(c_string tag);
* W092 Function could be free
    61:    static void PushBack(const std::string& arg); // main.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.cpp
  W005 Functional cast
    312:       heaps.push_back(AccessHeap(MemoryType(m)));
* W047 Data is init-only
    308:    std::ostringstream expl;
* W106 Function does not invoke Debug::ft
    172: static Heap* EnsureHeap(MemoryType type)
    189: Heap* Memory::AccessHeap(MemoryType type)
    208: size_t Memory::Align(size_t size, size_t log2align)
    387: bool Memory::Protect(MemoryType type)
    468: bool Memory::Unprotect(MemoryType type)
    499: size_t Memory::Words(size_t size)
C:\Users\Greg\Documents\rsc\rsc\src\nb\Memory.h
* W032 Unused function
    50:    size_t Words(size_t size);
    58:    void Set(void* dest, byte_t value, size_t size);
    78:    void* Realloc(void* addr, size_t size, MemoryType type);
C:\Users\Greg\Documents\rsc\rsc\src\nb\MemoryTrace.cpp
  W007 Cast down the inheritance hierarchy
    88:       auto curr = static_cast< MemoryTrace* >(rec);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Module.cpp
  W006 reinterpret_cast
    65:    auto fake = reinterpret_cast< const Module* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Module.h
* W032 Unused function
    96:    ModuleId Mid() const { return mid_.GetId(); }
* W053 Data could be const
    134:    RegCell mid_;
C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.cpp
* W106 Function does not invoke Debug::ft
    64: static const FactionFlags& AllFactions()
    106: static const FactionFlags& ShutdownFactions()
    197: RestartLevel ModuleRegistry::GetLevel()
    204: Module* ModuleRegistry::GetModule(ModuleId mid) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\ModuleRegistry.h
* W092 Function could be free
    91:    void SetLevel(RestartLevel level); // InitThread.cpp
    95:    static RestartLevel GetLevel(); // RootThread.cpp
    99:    static RestartLevel NextLevel(); // ModuleRegistry.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\MsgBuffer.cpp
* W106 Function does not invoke Debug::ft
    63: TraceStatus MsgBuffer::GetStatus() const
C:\Users\Greg\Documents\rsc\rsc\src\nb\MsgBuffer.h
* W043 Member could be protected
    47:    MsgBuffer(const MsgBuffer& that);
  W075 Virtual function is public
    60:    virtual TraceStatus GetStatus() const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\MutexGuard.cpp
  W107 Function does not invoke Debug::ft as first statement
    35:    Debug::ft("MutexGuard.ctor");
    55:       Debug::ftnt("MutexGuard.Release");
C:\Users\Greg\Documents\rsc\rsc\src\nb\MutexRegistry.h
* W042 Member could be private
    56:    SysMutex* Find(const std::string& name) const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbAppIds.h
* W028 Unused data
    72: constexpr FlagId FirstAppDebugFlag = 10;
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbCliParms.cpp
* W106 Function does not invoke Debug::ft
    123: word ExplainTraceRc(const CliThread& cli, TraceRc rc)
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbCliParms.h
  W082 Adjacent arguments have the same type
    123: CliParm::Rc GetCBV(const CliCommand& comm, CliThread& cli, bool& c, bool& v);
    129: bool ValidateOptions
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.cpp
  W004 C-style cast
    332:       auto child = (HeapBlock*) (uintptr_t(block) + LevelToSize(level + 1));
    377:    auto block = (const HeapBlock*) addr;
    485:    heap_ = (HeapPriv*) SysMemory::Alloc(nullptr, size_);
    525:    heap_->state = (uint8_t*) (heapAddr + infoSize);
    557:          ReleaseBlock((HeapBlock*) addr, level);
    568:       ReserveBlock((HeapBlock*) addr);
    677:                   if(block < (HeapBlock*) heap_)
    679:                   else if(block < (HeapBlock*) heap_->minAddr)
    748:    FreeBlock((HeapBlock*) addr, level);
    796:    return (HeapBlock*) (heap_->leftAddr + (offset << Log2Size(level)));
    883:       auto size = BlockToSize((const HeapBlock*) addr);
    886:       auto index = BlockToIndex((const HeapBlock*) addr, level);
    938:       if((HeapBlock*) block->link.prev->next != block)
    940:       if((HeapBlock*) block->link.next->prev != block)
  W005 Functional cast
    783:    return BlockState(state);
  W026 Unused argument
    77/3:       const std::string& prefix, const Flags& options) const;
* W053 Data could be const
    56:    Q2Link link;
* W099 Line contains adjacent spaces
    669:                case Split:     c = 'S'; break;
    670:                case Merged:    c = 'm'; break;
* W106 Function does not invoke Debug::ft
    128: static NbHeap::index_t IndexToChild(NbHeap::index_t index)
    137: static NbHeap::index_t IndexToParent(NbHeap::index_t index)
    146: static NbHeap::index_t IndexToSibling(NbHeap::index_t index)
    157: static size_t Log2Size(NbHeap::level_t level)
    166: static size_t LevelToSize(NbHeap::level_t level)
    175: static NbHeap::level_t SizeToLevel(size_t size)
    272: bool NbHeap::AddrIsValid(const void* addr, bool header) const
    314: HeapBlock* NbHeap::AllocBlock(level_t level, size_t size)
    346: NbHeap::index_t NbHeap::BlockToIndex
    413: NbHeap::BlockState NbHeap::Corrupt(int reason, bool restart) const
    595: HeapBlock* NbHeap::Dequeue(level_t level)
    701: void NbHeap::EnqBlock(HeapBlock* block, index_t index, level_t level)
    710: HeapBlock* NbHeap::Enqueue(HeapBlock* block, level_t level)
    753: void NbHeap::FreeBlock(HeapBlock* block, level_t level)
    772: NbHeap::BlockState NbHeap::GetState(index_t index) const
    788: HeapBlock* NbHeap::IndexToBlock(index_t index, level_t level) const
    801: size_t NbHeap::Overhead() const
    815: void NbHeap::ReleaseBlock(HeapBlock* block, level_t level)
    831: void NbHeap::ReserveBlock(const HeapBlock* block)
    844: void NbHeap::SetState(index_t index, BlockState state)
    860: void NbHeap::SplitAncestors(index_t block)
    908: NbHeap::BlockState NbHeap::ValidateBlock
  W119 Argument passed by value is modified
    294/1: void* NbHeap::Alloc(size_t size)
    446/1: bool NbHeap::Create(size_t size)
    753/1: void NbHeap::FreeBlock(HeapBlock* block, level_t level)
    860/1: void NbHeap::SplitAncestors(index_t block)
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbHeap.h
* W090 Function could be const
    171:    void SetState(index_t index, BlockState state);
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.cpp
  W005 Functional cast
    594:       rc = nbt->SelectFaction(Faction(id), TraceDefault);
    975:       rc = nbt->SelectFaction(Faction(id), TraceExcluded);
    1162:          auto type = MemoryType(memtype);
    1193:          auto type = MemoryType(m);
    1204:          *cli.obuf << setw(13) << MemoryType(m) << ": " << status << CRLF;
    1214:          auto type = MemoryType(memtype);
    1227:          auto type = MemoryType(memtype);
    1593:       rc = nbt->SelectFaction(Faction(id), TraceIncluded);
    3200:       auto heap = Memory::AccessHeap(MemoryType(m));
  W102 Line length exceeds the standard maximum
    3177: "Alloc  Min kB     kB       Bytes                            Memory        Prot\n"
    3178: "Fails   Avail  Avail      In Use     Allocs      Frees        Type  RWX  Chngs";
* W117 Line can merge with the next line and be under the length limit
    1090:    BindText(*new CliText
    1116:    BindText(*new CliText
    2603:    BindText(*new CliText
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbIncrement.h
* W028 Unused data
    195:    static const id_t LastNbIndex = 3;
* W060 Base class constructor is public
    41:    StatusCommand();
    56:    LogsAction();
    76:    explicit LogsCommand(bool bind = true);
    93:    SetWhatParm();
    107:    explicit SetCommand(bool bind = true);
    124:    IncludeWhatParm();
    138:    explicit IncludeCommand(bool bind = true);
    155:    ExcludeWhatParm();
    168:    explicit ExcludeCommand(bool bind = true);
    199:    explicit QueryCommand(bool bind = true);
    216:    SaveWhatParm();
    228:    explicit SaveCommand(bool bind = true);
    245:    ClearWhatParm();
    263:    explicit ClearCommand(bool bind = true);
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTracer.cpp
  W005 Functional cast
    228:             stream << Faction(f) << CRLF;
* W106 Function does not invoke Debug::ft
    188: TraceStatus NbTracer::FactionStatus(Faction faction) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTracer.h
  W110 Override of Base.Display not found
    63: class NbTracer : public Permanent
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.cpp
* W106 Function does not invoke Debug::ft
    75: char BlockingReasonChar(BlockingReason reason)
    98: char FactionChar(Faction faction)
C:\Users\Greg\Documents\rsc\rsc\src\nb\NbTypes.h
* W030 Unused enumerator
    44:    DispOption_N  // number of reasons; can be used to extend this enum
    74:    IdleFaction,         // idle thread (not used)
* W033 Unused typedef
    226: using PersistentStr =
C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.cpp
  W006 reinterpret_cast
    114:    auto obj = reinterpret_cast< ObjectStruct* >(this);
* W106 Function does not invoke Debug::ft
    59: Object::ClassId Object::GetClassId() const
    70: bool Object::GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid)
    95: Object::ObjectId Object::GetObjectId() const
C:\Users\Greg\Documents\rsc\rsc\src\nb\Object.h
* W032 Unused function
    92:    ClassId GetClassId() const;
    104:    ObjectId GetObjectId() const;
    110:    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid);
    131:    void MorphTo(const Class& target);
* W042 Member could be private
    98:    virtual InstanceId GetInstanceId() const;
* W043 Member could be protected
    59:    virtual void Patch(sel_t selector, void* arguments) { }
* W053 Data could be const
    136:    uintptr_t patchArea_;
  W075 Virtual function is public
    59:    virtual void Patch(sel_t selector, void* arguments) { }
    79:    virtual Class* GetClass() const;
    87:    virtual void PostInitialize() { }
    98:    virtual InstanceId GetInstanceId() const;
* W077 Virtual function has no overrides
    79:    virtual Class* GetClass() const;
    87:    virtual void PostInitialize() { }
    98:    virtual InstanceId GetInstanceId() const;
* W088 Argument could be const
    59/2:    virtual void Patch(sel_t selector, void* arguments) { }
* W090 Function could be const
    59:    virtual void Patch(sel_t selector, void* arguments) { }
* W092 Function could be free
    110:    static bool GetClassInstanceId(ObjectId oid, Class*& cls, InstanceId& iid); // Object.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.cpp
  W004 C-style cast
    87:    return (ObjectBlock*) getptr1(obj, BlockHeaderSize);
    311:       blocks_[currSegments_] = (uword*) Memory::Alloc(size, mem_, std::nothrow);
    335:          auto b = (ObjectBlock*) &seg[j];
    385:             auto b = (ObjectBlock*) &seg[j];
    421:             auto curr = (Pooled*) getptr1(item, diff);
    857:       return (ObjectBlock*) &blocks_[0][0];
    925:       return (ObjectBlock*) &blocks_[i][j];
    950:             auto b = (ObjectBlock*) &seg[j];
    981:    auto block = (const_ptr_t) ObjToBlock(obj);
    982:    auto maxdiff = (ptrdiff_t) (blockSize_ * (ObjectsPerSegment - 1));
    986:       auto b0 = (const_ptr_t) &blocks_[i][0];
    1049:          auto b = (ObjectBlock*) &seg[j];
  W006 reinterpret_cast
    557:    auto fake = reinterpret_cast< const ObjectPool* >(&local);
* W099 Line contains adjacent spaces
    169:    CounterPtr      allocCount_;
    170:    CounterPtr      freeCount_;
    171:    CounterPtr      failCount_;
    172:    CounterPtr      auditCount_;
    173:    CounterPtr      expansions_;
* W106 Function does not invoke Debug::ft
    84: static ObjectBlock* ObjToBlock(const Pooled* obj)
    351: size_t ObjectPool::AllocCount() const
    518: size_t ObjectPool::AvailCount() const
    525: bool ObjectPool::BidToIndices(PooledObjectId bid, size_t& i, size_t& j) const
    741: void ObjectPool::EnqBlock(Pooled* obj, bool deleted)
    836: size_t ObjectPool::Expansions() const
    843: size_t ObjectPool::FailCount() const
    884: size_t ObjectPool::FreeCount() const
    891: bool ObjectPool::IndicesToBid(size_t i, size_t j, PooledObjectId& bid) const
    903: size_t ObjectPool::InUseCount() const
    910: size_t ObjectPool::LowAvailCount() const
    917: ObjectBlock* ObjectPool::Next(PooledObjectId& bid) const
    936: Pooled* ObjectPool::NextUsed(PooledObjectId& bid) const
    1008: ObjectPoolId ObjectPool::ObjPid(const Pooled* obj)
    1017: PooledObjectSeqNo ObjectPool::ObjSeq(const Pooled* obj)
  W110 Override of Base.Display not found
    96: class ObjectPoolSizeCfg : public CfgIntParm
    162: class ObjectPoolStats : public Dynamic
    204: struct ObjectPoolDynamic : public Persistent
  W119 Argument passed by value is modified
    525/1: bool ObjectPool::BidToIndices(PooledObjectId bid, size_t& i, size_t& j) const
    539/1: Pooled* ObjectPool::BidToObj(PooledObjectId bid) const
    563/1: bool ObjectPool::Corrupt(size_t n)
C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPool.h
  W005 Functional cast
    97:    ObjectPoolId Pid() const { return ObjectPoolId(pid_.GetId()); }
  W075 Virtual function is public
    102:    virtual Pooled* DeqBlock(size_t size);
    107:    virtual void EnqBlock(Pooled* obj, bool deleted);
    179:    virtual void DisplayStats(std::ostream& stream, const Flags& options) const;
* W077 Virtual function has no overrides
    102:    virtual Pooled* DeqBlock(size_t size);
    107:    virtual void EnqBlock(Pooled* obj, bool deleted);
  W082 Adjacent arguments have the same type
    242:    bool BidToIndices(PooledObjectId bid, size_t& i, size_t& j) const;
    247:    bool IndicesToBid(size_t i, size_t j, PooledObjectId& bid) const;
* W090 Function could be const
    189:    bool Corrupt(size_t n);
    255:    void UpdateAlarm();
C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPoolRegistry.cpp
* W106 Function does not invoke Debug::ft
    280: ObjectPool* ObjectPoolRegistry::Pool(ObjectPoolId pid) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\ObjectPoolRegistry.h
* W042 Member could be private
    65:    bool NullifyObjectData() const { return nullifyObjectDataCfg_->CurrValue(); }
C:\Users\Greg\Documents\rsc\rsc\src\nb\PermanentHeap.cpp
* W106 Function does not invoke Debug::ft
    43: PermanentHeap* PermanentHeap::Instance()
C:\Users\Greg\Documents\rsc\rsc\src\nb\PermanentHeap.h
* W092 Function could be free
    41:    static PermanentHeap* Instance(); // Memory.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Pooled.cpp
  W004 C-style cast
    136:    auto obj = (Pooled*) addr;
  W006 reinterpret_cast
    114:    auto fake = reinterpret_cast< const Pooled* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\PooledClass.h
  W027 Unused class
    39: class PooledClass : public Class
* W032 Unused function
    53:    PooledClass(ClassId cid, size_t size);
    69:    bool SetPool(ObjectPool& pool);
C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.cpp
  W006 reinterpret_cast
    71:    auto fake = reinterpret_cast< const PosixSignal* >(&local);
* W106 Function does not invoke Debug::ft
    124: Flags PS_Break()
    129: Flags PS_Delayed()
    134: Flags PS_Final()
    139: Flags PS_Interrupt()
    144: Flags PS_Native()
    149: Flags PS_NoError()
    154: Flags PS_NoLog()
C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignal.h
* W032 Unused function
    148: Flags PS_Delayed();
* W053 Data could be const
    135:    RegCell sid_;
  W082 Adjacent arguments have the same type
    105:    PosixSignal(signal_t value, c_string name,
* W127 Data could be free
    51:    static const signal_t MaxId; // PosixSignalRegistry.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\PosixSignalRegistry.cpp
* W106 Function does not invoke Debug::ft
    58: Flags PosixSignalRegistry::Attrs(signal_t value) const
    89: PosixSignal* PosixSignalRegistry::Find(signal_t value) const
    101: PosixSignal* PosixSignalRegistry::Find(const string& name) const
    153: signal_t PosixSignalRegistry::Value(const string& name) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Link.cpp
  W107 Function does not invoke Debug::ft as first statement
    49:    Debug::ftnt(Q1Link_dtor);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Link.h
* W032 Unused function
    65:    bool IsQueued() const { return next != nullptr; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Q1Way.h
  W004 C-style cast
    143:       auto ante = (Q1Link*)
    166:       return (T*) getptr1(item, diff_);  // location of item's vptr
    212:       return (T*) getptr1(item, diff_);     // location of item's vptr
    233:          item = (Q1Link*)
    247:       elem = (T*) getptr1(item, diff_);     // location of item's vptr
    260:       return (T*) getptr1(item, diff_);       // location of next item's vptr
    332:          tail_.next = (Q1Link*) BAD_POINTER;  // corrupt queue header
    340:       auto item = (Q1Link*)                   // start at the current item
    342:       item->next = (Q1Link*) BAD_POINTER;     // corrupt ELEM's next pointer
    360:       return (Q1Link*) getptr2(&elem, diff_);
* W088 Argument could be const
    90/1:    bool Enq(T& elem)
    114/1:    bool Henq(T& elem)
    136/1:    bool Insert(T* prev, T& elem)
    171/1:    bool Exq(T& elem)
    328/1:    void Corrupt(T* elem)
* W099 Line contains adjacent spaces
    389:    inline static fn_name Q1Way_dtor()    { return "Q1Way.dtor"; }
    390:    inline static fn_name Q1Way_Init()    { return "Q1Way.Init"; }
    391:    inline static fn_name Q1Way_Enq()     { return "Q1Way.Enq"; }
    392:    inline static fn_name Q1Way_Henq()    { return "Q1Way.Henq"; }
    393:    inline static fn_name Q1Way_Insert()  { return "Q1Way.Insert"; }
    394:    inline static fn_name Q1Way_Deq()     { return "Q1Way.Deq"; }
    395:    inline static fn_name Q1Way_Exq()     { return "Q1Way.Exq"; }
    396:    inline static fn_name Q1Way_Next()    { return "Q1Way.Next"; }
    397:    inline static fn_name Q1Way_Size()    { return "Q1Way.Size"; }
    398:    inline static fn_name Q1Way_Purge()   { return "Q1Way.Purge"; }
    400:    inline static fn_name Q1Way_Item()    { return "Q1Way.Item"; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Link.cpp
* W106 Function does not invoke Debug::ft
    40: Q2Link::~Q2Link()
C:\Users\Greg\Documents\rsc\rsc\src\nb\Q2Way.h
  W004 C-style cast
    145:       return (T*) getptr1(item, diff_);    // location of item's vptr
    174:       return (T*) getptr1(item, diff_);     // location of item's vptr
    191:          item = (Q2Link*)
    197:          elem = (T*) getptr1(item, diff_);  // location of item's vptr
    208:       return (T*) getptr1(item, diff_);       // location of next item's vptr
    218:       return (T*) getptr1(item, diff_);     // location of item's vptr
    235:          item = (Q2Link*)
    241:          elem = (T*) getptr1(item, diff_);  // location of item's vptr
    252:       return (T*) getptr1(item, diff_);       // location of next item's vptr
    336:       return (Q2Link*) getptr2(&elem, diff_);
* W032 Unused function
    298:    void Display(std::ostream& stream,
* W088 Argument could be const
    150/1:    bool Exq(T& elem)
* W090 Function could be const
    150:    bool Exq(T& elem)
* W099 Line contains adjacent spaces
    366:    inline static fn_name Q2Way_dtor()  { return "Q2Way.dtor"; }
    367:    inline static fn_name Q2Way_Init()  { return "Q2Way.Init"; }
    368:    inline static fn_name Q2Way_Enq()   { return "Q2Way.Enq"; }
    369:    inline static fn_name Q2Way_Henq()  { return "Q2Way.Henq"; }
    370:    inline static fn_name Q2Way_Deq()   { return "Q2Way.Deq"; }
    371:    inline static fn_name Q2Way_Exq()   { return "Q2Way.Exq"; }
    372:    inline static fn_name Q2Way_Next()  { return "Q2Way.Next"; }
    373:    inline static fn_name Q2Way_Prev()  { return "Q2Way.Prev"; }
    374:    inline static fn_name Q2Way_Size()  { return "Q2Way.Size"; }
    376:    inline static fn_name Q2Way_Item()  { return "Q2Way.Item"; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\RegCell.cpp
* W106 Function does not invoke Debug::ft
    38: RegCell::~RegCell()
    50: void RegCell::SetId(id_t cid)
C:\Users\Greg\Documents\rsc\rsc\src\nb\Registry.h
  W004 C-style cast
    116:       registry_ = (T**) Memory::Alloc(size, mem);
    506:                auto cell = (RegCell*) getptr2(item, diff_);
    564:       return (RegCell*) getptr2(&item, diff_);
    579:       auto table = (T**) Memory::Alloc(size, mem_);
* W042 Member could be private
    493:    void Purge()
* W088 Argument could be const
    277/1:    bool Erase(T& item)
* W099 Line contains adjacent spaces
    626:    inline static fn_name Registry_ctor()   { return "Registry.ctor"; }
    627:    inline static fn_name Registry_dtor()   { return "Registry.dtor"; }
    628:    inline static fn_name Registry_Init()   { return "Registry.Init"; }
    630:    inline static fn_name Registry_Erase()  { return "Registry.Erase"; }
    631:    inline static fn_name Registry_Next()   { return "Registry.Next"; }
    632:    inline static fn_name Registry_Prev()   { return "Registry.Prev"; }
    633:    inline static fn_name Registry_Size()   { return "Registry.Size"; }
    634:    inline static fn_name Registry_Empty()  { return "Registry.Empty"; }
    635:    inline static fn_name Registry_Purge()  { return "Registry.Purge"; }
    636:    inline static fn_name Registry_Cell()   { return "Registry.Cell"; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Restart.cpp
* W106 Function does not invoke Debug::ft
    38: bool Restart::ClearsMemory(MemoryType type)
    69: RestartLevel Restart::LevelToClear(MemoryType type)
C:\Users\Greg\Documents\rsc\rsc\src\nb\RootThread.cpp
* W106 Function does not invoke Debug::ft
    61: static Gate& ExitGate()
C:\Users\Greg\Documents\rsc\rsc\src\nb\RootThread.h
* W092 Function could be free
    48:    static main_t Main(); // main.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\Singleton.h
  W004 C-style cast
    85:       reg->BindInstance((const Base**) &Instance_, type);
    104:       reg->UnbindInstance((const Base**) &Instance_);
* W099 Line contains adjacent spaces
    129:    inline static fn_name Singleton_Destroy()  { return "Singleton.Destroy"; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\Singletons.cpp
* W053 Data could be const
    41:    MemoryType type;    // the type of memory that the singleton uses
* W106 Function does not invoke Debug::ft
    126: Singletons* Singletons::Instance()
C:\Users\Greg\Documents\rsc\rsc\src\nb\SoftwareException.h
* W043 Member could be protected
    41:    SoftwareException(debug64_t errval, debug64_t offset);
* W060 Base class constructor is public
    41:    SoftwareException(debug64_t errval, debug64_t offset);
    42:    SoftwareException(const std::string& errstr, debug64_t offset);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.cpp
  W006 reinterpret_cast
    89:    auto fake = reinterpret_cast< const Statistic* >(&local);
* W106 Function does not invoke Debug::ft
    117: uint64_t Statistic::Overall() const
    248: uint64_t HighWatermark::Overall() const
    320: uint64_t LowWatermark::Overall() const
C:\Users\Greg\Documents\rsc\rsc\src\nb\Statistics.h
* W043 Member could be protected
    68:    virtual void DisplayStat(std::ostream& stream, const Flags& options) const;
  W050 Data is not private
    87:    std::atomic_size_t curr_;
    91:    std::atomic_size_t prev_;
    95:    std::atomic_uint64_t total_;
    99:    size_t divisor_;
* W053 Data could be const
    115:    RegCell sid_;
* W060 Base class constructor is public
    131:    explicit Counter(const std::string& expl, size_t divisor = 1);
  W075 Virtual function is public
    64:    virtual uint64_t Overall() const;
    68:    virtual void DisplayStat(std::ostream& stream, const Flags& options) const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.cpp
  W006 reinterpret_cast
    87:    auto fake = reinterpret_cast< const StatisticsGroup* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsGroup.h
* W042 Member could be private
    54:    static const size_t ReportWidth;
    62:    id_t Gid() const { return gid_.GetId(); }
* W053 Data could be const
    97:    RegCell gid_;
  W075 Virtual function is public
    70:    virtual void DisplayStats
* W127 Data could be free
    54:    static const size_t ReportWidth; // StatisticsRegistry.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsRegistry.cpp
* W106 Function does not invoke Debug::ft
    131: StatisticsGroup* StatisticsRegistry::GetGroup(id_t gid) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\StatisticsRegistry.h
* W090 Function could be const
    77:    void StartInterval(bool first);
C:\Users\Greg\Documents\rsc\rsc\src\nb\StreamRequest.h
* W043 Member could be protected
    59:    StreamRequest(const StreamRequest& that);
* W060 Base class constructor is public
    54:    StreamRequest();
C:\Users\Greg\Documents\rsc\rsc\src\nb\Symbol.cpp
  W006 reinterpret_cast
    96:    auto fake = reinterpret_cast< const Symbol* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Symbol.h
* W053 Data could be const
    112:    Q1Link link_;
C:\Users\Greg\Documents\rsc\rsc\src\nb\SymbolRegistry.h
  W082 Adjacent arguments have the same type
    59:    bool BindSymbol
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysConsole.cpp
* W106 Function does not invoke Debug::ft
    33: std::istream& SysConsole::In()
    40: ostream& SysConsole::Out()
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysDecls.h
  W044 Typedef of pointer type
    46: typedef void* SysHeap_t;
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysFile.cpp
* W106 Function does not invoke Debug::ft
    68: size_t SysFile::FindExt(const string& name, const string& ext)
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysHeap.h
* W032 Unused function
    107:    SysHeap(MemoryType type, size_t size);
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysHeap.win.cpp
* W106 Function does not invoke Debug::ft
    107: void* SysHeap::Addr() const
    142: bool SysHeap::CanBeProtected() const { return false; }
    190: size_t SysHeap::Overhead() const { return 0; }
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.cpp
* W106 Function does not invoke Debug::ft
    38: SysLock::~SysLock()
    48: void SysLock::Acquire()
    65: void SysLock::Release()
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysLock.h
  W026 Unused argument
    79/3:       const std::string& prefix, const Flags& options) const;
  W027 Unused class
    44: class SysLock
* W032 Unused function
    49:    SysLock();
    66:    void Acquire();
    70:    void Release();
    74:    SysThreadId Owner() const { return owner_; }
    78:    void Display(std::ostream& stream,
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.h
  W026 Unused argument
    45/2:    bool Free(void* addr, size_t size);
* W032 Unused function
    49:    bool Lock(void* addr, size_t size);
    54:    bool Unlock(void* addr, size_t size);
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMemory.win.cpp
* W106 Function does not invoke Debug::ft
    50: static DWORD GetMemoryProtection(MemoryProtection attrs)
  W119 Argument passed by value is modified
    72/1: void* SysMemory::Alloc(void* addr, size_t size, MemoryProtection attrs)
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMutex.cpp
  W006 reinterpret_cast
    105:    auto fake = reinterpret_cast<const SysMutex*>(&local);
* W106 Function does not invoke Debug::ft
    125: Thread* SysMutex::Owner() const
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysMutex.h
* W032 Unused function
    115:    Thread* Owner() const;
* W053 Data could be const
    140:    RegCell mid_;
C:\Users\Greg\Documents\rsc\rsc\src\nb\SystemTime.cpp
  W056 Implicit constructor invoked: POD members not initialized
  i 101:    tm ymdhms;
  W131 C-style preprocessor directive
    74: #ifdef OS_WIN
    79: #ifdef OS_LINUX
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.cpp
* W106 Function does not invoke Debug::ft
    105: bool SysThread::ReportError(fn_name function, fixed_string expl, int error)
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.h
  W082 Adjacent arguments have the same type
    96:    static bool ReportError(fn_name function, fixed_string expl, int error);
* W090 Function could be const
    161:    DelayRc Suspend(Gate& gate, const msecs_t& timeout);
* W092 Function could be free
    96:    static bool ReportError(fn_name function, fixed_string expl, int error); // SysThread.win.cpp
    101:    static void ConfigureProcess(); // RootThread.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThread.win.cpp
  W004 C-style cast
    185:       (nullptr, size, EnterThread, (void*) client, 0, &id);
    193:    SetThreadPriorityBoost((HANDLE) nthread_, true);
    205:       CloseHandle((HANDLE) nthread_);
    239:    if(!SetThreadPriority((HANDLE) nthread_, PriorityMap[prio]))
    274:    _set_se_translator((_se_translator_function) SE_Handler);
  W008 Cast removes const qualification
    185:       (nullptr, size, EnterThread, (void*) client, 0, &id);
* W106 Function does not invoke Debug::ft
    49: static signal_t AccessViolationType(const _EXCEPTION_POINTERS* ex)
    219: void SysThread::RegisterForSignal(signal_t sig, sighandler_t handler)
    226: SysThreadId SysThread::RunningThreadId() NO_FT
  W107 Function does not invoke Debug::ft as first statement
    73:    Debug::ft("NodeBase.SE_Handler");
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.h
  W026 Unused argument
    38/1:    void Startup(RestartLevel level);
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysThreadStack.win.cpp
  W004 C-style cast
    165:    Symbols = (SYMBOL_INFO*) Memory::Alloc(size, MemPermanent, std::nothrow);
* W015 #include not sorted in standard order
    31: #include <Windows.h>
  W044 Typedef of pointer type
    54: typedef void* StackFrames[MaxFrames];
  W082 Adjacent arguments have the same type
    92:    static const char* GetFileLoc(DWORD64 frame, DWORD& line, DWORD& disp);
* W106 Function does not invoke Debug::ft
    122: fn_depth StackInfo::GetFrames(StackFramesPtr& frames)
    147: void StackInfo::Shutdown()
    156: DWORD StackInfo::Startup()
    270: fn_depth SysThreadStack::FuncDepth()
    315: bool SysThreadStack::TrapIsOk() NO_FT
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.cpp
  W006 reinterpret_cast
    40:    auto bytes = reinterpret_cast< uint8_t* >(&value);
* W106 Function does not invoke Debug::ft
    37: static uintptr_t BadPointer()
C:\Users\Greg\Documents\rsc\rsc\src\nb\SysTypes.h
* W028 Unused data
    50: constexpr uword UWORD_MAX = (sizeof(word) == 8 ? UINT64_MAX : UINT32_MAX);
* W030 Unused enumerator
    194:    MemInaccessible = 0,      // ---
    195:    MemExecuteOnly = 1,       // --x
    197:    MemReadExecute = 5,       // r-x
    199:    MemReadWriteExecute = 7,  // rwx
  W044 Typedef of pointer type
    101: typedef char* ptr_t;
    102: typedef const char* const_ptr_t;
    119: typedef const char* c_string;
    120: typedef const char* const fixed_string;
    125: typedef const char* const fn_name;      // for defining a function name
    126: typedef const char* const fn_name_arg;  // when fn_name is an argument
C:\Users\Greg\Documents\rsc\rsc\src\nb\ThisThread.cpp
* W106 Function does not invoke Debug::ft
    32: bool ThisThread::EnterBlockingOperation(BlockingReason why, fn_name_arg func)
    39: void ThisThread::ExitBlockingOperation(fn_name_arg func)
    46: void ThisThread::IncludeInTrace()
    53: DelayRc ThisThread::Pause(const msecs_t& timeout)
    60: void ThisThread::PauseOver(word limit)
    67: word ThisThread::RtcPercentUsed()
    74: ThreadId ThisThread::RunningThreadId()
    81: TraceRc ThisThread::StartTracing(const string& opts)
    88: void ThisThread::StopTracing()
C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.cpp
  W006 reinterpret_cast
    1264:    auto p = reinterpret_cast< char* >(BAD_POINTER);
  W009 Pointer arithmetic
    2996:    ptrdiff_t stacksize = &local - priv_->stackBase_;
* W048 Data is write-only
    921:    SteadyTime::Point readyTime_;
* W099 Line contains adjacent spaces
    275:    CounterPtr       traps_;
    276:    CounterPtr       exceeds_;
    277:    CounterPtr       yields_;
    278:    CounterPtr       interrupts_;
    282:    AccumulatorPtr   totTime_;
* W106 Function does not invoke Debug::ft
    89: static std::map< SysThreadId, std::atomic_flag >& AccessFtLocks() NO_FT
    100: static std::atomic_flag& AccessFtLock() NO_FT
    122: static void EraseFtLock() NO_FT
    455: ContextSwitch* ContextSwitches::AddSwitch()
    1091: static bool ClearActiveThread(Thread* active)
    1217: Thread* Thread::ActiveThread() NO_FT
    1227: SysMutex* Thread::BlockingMutex() const
    1234: TraceStatus Thread::CalcStatus(bool dynamic) const
    1252: bool Thread::CanBeScheduled() const
    1690: void Thread::ExitIfSafe(debug64_t offset) NO_FT
    1778: Thread* Thread::FindRunningThread() NO_FT
    1802: void Thread::FunctionInvoked(fn_name_arg func) NO_FT
    1846: void Thread::FunctionInvoked(fn_name_arg func, const std::nothrow_t&) NO_FT
    1864: BlockingReason Thread::GetBlockingReason() const
    1871: signal_t Thread::GetSignal() const
    1878: TraceStatus Thread::GetStatus() const
    2039: bool Thread::IsLocked() const
    2046: bool Thread::IsScheduled() const
    2053: bool Thread::IsTraceable() const
    2109: Thread* Thread::LockedThread()
    2171: TraceRc Thread::LogContextSwitches(bool on)
    2349: uint8_t Thread::MutexCount() const
    2356: SysThreadId Thread::NativeThreadId() const NO_FT
    2373: DelayRc Thread::Pause(msecs_t time)
    2419: double Thread::PercentIdle()
    2710: void Thread::ResetDebugFlags()
    2804: Thread* Thread::RunningThread() NO_FT
    2830: Thread* Thread::RunningThread(const std::nothrow_t&) NO_FT
    2884: void Thread::SetStatus(TraceStatus status)
    2987: void Thread::StackCheck() NO_FT
    3302: TraceRc Thread::StartTracing(const string& opts)
    3334: void Thread::StopTracing()
    3503: bool Thread::TraceRunningThread(Thread*& thr)
    3531: bool Thread::TraceRunningThread(Thread*& thr, const std::nothrow_t&)
    3558: void Thread::TrapCheck() NO_FT
    3764: void Thread::UpdateMutex(SysMutex* mutex)
    3771: void Thread::UpdateMutexCount(bool acquired)
  W107 Function does not invoke Debug::ft as first statement
    1629:    Debug::ft("Thread.Exit");
    2623:    Debug::ft("Thread.Ready");
    2954:    Debug::ft("Thread.SignalHandler");
    3029:             Debug::ft("Thread.Start(initializing)");
    3575:       Debug::ft(Thread_TrapHandler);  //@
  W110 Override of Base.Display not found
    269: class ThreadStats : public Dynamic
    356: class ContextSwitches : public Permanent
* W111 Override of Object.Patch not found
    356: class ContextSwitches : public Permanent
    784: class ThreadPriv : public Permanent
  W119 Argument passed by value is modified
    1091/1: static bool ClearActiveThread(Thread* active)
    1885/1: bool Thread::HandleSignal(signal_t sig, uint32_t code)
    2373/1: DelayRc Thread::Pause(msecs_t time)
    3486/1: void Thread::Trace(Thread* thr,
C:\Users\Greg\Documents\rsc\rsc\src\nb\Thread.h
  W026 Unused argument
    329/2:       (BlockingReason why, fn_name_arg func) { return true; }
    338/1:    virtual void ScheduledIn(fn_name_arg func) { }
* W032 Unused function
    129:    static std::atomic_uint32_t* Vector();
    133:    static bool TestFlag(FlagId fid);
    137:    static void ResetFlag(FlagId fid);
    160:    Faction GetFaction() const { return faction_; }
    164:    bool ChangeFaction(Faction faction);
    410:    static main_t EnterThread(void* arg);
    488:    SysMutex* BlockingMutex() const;
    496:    uint8_t MutexCount() const;
* W042 Member could be private
    141:    static void ResetFlags();
    156:    SysThreadId NativeThreadId() const;
* W065 Base class virtual destructor is not public
    270:    virtual ~Thread();
  W075 Virtual function is public
    117:    virtual bool EnqMsg(MsgBuffer& msg);
    181:    virtual TraceStatus CalcStatus(bool dynamic) const;
    241:    virtual void DisplayStats(std::ostream& stream, const Flags& options) const;
* W077 Virtual function has no overrides
    117:    virtual bool EnqMsg(MsgBuffer& msg);
    241:    virtual void DisplayStats(std::ostream& stream, const Flags& options) const;
    283:    virtual MsgBuffer* DeqMsg(const msecs_t& timeout);
  W082 Adjacent arguments have the same type
    644:    void DisplaySummary(std::ostream& stream,
* W090 Function could be const
    125:    bool Interrupt(const Flags& mask = NoFlags);
    168:    void SetStatus(TraceStatus status);
    277:    void SetInitialized();
    418:    void Reset(FlagId fid);
    422:    void Ready();
    426:    void Preempt();
    445:    void Proceed();
    484:    void UpdateMutex(SysMutex* mutex);
    492:    void UpdateMutexCount(bool acquired);
    544:    bool LogTrap(const Exception* ex,
    592:    void SetTrap(bool on);
    600:    void StackCheck();
    604:    void SetSignal(signal_t sig);
* W092 Function could be free
    226:    static double PercentIdle(); // NbIncrement.cpp
    410:    static main_t EnterThread(void* arg); // Thread.cpp
    637:    static void EnableFactions(const FactionFlags& enabled); // ModuleRegistry.cpp
    653:    static TraceRc LogContextSwitches(bool on); // NbIncrement.cpp
    661:    static void DisplayContextSwitches(std::ostream& stream); // NbIncrement.cpp
  W121 Static member function has indirect argument for its class
    587/1:    static void Trace(Thread* thr, fn_name_arg func,
C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.cpp
* W106 Function does not invoke Debug::ft
    205: static ThreadAdmin* AccessAdminData()
    291: bool ThreadAdmin::BreakEnabled()
    367: void ThreadAdmin::Incr(Register r)
    454: bool ThreadAdmin::ReinitOnSchedTimeout()
    462: word ThreadAdmin::RtcInterval()
    470: word ThreadAdmin::RtcLimit()
    478: msecs_t ThreadAdmin::RtcTimeout()
    487: msecs_t ThreadAdmin::SchedTimeout()
    507: word ThreadAdmin::StackCheckInterval()
    515: word ThreadAdmin::StackUsageLimit()
    547: word ThreadAdmin::TrapCount()
    559: word ThreadAdmin::TrapInterval()
    567: word ThreadAdmin::TrapLimit()
    575: bool ThreadAdmin::TrapOnRtcTimeout()
  W110 Override of Base.Display not found
    54: class ThreadsStats : public Dynamic
C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadAdmin.h
* W099 Line contains adjacent spaces
    182:    CfgIntParmPtr  initTimeoutMsecs_;
    183:    CfgIntParmPtr  schedTimeoutMsecs_;
    185:    CfgIntParmPtr  rtcTimeoutMsecs_;
    187:    CfgIntParmPtr  rtcLimit_;
    188:    CfgIntParmPtr  rtcInterval_;
    190:    CfgIntParmPtr  trapLimit_;
    191:    CfgIntParmPtr  trapInterval_;
    193:    CfgIntParmPtr  stackUsageLimit_;
    194:    CfgIntParmPtr  stackCheckInterval_;
C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.cpp
* W106 Function does not invoke Debug::ft
    48: static bool IsSortedByThreadId(const Thread* thr1, const Thread* thr2)
    298: Thread* ThreadRegistry::FindThread(SysThreadId nid) const NO_FT
    307: ThreadId ThreadRegistry::FindTid(SysThreadId nid) const NO_FT
    347: Thread* ThreadRegistry::GetThread(ThreadId tid) const
    360: std::vector< Thread* > ThreadRegistry::GetThreads() const
    398: bool ThreadRegistry::IsDeleted() const
    558: size_t ThreadRegistry::Size()
C:\Users\Greg\Documents\rsc\rsc\src\nb\ThreadRegistry.h
* W053 Data could be const
    75:    ThreadId tid_;
C:\Users\Greg\Documents\rsc\rsc\src\nb\Tool.cpp
  W006 reinterpret_cast
    67:    auto fake = reinterpret_cast< const Tool* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nb\Tool.h
  W075 Virtual function is public
    64:    virtual c_string Name() const = 0;
    68:    virtual c_string Expl() const = 0;
    74:    virtual std::string Status() const;
C:\Users\Greg\Documents\rsc\rsc\src\nb\ToolRegistry.cpp
* W106 Function does not invoke Debug::ft
    117: Tool* ToolRegistry::GetTool(FlagId id) const
C:\Users\Greg\Documents\rsc\rsc\src\nb\ToolTypes.h
* W030 Unused enumerator
    66:    TraceFailed,        // operation failed for some other reason
C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.cpp
  W004 C-style cast
    217:    buff_ = (TraceRecord**)
    221:    funcs_ = (FunctionTrace*)
  W005 Functional cast
    594:    stream << indent << "buffsize : " << int(std::log2(size_));
  W007 Cast down the inheritance hierarchy
    448:          auto ft = static_cast< FunctionTrace* >(rec);
    479:          auto ft = static_cast< FunctionTrace* >(rec);
* W106 Function does not invoke Debug::ft
    113: TraceBuffer::TraceBuffer() :
    149: TraceBuffer::~TraceBuffer()
    169: void* TraceBuffer::AddFunction()
    237: uint32_t TraceBuffer::AllocSlot()
    387: bool TraceBuffer::Empty() const
    405: bool TraceBuffer::Insert(TraceRecord* record)
    437: fn_depth TraceBuffer::LastDtorDepth(SysThreadId nid) const
    469: const FunctionTrace* TraceBuffer::LastFunction(SysThreadId nid) const
    489: void TraceBuffer::Lock()
    496: void TraceBuffer::MoveAbove(TraceRecord* second, const TraceRecord* first) const
    516: void TraceBuffer::Next(TraceRecord*& curr, const Flags& mask) const
    627: void TraceBuffer::RecordInvocation(fn_name_arg func) const
    792: void TraceBuffer::Unlock()
* W117 Line can merge with the next line and be under the length limit
    560:          (curr->slot_ != TraceRecord::InvalidSlot) &&
  W119 Argument passed by value is modified
    189/1: bool TraceBuffer::AllocBuffers(size_t n)
    368/1: TraceRc TraceBuffer::DisplayTrace(ostream* stream, const string& opts)
C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceBuffer.h
  W026 Unused argument
    152/1:    TraceRc StartTracing(const std::string& opts);
* W032 Unused function
    182:    const SystemTime::Point& StartTime() const { return startTime_; }
* W092 Function could be free
    105:    void QueryTools(std::ostream& stream) const; // NbIncrement.cpp
  W110 Override of Base.Display not found
    64: class TraceBuffer : public Permanent
C:\Users\Greg\Documents\rsc\rsc\src\nb\TraceRecord.h
* W042 Member could be private
    54:    static const uint32_t InvalidSlot;
  W050 Data is not private
    125:    Id rid_ : 8;
  W075 Virtual function is public
    83:    virtual bool Display(std::ostream& stream, const std::string& opts);
* W090 Function could be const
    105:    virtual void ClaimBlocks() { }
C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.cpp
  W004 C-style cast
    93:    functionq_ = (Q2Way< FunctionStats >*) Memory::Alloc(size, MemTemporary);
  W007 Cast down the inheritance hierarchy
    203:             auto ft = static_cast<FunctionTrace*>(rec);
* W022 Add using statement
    0:  // namespace NodeBase
  W082 Adjacent arguments have the same type
    60: static void CheckHigh(FunctionStats*& high,
* W106 Function does not invoke Debug::ft
    60: static void CheckHigh(FunctionStats*& high,
C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionProfiler.h
* W020 Using statement in header
    37: using namespace NodeBase;
* W090 Function could be const
    84:    FunctionStats* EnsureRecord(fn_name_arg func, size_t count);
  W110 Override of Base.Display not found
    48: class FunctionProfiler : public Temporary
C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.cpp
  W006 reinterpret_cast
    77:    auto fake = reinterpret_cast< const FunctionStats* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    48: int FunctionStats::Compare(const FunctionStats& that) const
    66: void FunctionStats::IncrCalls(const usecs_t& net)
C:\Users\Greg\Documents\rsc\rsc\src\nt\FunctionStats.h
* W020 Using statement in header
    31: using namespace NodeBase;
* W053 Data could be const
    91:    Q2Link link_;
C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.cpp
  W005 Functional cast
    3481:    auto test = RecoveryThread::Test(index);
  W006 reinterpret_cast
    1499:    auto fake = reinterpret_cast< const Q1WayItem* >(&local);
    1993:    auto fake = reinterpret_cast< const Q2WayItem* >(&local);
    2504:    auto fake = reinterpret_cast< const RegistryItem* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
* W053 Data could be const
    1365:    Q1Link link_;
    1851:    Q2Link link_;
  W082 Adjacent arguments have the same type
    201:    static word Sort(const string& input, const string& output, string& expl);
* W106 Function does not invoke Debug::ft
    1007: static word CheckHeap(bool shouldExist, const CliThread& cli, Heap*& heap)
    1478: Q1WayItem::~Q1WayItem()
    1509: Q1WayPool::Q1WayPool()
    1538: void Q1WayPool::Reallocate()
    1972: Q2WayItem::~Q2WayItem()
    2003: Q2WayPool::Q2WayPool()
    2032: void Q2WayPool::Reallocate()
    2494: RegistryItem::~RegistryItem()
    2522: RegistryPool::RegistryPool()
  W107 Function does not invoke Debug::ft as first statement
    3139:       Debug::ft(RecoveryThread_Enter);
  W110 Override of Base.Display not found
    884: class TestHeap : public NbHeap
    1244: class LbcPool : public Temporary
C:\Users\Greg\Documents\rsc\rsc\src\nt\NtIncrement.h
* W020 Using statement in header
    32: using namespace NodeBase;
* W028 Unused data
    80:    static const id_t LastNtIndex = FuncTraceScope;
* W060 Base class constructor is public
    44:    CorruptWhatParm();
    56:    explicit CorruptCommand(bool bind = true);
    98:    NtSaveWhatParm();
    110:    explicit NtSaveCommand(bool bind = true);
    123:    TestsAction();
    144:    explicit TestsCommand(bool bind = true);
C:\Users\Greg\Documents\rsc\rsc\src\nt\NtModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\nt\NtModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\nt\NtTestData.cpp
  W007 Cast down the inheritance hierarchy
    62:    return static_cast< NtTestData* >(data);
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\nt\NtTestData.h
* W020 Using statement in header
    31: using namespace NodeBase;
* W090 Function could be const
    81:    void Reset();
C:\Users\Greg\Documents\rsc\rsc\src\nt\TestDatabase.cpp
* W106 Function does not invoke Debug::ft
    148: TestDatabase::State TestDatabase::GetState(const string& testname)
C:\Users\Greg\Documents\rsc\rsc\src\nt\TestDatabase.h
  W110 Override of Base.Display not found
    41: class TestDatabase : public NodeBase::Temporary
C:\Users\Greg\Documents\rsc\rsc\src\nw\ByteBuffer.h
  W056 Implicit constructor invoked: POD members not initialized
    63: class TinyBuffer : public ByteBuffer
    74: class SmallBuffer : public ByteBuffer
    85: class MediumBuffer : public ByteBuffer
    96: class LargeBuffer : public ByteBuffer
    107: class HugeBuffer : public ByteBuffer
  W075 Virtual function is public
    44:    virtual NodeBase::byte_t* Bytes() = 0;
    48:    virtual size_t Size() const = 0;
  W110 Override of Base.Display not found
    63: class TinyBuffer : public ByteBuffer
    74: class SmallBuffer : public ByteBuffer
    85: class MediumBuffer : public ByteBuffer
    96: class LargeBuffer : public ByteBuffer
    107: class HugeBuffer : public ByteBuffer
* W111 Override of Object.Patch not found
    35: class ByteBuffer : public NodeBase::Pooled
    63: class TinyBuffer : public ByteBuffer
    74: class SmallBuffer : public ByteBuffer
    85: class MediumBuffer : public ByteBuffer
    96: class LargeBuffer : public ByteBuffer
    107: class HugeBuffer : public ByteBuffer
C:\Users\Greg\Documents\rsc\rsc\src\nw\InputHandler.h
  W026 Unused argument
    138/3:       (IpBuffer& buff, NodeBase::byte_t* src, size_t size) const;
    143/1:    virtual void SocketFailed(SysSocket* socket) const { }
* W043 Member could be protected
    71:    IpPort* Port() const { return port_; }
  W075 Virtual function is public
    101:    virtual IpBuffer* AllocBuff(const NodeBase::byte_t* source, size_t size,
    109:    virtual void NetworkToHost(IpBuffer& buff, NodeBase::byte_t* dest,
    128:    virtual void ReceiveBuff
    137:    virtual NodeBase::byte_t* HostToNetwork
    143:    virtual void SocketFailed(SysSocket* socket) const { }
* W088 Argument could be const
    138/1:       (IpBuffer& buff, NodeBase::byte_t* src, size_t size) const;
C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.cpp
  W004 C-style cast
    78:    buffer_ = (byte_t*) Memory::Alloc(SysSocket::MaxMsgSize, MemDynamic);
  W009 Pointer arithmetic
    187:       source += rcvd;
  W119 Argument passed by value is modified
    141/2:    (const IpPort& port, const byte_t* source, size_t size) const
    141/3:    (const IpPort& port, const byte_t* source, size_t size) const
C:\Users\Greg\Documents\rsc\rsc\src\nw\IoThread.h
* W042 Member could be private
    87:    bool ExitOnRestart(NodeBase::RestartLevel level) const override;
  W050 Data is not private
    91:    const ipport_t port_;
    96:    IpPort* ipPort_;
    100:    SysIpL2Addr self_;
    104:    size_t recvs_;
    108:    SysIpL3Addr txAddr_;
    113:    SysIpL3Addr rxAddr_;
    117:    NodeBase::SteadyTime::Point time_;
    121:    NodeBase::byte_t* buffer_;
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.cpp
  W004 C-style cast
    158:    bytes_ = (byte_t*) newbytes;
  W009 Pointer arithmetic
    134:       Memory::Copy((bytes_ + hdrSize_ + paySize), source, size);
    134:       Memory::Copy((bytes_ + hdrSize_ + paySize), source, size);
    238:       bytes = bytes_ + hdrSize_;
    262:    bytes += hdrSize_;
* W106 Function does not invoke Debug::ft
    194: TraceStatus IpBuffer::GetStatus() const
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpBuffer.h
  W009 Pointer arithmetic
    111:    NodeBase::byte_t* PayloadPtr() const { return bytes_ + hdrSize_; }
* W060 Base class constructor is public
    55:    IpBuffer(NodeBase::MsgDirection dir, size_t header, size_t payload);
  W075 Virtual function is public
    64:    virtual IpBuffer* Clone() const;
    124:    virtual size_t PayloadSize() const;
    143:    virtual bool AddBytes
  W082 Adjacent arguments have the same type
    55:    IpBuffer(NodeBase::MsgDirection dir, size_t header, size_t payload);
* W127 Data could be free
    50:    static const size_t MaxBuffSize; // IpBuffer.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.cpp
  W006 reinterpret_cast
    307:    auto fake = reinterpret_cast< const IpPort* >(&local);
* W099 Line contains adjacent spaces
    60:    CounterPtr       recvs_;
    61:    AccumulatorPtr   bytesRcvd_;
    64:    CounterPtr       discards_;
    65:    CounterPtr       rejects_;
    66:    CounterPtr       sends_;
    67:    AccumulatorPtr   bytesSent_;
    69:    CounterPtr       overflows_;
* W106 Function does not invoke Debug::ft
    221: size_t IpPort::Discards() const
  W110 Override of Base.Display not found
    54: class IpPortStats : public Dynamic
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPort.h
* W042 Member could be private
    189:    virtual IoThread* CreateIoThread();
* W053 Data could be const
    207:    NodeBase::Q1Link link_;
  W075 Virtual function is public
    106:    virtual SysTcpSocket* CreateAppSocket();
    151:    virtual void DisplayStats
* W077 Virtual function has no overrides
    151:    virtual void DisplayStats
* W090 Function could be const
    189:    virtual IoThread* CreateIoThread();
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpPortRegistry.cpp
* W106 Function does not invoke Debug::ft
    287: IpPort* IpPortRegistry::GetPort(ipport_t port, IpProtocol protocol) const
    509: bool IpPortRegistry::UseIPv6()
  W110 Override of Base.Display not found
    57: class LocalAddrCfg : public CfgStrParm
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.cpp
  W006 reinterpret_cast
    72:    auto fake = reinterpret_cast< const IpService* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpService.h
* W020 Using statement in header
    38: using namespace NodeBase;
* W043 Member could be protected
    113:    id_t Sid() const { return sid_.GetId(); }
* W053 Data could be const
    160:    RegCell sid_;
  W075 Virtual function is public
    63:    virtual c_string Name() const = 0;
    67:    virtual IpProtocol Protocol() const = 0;
    71:    virtual Faction GetFaction() const = 0;
    76:    virtual bool Enabled() const = 0;
    80:    virtual size_t RxSize() const { return IoThread::MaxRxBuffSize; }
    84:    virtual size_t TxSize() const { return IoThread::MaxTxBuffSize; }
    91:    virtual CliText* CreateText() const = 0;
    97:    virtual bool HasSharedSocket() const = 0;
    105:    virtual void GetAppSocketSizes(size_t& rxSize, size_t& txSize) const;
* W077 Virtual function has no overrides
    80:    virtual size_t RxSize() const { return IoThread::MaxRxBuffSize; }
    84:    virtual size_t TxSize() const { return IoThread::MaxTxBuffSize; }
* W090 Function could be const
    152:    virtual IpPort* CreatePort(ipport_t pid) = 0;
* W127 Data could be free
    59:    static const id_t MaxId; // IpServiceRegistry.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceCfg.h
* W020 Using statement in header
    29: using namespace NodeBase;
* W053 Data could be const
    60:    IpService* const service_;
  W082 Adjacent arguments have the same type
    43:    IpServiceCfg(c_string key, c_string def, c_string expl, IpService* service);
  W110 Override of Base.Display not found
    38: class IpServiceCfg : public CfgBoolParm
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceRegistry.cpp
* W106 Function does not invoke Debug::ft
    77: std::vector< IpService* > IpServiceRegistry::GetServices
C:\Users\Greg\Documents\rsc\rsc\src\nw\IpServiceRegistry.h
* W032 Unused function
    61:    std::vector< IpService* > GetServices(const std::string& name) const;
C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.cpp
  W006 reinterpret_cast
    243:       auto payload = reinterpret_cast< SysIpL3Addr* >(buff->PayloadPtr());
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    122: bool SendLocalIpService::Enabled() const
C:\Users\Greg\Documents\rsc\rsc\src\nw\LocalAddrTest.h
* W020 Using statement in header
    33: using namespace NodeBase;
  W110 Override of Base.Display not found
    110: class SendLocalIpService : public UdpIpService
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwCliParms.h
* W060 Base class constructor is public
    68:    IpAddrParm(NodeBase::c_string help, NodeBase::c_string text);
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.cpp
  W007 Cast down the inheritance hierarchy
    261:       (this, static_cast< const TcpIpService* >(service), port);
    272:    auto daemon = static_cast< TcpIoDaemon* >(reg->FindDaemon(name.c_str()));
    321:       (this, static_cast<const UdpIpService*>(service), port);
    332:    auto daemon = static_cast< UdpIoDaemon* >(reg->FindDaemon(name.c_str()));
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwDaemons.h
* W053 Data could be const
    98:    IoThreadRecreator* recreator_;
* W092 Function could be free
    111:    static TcpIoDaemon* GetDaemon(const TcpIpService* service, ipport_t port); // TcpIpPort.cpp
    138:    static UdpIoDaemon* GetDaemon(const UdpIpService* service, ipport_t port); // UdpIpPort.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwIncrement.h
* W060 Base class constructor is public
    39:    NwClearWhatParm();
    54:    explicit NwClearCommand(bool bind = true);
    69:    NwExcludeWhatParm();
    82:    explicit NwExcludeCommand(bool bind = true);
    97:    NwIncludeWhatParm();
    110:    explicit NwIncludeCommand(bool bind = true);
    127:    explicit NwQueryCommand(bool bind = true);
    142:    NwStatusCommand() = default;
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwLogs.cpp
* W106 Function does not invoke Debug::ft
    152: static void UpdateAlarm
  W107 Function does not invoke Debug::ft as first statement
    102:    Debug::ft("NetworkBase.NetworkIsUp");
  W119 Argument passed by value is modified
    115/1: void OutputNwLog(LogId id, c_string func, nwerr_t errval, c_string extra)
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTracer.h
* W042 Member could be private
    63:    bool PeersEmpty() const;
    67:    bool PortsEmpty() const;
  W110 Override of Base.Display not found
    40: class NwTracer : public NodeBase::Permanent
C:\Users\Greg\Documents\rsc\rsc\src\nw\NwTypes.h
* W028 Unused data
    108: constexpr ipport_t FirstAppIpPort = 1024;
    114: constexpr ipport_t LastAppIpPort = MaxIpPort;
* W053 Data could be const
    60:       uint8_t  u8[16];  // bytes: [12-15] overlay IPv4Addr
* W099 Line contains adjacent spaces
    60:       uint8_t  u8[16];  // bytes: [12-15] overlay IPv4Addr
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.cpp
  W005 Functional cast
    64:    byte = uint8_t(value);
    101:    quartet = uint16_t(value);
* W106 Function does not invoke Debug::ft
    358: const SysIpL2Addr& SysIpL2Addr::NullIpAddr()
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.h
* W032 Unused function
    113:    static const SysIpL2Addr& NullIpAddr();
    117:    const IPv6Addr& Addr() const { return addr_; }
* W043 Member could be protected
    57:    SysIpL2Addr(const SysIpL2Addr& that) = default;
* W060 Base class constructor is public
    42:    SysIpL2Addr();
    49:    SysIpL2Addr(const std::string& text);
  W075 Virtual function is public
    73:    virtual void Nullify();
* W092 Function could be free
    113:    static const SysIpL2Addr& NullIpAddr(); // SysIpL2Addr.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL2Addr.win.cpp
  W004 C-style cast
    66:                auto netaddr = (sockaddr_in*) curr->ai_addr;
    74:                auto netaddr = (sockaddr_in6*) curr->ai_addr;
  W056 Implicit constructor invoked: POD members not initialized
  i 50:       addrinfo hints;
* W106 Function does not invoke Debug::ft
    127: bool SysIpL2Addr::SupportsIPv6()
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.cpp
  W005 Functional cast
    64:    port = ipport_t(value);
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.h
  W037 Member hides inherited name
    105:    void HostToNetwork(IPv4Addr& netaddr, ipport_t& netport) const;
    110:    void HostToNetwork(uint16_t netaddr[8], ipport_t& netport) const;
    115:    void NetworkToHost(IPv4Addr netaddr, ipport_t netport);
    120:    void NetworkToHost(const uint16_t netaddr[8], ipport_t netport);
    160:    std::string to_str(bool verbose) const;
* W060 Base class constructor is public
    41:    SysIpL3Addr();
    46:    SysIpL3Addr(const SysIpL2Addr& l2Addr, ipport_t port,
    53:    SysIpL3Addr(IPv4Addr netaddr, ipport_t netport,
    60:    SysIpL3Addr(const uint16_t netaddr[8], ipport_t netport,
    69:    explicit SysIpL3Addr(const std::string& text);
    79:    SysIpL3Addr
  W082 Adjacent arguments have the same type
    79:    SysIpL3Addr
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysIpL3Addr.win.cpp
  W004 C-style cast
    65:          auto netaddr = (sockaddr_in*) info->ai_addr;
    88:          auto netaddr = (sockaddr_in6*) info->ai_addr;
    138:       HostToNetwork((IPv4Addr&) ipv4addr.sin_addr.s_addr, ipv4addr.sin_port);
    139:       addrinfo = (sockaddr*) &ipv4addr;
    148:       addrinfo = (sockaddr*) &ipv6addr;
  W056 Implicit constructor invoked: POD members not initialized
  i 51:    addrinfo hints;
  i 132:    sockaddr_in ipv4addr;
  i 133:    sockaddr_in6 ipv6addr;
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.cpp
* W106 Function does not invoke Debug::ft
    155: bool SysSocket::SetTracing(bool tracing)
    185: bool SysSocket::TraceEnabled()
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.h
* W032 Unused function
    50: uint64_t htonll(uint64_t hostllong);
    53: uint64_t ntohll(uint64_t netllong);
* W043 Member could be protected
    107:    bool IsValid() const;
    128:    virtual AllocRc SetService(const IpService* service, bool shared);
    145:    void OutputLog(NodeBase::LogId id,
* W065 Base class virtual destructor is not public
    214:    virtual ~SysSocket();
  W075 Virtual function is public
    99:    virtual IpProtocol Protocol() const { return IpAny; }
    128:    virtual AllocRc SetService(const IpService* service, bool shared);
    134:    virtual SendRc SendBuff(IpBuffer& buff) = 0;
* W092 Function could be free
    156:    static NodeBase::c_string AlarmName(nwerr_t errval); // NwLogs.cpp
    161:    static bool StartLayer(); // NwModule.cpp
    166:    static void StopLayer(); // NwModule.cpp
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysSocket.win.cpp
  W004 C-style cast
    109:          (const char*)&dual, sizeof(dual)) == SOCKET_ERROR)
    135:       addr = (sockaddr*) &ipv4addr;
    145:       addr = (sockaddr*) &ipv6addr;
    276:       (const char*) &rxSize, sizeof(rxSize)) == SOCKET_ERROR)
    283:       (char*) &max, &maxsize) == SOCKET_ERROR)
    295:       (const char*) &txSize, sizeof(txSize)) == SOCKET_ERROR)
    302:       (char*) &max, &maxsize) == SOCKET_ERROR)
* W015 #include not sorted in standard order
    28: #include <WinSock2.h>
  W056 Implicit constructor invoked: POD members not initialized
  i 127:    sockaddr_in ipv4addr;
  i 128:    sockaddr_in6 ipv6addr;
  i 322:    WSAData wsaData;
* W106 Function does not invoke Debug::ft
    43: uint32_t htonl(uint32_t hostlong) { return ::htonl(hostlong); }
    45: uint64_t htonll(uint64_t hostllong) { return ::htonll(hostllong); }
    47: uint16_t htons(uint16_t hostshort) { return ::htons(hostshort); }
    49: uint32_t ntohl(uint32_t netlong) { return ::ntohl(netlong); }
    51: uint64_t ntohll(uint64_t netllong) { return ::ntohll(netllong); }
    53: uint16_t ntohs(uint16_t netshort) { return ::ntohs(netshort); }
    228: bool SysSocket::IsValid() const
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.cpp
  W119 Argument passed by value is modified
    246/1: SysSocket::SendRc SysTcpSocket::QueueBuff(IpBuffer* buff, bool henq)
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.h
* W032 Unused function
    143:    bool LocAddr(SysIpL3Addr& locAddr);
    198:    IpBuffer* IcMsg() const { return icMsg_; }
* W042 Member could be private
    90:    NodeBase::word Connect(const SysIpL3Addr& remAddr);
    138:    NodeBase::word Send(const NodeBase::byte_t* data, size_t size);
    160:    bool SetClose(bool graceful);
    189:    bool IsOpen() const;
  W075 Virtual function is public
    181:    virtual void Acquire();
    185:    virtual void Release();
* W077 Virtual function has no overrides
    181:    virtual void Acquire();
    185:    virtual void Release();
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysTcpSocket.win.cpp
  W004 C-style cast
    56:       peer = (sockaddr*) &ipv6peer;
    61:       peer = (sockaddr*) &ipv4peer;
    111:       peer = (sockaddr*) &ipv6peer;
    118:          ((IPv4Addr&) ipv4peer.sin_addr.s_addr, ipv4peer.sin_port);
    119:       peer = (sockaddr*) &ipv4peer;
    200:       self = (sockaddr*) &ipv6self;
    205:       self = (sockaddr*) &ipv4self;
    338:       peer = (sockaddr*) &ipv6peer;
    343:       peer = (sockaddr*) &ipv4peer;
    409:       (char*) &linger_opts, sizeof(linger)) != SOCKET_ERROR)
    435:       (const char*) &alive, sizeof(alive)) == SOCKET_ERROR)
    445:       (char*) &val, &valsize) == SOCKET_ERROR)
  W006 reinterpret_cast
    311:    auto rcvd = recv(Socket(), reinterpret_cast< char* >(buff), size, 0);
    382:    auto sent = send(Socket(), reinterpret_cast< const char* >(data), size, 0);
  W007 Cast down the inheritance hierarchy
    432:    bool alive = static_cast< const TcpIpService* >(service)->Keepalive();
  W056 Implicit constructor invoked: POD members not initialized
  i 47:    sockaddr_in ipv4peer;
  i 48:    sockaddr_in6 ipv6peer;
  i 98:    sockaddr_in ipv4peer;
  i 99:    sockaddr_in6 ipv6peer;
  i 191:    sockaddr_in ipv4self;
  i 192:    sockaddr_in6 ipv6self;
  i 329:    sockaddr_in ipv4peer;
  i 330:    sockaddr_in6 ipv6peer;
  i 404:    linger linger_opts;
  W119 Argument passed by value is modified
    165/1: word SysTcpSocket::Listen(size_t backlog)
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.h
* W042 Member could be private
    73:    NodeBase::word SendTo
C:\Users\Greg\Documents\rsc\rsc\src\nw\SysUdpSocket.win.cpp
  W004 C-style cast
    58:          (char*) &max, &maxsize) == SOCKET_ERROR)
    99:       peer = (sockaddr*) &ipv6peer;
    104:       peer = (sockaddr*) &ipv4peer;
    185:       peer = (sockaddr*) &ipv6peer;
    192:          ((IPv4Addr&) ipv4peer.sin_addr.s_addr, ipv4peer.sin_port);
    193:       peer = (sockaddr*) &ipv4peer;
  W006 reinterpret_cast
    109:       reinterpret_cast< char* >(buff), size, 0, peer, &peersize);
    198:       reinterpret_cast< const char* >(data), size, 0, peer, peersize);
  W056 Implicit constructor invoked: POD members not initialized
  i 90:    sockaddr_in ipv4peer;
  i 91:    sockaddr_in6 ipv6peer;
  i 172:    sockaddr_in ipv4peer;
  i 173:    sockaddr_in6 ipv6peer;
C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.cpp
  W007 Cast down the inheritance hierarchy
    215:    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
    225:    auto svc = static_cast< const TcpIpService* >(ipPort_->GetService());
    310:    auto registrant = static_cast< SysTcpSocket* >(ipPort_->GetSocket());
    472:    auto sock = static_cast< SysTcpSocket* >(socket);
* W106 Function does not invoke Debug::ft
    492: SysTcpSocket* TcpIoThread::Listener() const
C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIoThread.h
* W042 Member could be private
    75:    void Unblock() override;
C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpPort.cpp
  W007 Cast down the inheritance hierarchy
    61:    auto thread = static_cast< TcpIoThread* >(GetThread());
    67:       thread = static_cast< TcpIoThread* >(CreateThread());
    73:    auto svc = static_cast< const TcpIpService* >(GetService());
    93:    auto svc = static_cast< const TcpIpService* >(GetService());
C:\Users\Greg\Documents\rsc\rsc\src\nw\TcpIpService.h
* W042 Member could be private
    86:    IpPort* CreatePort(ipport_t pid) override;
  W075 Virtual function is public
    40:    virtual bool AcceptsConns() const { return true; }
    45:    virtual size_t MaxConns() const = 0;
    50:    virtual size_t MaxBacklog() const = 0;
    54:    virtual bool Keepalive() const { return false; }
C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.cpp
  W007 Cast down the inheritance hierarchy
    96:    auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
    100:       auto svc = static_cast< const UdpIpService* >(ipPort_->GetService());
    201:       auto socket = static_cast< SysUdpSocket* >(ipPort_->GetSocket());
C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIoThread.h
* W042 Member could be private
    58:    void Unblock() override;
* W090 Function could be const
    62:    void ReleaseResources();
C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIpPort.cpp
  W007 Cast down the inheritance hierarchy
    53:    auto svc = static_cast< const UdpIpService* >(GetService());
C:\Users\Greg\Documents\rsc\rsc\src\nw\UdpIpService.h
* W042 Member could be private
    59:    IpPort* CreatePort(ipport_t pid) override;
C:\Users\Greg\Documents\rsc\rsc\src\on\OnModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\on\OnModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PbModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PbModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBicFeature.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    80: CliText* PotsBicFeature::Attrs() const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBicFeature.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBocFeature.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    69: CliText* PotsBocFeature::Attrs() const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsBocFeature.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    76: CliText* PotsCfbFeature::Attrs() const { return new PotsCfbAttrs; }
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfbFeature.h
* W020 Using statement in header
    30: using namespace CallBase;
    31: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    86: CliText* PotsCfnFeature::Attrs() const { return new PotsCfnAttrs; }
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfnFeature.h
* W020 Using statement in header
    31: using namespace CallBase;
    32: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    76: CliText* PotsCfuFeature::Attrs() const { return new PotsCfuAttrs; }
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCfuFeature.h
* W020 Using statement in header
    30: using namespace CallBase;
    31: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCircuit.h
* W020 Using statement in header
    40: using namespace MediaBase;
    41: using namespace CallBase;
    42: using namespace NodeBase;
    43: using namespace SessionBase;
* W032 Unused function
    93:    bool IsRinging() const { return ringing_; }
    97:    bool CanFlash() const { return flash_; }
    102:    Cause::Ind GetCause() const { return cause_; }
* W042 Member could be private
    134:    void ResetCircuit();
* W092 Function could be free
    138:    static void DisplayStateCounts // AnIncrement.cpp
    147:    static void ResetStateCounts(RestartLevel level); // PotsProfileRegistry.cpp
* W127 Data could be free
    181:    static const SignalEntry NilSignalEntry; // PotsCircuit.cpp
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCliParms.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCliParms.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCwtFeature.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    64: CliText* PotsCwtFeature::Attrs() const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCwtFeature.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCxfFeature.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    65: CliText* PotsCxfFeature::Attrs() const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsCxfFeature.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.cpp
  W006 reinterpret_cast
    84:    auto fake = reinterpret_cast< const PotsFeature* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeature.h
  W005 Functional cast
    72:    Id Fid() const { return Id(fid_.GetId()); }
* W020 Using statement in header
    39: using namespace NodeBase;
  W026 Unused argument
    95/1:       (PotsProfile& profile, CliThread& cli) const = 0;  //d
* W042 Member could be private
    72:    Id Fid() const { return Id(fid_.GetId()); }
    80:    c_string FullName() const { return name_; }
    84:    bool CanBeDeactivated() const { return deactivation_; }
  W075 Virtual function is public
    94:    virtual PotsFeatureProfile* Subscribe
  W082 Adjacent arguments have the same type
    107:    PotsFeature(Id fid, bool deactivation, c_string abbr, c_string name);
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.cpp
  W006 reinterpret_cast
    94:    auto fake = reinterpret_cast< const PotsFeatureProfile* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureProfile.h
* W020 Using statement in header
    31: using namespace NodeBase;
  W026 Unused argument
    63/1:    virtual bool Deactivate(PotsProfile& profile);
    87/1:    virtual bool Unsubscribe(PotsProfile& profile);
* W042 Member could be private
    67:    PotsFeature::Id Fid() const { return fid_; }
* W053 Data could be const
    99:    Q1Link link_;
* W065 Base class virtual destructor is not public
    80:    virtual ~PotsFeatureProfile();
  W075 Virtual function is public
    58:    virtual bool Activate(const PotsProfile& profile, CliThread& cli);  //d
    63:    virtual bool Deactivate(PotsProfile& profile);
* W077 Virtual function has no overrides
    87:    virtual bool Unsubscribe(PotsProfile& profile);
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureRegistry.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    148: PotsFeature* PotsFeatureRegistry::Feature(PotsFeature::Id fid) const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatureRegistry.h
* W020 Using statement in header
    36: using namespace NodeBase;
* W090 Function could be const
    66:    void Audit();
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    105: void DnRouteFeatureProfile::SetActive(bool on)
    113: void DnRouteFeatureProfile::SetDN(Address::DN dn)
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsFeatures.h
* W020 Using statement in header
    29: using namespace CallBase;
    30: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    81: CliText* PotsHtlFeature::Attrs() const { return new PotsHtlAttrs; }
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsHtlFeature.h
* W020 Using statement in header
    30: using namespace NodeBase;
    31: using namespace CallBase;
* W053 Data could be const
    59:    Address::DN dn_;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsIncrement.cpp
  W007 Cast down the inheritance hierarchy
    398:       auto mep = static_cast< MediaEndpt* >(obj);
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsIncrement.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsMessages.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.cpp
  W006 reinterpret_cast
    84:    auto fake = reinterpret_cast< const PotsProfile* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfile.h
* W020 Using statement in header
    36: using namespace NodeBase;
    37: using namespace CallBase;
    38: using namespace SessionBase;
* W090 Function could be const
    108:    void SetState(const ProtocolSM* psm, State state);
    118:    bool SetObjAddr(const MsgPort& port);
  W110 Override of Base.Display not found
    81:    struct PotsProfileDynamic : public Persistent
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    107: PotsProfile* PotsProfileRegistry::Profile(Address::DN dn) const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProfileRegistry.h
* W020 Using statement in header
    35: using namespace NodeBase;
    36: using namespace CallBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.cpp
  W006 reinterpret_cast
    453:    reinterpret_cast< const PotsFacilityInfo* >(bytes)->Display(stream, prefix);
    635:    reinterpret_cast< const PotsHeaderInfo* >(bytes)->Display(stream, prefix);
    748:    reinterpret_cast< const PotsRingInfo* >(bytes)->Display(stream, prefix);
    830:    reinterpret_cast< const PotsScanInfo* >(bytes)->Display(stream, prefix);
  W007 Cast down the inheritance hierarchy
    466:    auto&            pmsg = static_cast< PotsMessage& >(msg);
    523:    auto&             pmsg = static_cast< const PotsMessage& >(msg);
    647:    auto&          pmsg = static_cast< PotsMessage& >(msg);
    671:    auto&           pmsg = static_cast< const PotsMessage& >(msg);
    759:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
    841:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W099 Line contains adjacent spaces
    463:    id_t             index;
    464:    word             sid, ind;
    466:    auto&            pmsg = static_cast< PotsMessage& >(msg);
    522:    TestRc            rc;
    523:    auto&             pmsg = static_cast< const PotsMessage& >(msg);
    525:    id_t              index;
    526:    word              sid, ind;
    645:    word           port;
    647:    auto&          pmsg = static_cast< PotsMessage& >(msg);
    670:    TestRc          rc;
    671:    auto&           pmsg = static_cast< const PotsMessage& >(msg);
    672:    word            port;
    758:    TestRc        rc;
    759:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
    761:    bool          ring = false;
    762:    auto          exists = false;
    840:    TestRc        rc;
    841:    auto&         pmsg = static_cast< const PotsMessage& >(msg);
    843:    string        scan;
    844:    auto          digits = false;
    845:    auto          flash = false;
    846:    auto          exists = false;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsProtocol.h
* W020 Using statement in header
    45: using namespace NodeBase;
    46: using namespace SessionBase;
    47: using namespace MediaBase;
    48: using namespace CallBase;
* W028 Unused data
    105:    static const Id LastId    = NextId + 9;  // range constant
    133:    static const Id LastId   = NextId + 7;  // range constant
* W032 Unused function
    287:    MediaInfo* AddMedia(const MediaInfo& media);
  W038 Class could be namespace
    213: class Facility
* W043 Member could be protected
    263:    explicit PotsMessage(SbIpBufferPtr& buff);
* W060 Base class constructor is public
    263:    explicit PotsMessage(SbIpBufferPtr& buff);
    267:    PotsMessage(ProtocolSM* psm, size_t size);
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsSusFeature.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    62: CliText* PotsSusFeature::Attrs() const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsSusFeature.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsTwcFeature.cpp
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    81: CliText* PotsTwcFeature::Attrs() const
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsTwcFeature.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    85: CliText* PotsWmlFeature::Attrs() const { return new PotsWmlAttrs; }
C:\Users\Greg\Documents\rsc\rsc\src\pb\PotsWmlFeature.h
* W020 Using statement in header
    31: using namespace CallBase;
    32: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\rn\RnModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\rn\RnModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\rsc\main.cpp
* W015 #include not sorted in standard order
    31: #include "SysTypes.h"
* W032 Unused function
    123: main_t main(int argc, char* argv[])
C:\Users\Greg\Documents\rsc\rsc\src\sb\AnalyzeSapEvent.cpp
* W106 Function does not invoke Debug::ft
    86: void AnalyzeSapEvent::Capture
C:\Users\Greg\Documents\rsc\rsc\src\sb\AnalyzeSnpEvent.cpp
* W106 Function does not invoke Debug::ft
    82: void AnalyzeSnpEvent::Capture
C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.cpp
  W006 reinterpret_cast
    576:    auto fake = reinterpret_cast< const Context* >(&local);
    866:             auto toi = reinterpret_cast< TimeoutInfo* >(pptr->bytes);
  W007 Cast down the inheritance hierarchy
    756:                inv = static_cast< InvokerThread* >(Thread::RunningThread());
    861:          auto pptr = static_cast< TlvMessage* >
* W106 Function does not invoke Debug::ft
    334: void Context::Dump() const
    931: bool Context::TraceOn()
    941: bool Context::TraceOn(TransTrace*& trans)
  W107 Function does not invoke Debug::ft as first statement
    688:    Debug::ft(Context_ProcessWork);
  W119 Argument passed by value is modified
    384/3: void Context::Enqueue(Q2Way< Context >& whichq, MsgPriority prio, bool henq)
    682/1: void Context::ProcessWork(InvokerThread* inv)
C:\Users\Greg\Documents\rsc\rsc\src\sb\Context.h
* W032 Unused function
    120:    static void Kill(NodeBase::debug64_t errval, NodeBase::debug64_t offset);
    125:    static void Dump(NodeBase::fn_name_arg func,
  W037 Member hides inherited name
    166:    static ptrdiff_t LinkDiff();
* W042 Member could be private
    158:    bool StopTimer(const Base& owner, TimerId tid);
    192:    virtual void EndOfTransaction() { }
* W053 Data could be const
    309:    NodeBase::Q2Link link_;
    333:    NodeBase::Faction faction_;
* W065 Base class virtual destructor is not public
    188:    virtual ~Context();
  W075 Virtual function is public
    98:    virtual ContextType Type() const = 0;
    102:    virtual RootServiceSM* RootSsm() const { return nullptr; }
    106:    virtual ProtocolSM* FirstPsm() const { return nullptr; }
    110:    virtual void NextPsm(ProtocolSM*& psm) const { psm = nullptr; }
    114:    virtual void NextPort(MsgPort*& port) const { port = nullptr; }
  W082 Adjacent arguments have the same type
    132:    void TraceMsg(ProtocolId prid, SignalId sid, NodeBase::MsgDirection dir);
* W088 Argument could be const
    288/1:    bool ProcessMsg(NodeBase::Q1Way< Message >& msgq, const InvokerThread* inv);
* W090 Function could be const
    158:    bool StopTimer(const Base& owner, TimerId tid);
    192:    virtual void EndOfTransaction() { }
* W092 Function could be free
    84:    static RootServiceSM* ContextRoot(); // Event.cpp
    120:    static void Kill(NodeBase::debug64_t errval, NodeBase::debug64_t offset); // Context.cpp
    125:    static void Dump(NodeBase::fn_name_arg func, // Context.cpp
* W127 Data could be free
    361:    static const MessageEntry NilMessageEntry; // Context.cpp
  W141 Function could be moved to a subclass
    192:    virtual void EndOfTransaction() { } // MsgContext
C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.cpp
* W106 Function does not invoke Debug::ft
    137: void Event::Capture
C:\Users\Greg\Documents\rsc\rsc\src\sb\Event.h
* W042 Member could be private
    130:    virtual bool Save();
    134:    virtual Event* Restore(EventHandler::Rc& rc);
    138:    virtual void Free();
* W043 Member could be protected
    96:    enum Location
* W092 Function could be free
    70:    static bool AppCanHandle(Id eid) // State.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sb\EventHandler.h
  W075 Virtual function is public
    123:    virtual Rc ProcessEvent
* W092 Function could be free
    92:    static bool AppCanRegister(Id ehid) // Service.cpp
    100:    static bool AppCanUse(Id ehid) // State.cpp
* W111 Override of Object.Patch not found
    48: class EventHandler : public NodeBase::Immutable
C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.cpp
  W006 reinterpret_cast
    201:    auto fake = reinterpret_cast< const Factory* >(&local);
* W099 Line contains adjacent spaces
    53:    CounterPtr       icMsgsIntra_;
    54:    CounterPtr       icMsgsInter_;
    56:    CounterPtr       ogMsgsIntra_;
    57:    CounterPtr       ogMsgsInter_;
    59:    CounterPtr       contexts_;
    60:    CounterPtr       msgsDeleted_;
    61:    CounterPtr       ctxsDeleted_;
* W106 Function does not invoke Debug::ft
    216: size_t Factory::DiscardedContextCount() const
    223: size_t Factory::DiscardedMessageCount() const
  W110 Override of Base.Display not found
    45: class FactoryStats : public Dynamic
C:\Users\Greg\Documents\rsc\rsc\src\sb\Factory.h
  W005 Functional cast
    91:    Id Fid() const { return Id(fid_.GetId()); }
  W026 Unused argument
    131/1:    virtual Message* AllocOgMsg(SignalId sid) const;
    151/1:    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
    151/2:    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
* W030 Unused enumerator
    85:       PortAllocFailed,      // failed to create PSM for context
* W032 Unused function
    231:    void SetFaction(NodeBase::Faction faction) { faction_ = faction; }
* W042 Member could be private
    151:    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
    235:    virtual Context* AllocContext() const;
  W075 Virtual function is public
    125:    virtual NodeBase::CliText* CreateText() const;
    131:    virtual Message* AllocOgMsg(SignalId sid) const;
    138:    virtual bool InjectMsg(Message& msg) const;
    144:    virtual Message* ReallocOgMsg(SbIpBufferPtr& buff) const;
    151:    virtual bool ScreenFirstMsg(const Message& msg, MsgPriority& prio) const;
    161:    virtual bool ScreenIcMsgs(NodeBase::Q1Way< Message >& msgq);
    183:    virtual void DisplayStats
* W077 Virtual function has no overrides
    183:    virtual void DisplayStats
  W082 Adjacent arguments have the same type
    168:    void RecordMsg(bool incoming, bool inter, size_t size) const;
* W088 Argument could be const
    161/1:    virtual bool ScreenIcMsgs(NodeBase::Q1Way< Message >& msgq);
* W090 Function could be const
    161:    virtual bool ScreenIcMsgs(NodeBase::Q1Way< Message >& msgq);
    257:    virtual Rc ReceiveMsg
  W141 Function could be moved to a subclass
    235:    virtual Context* AllocContext() const; // PsmFactory
C:\Users\Greg\Documents\rsc\rsc\src\sb\FactoryRegistry.cpp
* W106 Function does not invoke Debug::ft
    147: Factory* FactoryRegistry::GetFactory(FactoryId fid) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\GlobalAddress.h
* W032 Unused function
    47:    GlobalAddress(const NetworkBase::SysIpL3Addr& l3Addr, FactoryId fid);
    66:    GlobalAddress(GlobalAddress&& that) = default;
  W082 Adjacent arguments have the same type
    51:    GlobalAddress
C:\Users\Greg\Documents\rsc\rsc\src\sb\InitiationReqEvent.cpp
* W106 Function does not invoke Debug::ft
    84: void InitiationReqEvent::Capture
C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.cpp
  W006 reinterpret_cast
    217:    auto fake = reinterpret_cast< const Initiator* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\sb\Initiator.h
* W053 Data could be const
    137:    NodeBase::Q1Link link_;
* W065 Base class virtual destructor is not public
    99:    virtual ~Initiator();
  W082 Adjacent arguments have the same type
    94:    Initiator(ServiceId sid, ServiceId aid, TriggerId tid, Priority prio);
* W088 Argument could be const
    108/2:       (const ServiceSM& parentSsm, Event& currEvent, Event*& nextEvent) const;
C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.cpp
  W006 reinterpret_cast
    283:    auto fake = reinterpret_cast< const InvokerPool* >(&local);
  W007 Cast down the inheritance hierarchy
    240:    invokersCfg_.reset(static_cast< CfgIntParm* >(reg->FindParm(parmKey)));
    567:       auto inv = static_cast< InvokerThread* >(Thread::RunningThread());
* W099 Line contains adjacent spaces
    120:    CounterPtr       requeues_;
    121:    CounterPtr       trojans_;
    122:    CounterPtr       lockouts_;
* W106 Function does not invoke Debug::ft
    738: void InvokerPool::RecordDelay(MsgPriority prio, const nsecs_t& delay) const
    790: size_t InvokerPool::WorkQCurrLength(MsgPriority prio) const
    798: nsecs_t InvokerPool::WorkQMaxDelay(MsgPriority prio) const
    806: size_t InvokerPool::WorkQMaxLength(MsgPriority prio) const
  W110 Override of Base.Display not found
    111: class InvokerPoolStats : public Dynamic
    152: class InvokerWork : public Dynamic
C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPool.h
  W005 Functional cast
    72:       { return NodeBase::Faction(faction_.GetId()); }
  W075 Virtual function is public
    90:    virtual void DisplayStats
* W077 Virtual function has no overrides
    90:    virtual void DisplayStats
* W090 Function could be const
    149:    void KickThread();
    153:    Context* FindWork();
    172:    void Requeue(Context& ctx);
    180:    void ScheduledOut();
C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerPoolRegistry.cpp
  W005 Functional cast
    87:       auto p = reg->Pool(Faction(id));
* W106 Function does not invoke Debug::ft
    169: InvokerPool* InvokerPoolRegistry::Pool(Faction faction) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.cpp
  W006 reinterpret_cast
    130:    auto fake = reinterpret_cast< const InvokerThread* >(&local);
* W106 Function does not invoke Debug::ft
    119: TraceStatus InvokerThread::CalcStatus(bool dynamic) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\InvokerThread.h
* W042 Member could be private
    57:    static NodeBase::word RtcYieldPercent() { return RtcYieldPercent_; }
* W053 Data could be const
    132:    NodeBase::RegCell iid_;
    158:    static NodeBase::word RtcYieldPercent_;
C:\Users\Greg\Documents\rsc\rsc\src\sb\LocalAddress.h
* W032 Unused function
    55:    LocalAddress(LocalAddress&& that) = default;
C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.cpp
* W106 Function does not invoke Debug::ft
    236: MsgDirection Message::Dir() const
    323: ProtocolId Message::GetProtocol() const
    354: SignalId Message::GetSignal() const
    409: MsgHeader* Message::Header() const
  W119 Argument passed by value is modified
    589/1: bool Message::Retrieve(ProtocolSM* psm)
    656/1: bool Message::Send(Route route)
  W125 Non-const cast is not a downcast
    954:          auto bt = dynamic_cast< const BuffTrace* >(bt_);
C:\Users\Greg\Documents\rsc\rsc\src\sb\Message.h
* W029 Unused enum
    72:    enum Location
* W030 Unused enumerator
    88:       IllegalSignal,   // illegal signal found              0000  sid
    89:       IllegalParm,     // illegal parameter found          index  pid
    90:       IncompleteParm,  // parameter too short              index  pid
    91:       MissingParm,     // mandatory parameter missing       0000  pid
    92:       Overflow,        // last parameter extends past end  index  pid
    93:       Trampled         // last parameter trampled fence    index  pid
* W032 Unused function
    181:    Message* FindSignal(SignalId sid) const;
* W042 Member could be private
    329:    virtual void Handled(bool retain);
    333:    virtual bool SendFailure(NodeBase::debug64_t errval);
* W043 Member could be protected
    132:    virtual InspectRc InspectMsg(NodeBase::debug64_t& errval) const;
    241:    NodeBase::MsgDirection Dir() const;
  W075 Virtual function is public
    132:    virtual InspectRc InspectMsg(NodeBase::debug64_t& errval) const;
    152:    virtual void Save();
    157:    virtual void Unsave();
    165:    virtual bool Retrieve(ProtocolSM* psm);
    172:    virtual bool Relay(ProtocolSM& ogPsm);
    176:    virtual bool SendToSelf();
    233:    virtual void SetReceiver(const GlobalAddress& receiver);
    237:    virtual void SetSender(const GlobalAddress& sender);
    262:    virtual bool Send(Route route);
    266:    virtual bool Restore();
* W077 Virtual function has no overrides
    152:    virtual void Save();
    157:    virtual void Unsave();
    165:    virtual bool Retrieve(ProtocolSM* psm);
    172:    virtual bool Relay(ProtocolSM& ogPsm);
    176:    virtual bool SendToSelf();
    233:    virtual void SetReceiver(const GlobalAddress& receiver);
    237:    virtual void SetSender(const GlobalAddress& sender);
    266:    virtual bool Restore();
    316:    virtual void Refresh();
    329:    virtual void Handled(bool retain);
    333:    virtual bool SendFailure(NodeBase::debug64_t errval);
    341:    virtual void ClearContext() const;
* W088 Argument could be const
    132/1:    virtual InspectRc InspectMsg(NodeBase::debug64_t& errval) const;
* W090 Function could be const
    110:    void SetSignal(SignalId sid);
    114:    void SetJoin(bool join);
    225:    void SetProtocol(ProtocolId prid);
    229:    void SetPriority(MsgPriority prio);
    233:    virtual void SetReceiver(const GlobalAddress& receiver);
    237:    virtual void SetSender(const GlobalAddress& sender);
    358:    void SetRxAddr(const LocalAddress& rxaddr);
C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgContext.cpp
  W007 Cast down the inheritance hierarchy
    75:    static_cast< MsgFactory* >(fac)->ProcessIcMsg(msg);
C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgHeader.h
* W099 Line contains adjacent spaces
    42:    LocalAddress   txAddr;         // source address
    43:    LocalAddress   rxAddr;         // destination address
    44:    MsgPriority    priority : 2;   // message's priority
    45:    bool           initial  : 1;   // true for initial message
    46:    bool           final    : 1;   // true for final message
    47:    bool           join     : 1;   // true to create PSM and join root SSM
    48:    bool           self     : 1;   // true for message to self
    49:    bool           injected : 1;   // true if sent by InjectCommand
    50:    bool           kill     : 1;   // true to kill context on arrival
    51:    uint8_t        spare    : 6;   // reserved for future use
    52:    Message::Route route    : 2;   // the route that the message took
    53:    ProtocolId     protocol : 16;  // message's protocol
    54:    SignalId       signal   : 16;  // message's signal
    55:    uint16_t       length   : 16;  // total bytes in all parameters
C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.cpp
  W007 Cast down the inheritance hierarchy
    74:    locAddr_.sbAddr_.fid = static_cast< ProtocolSM& >(upper).GetFactory();
    146:    return static_cast< PsmFactory* >(fac)->AllocIcPsm(msg, *this);
    204:    auto port = static_cast< MsgPort* >(pool->BidToObj(locAddr.bid));
    259:       static_cast< PsmFactory* >(fac)->PortAllocated(*this, msg);
  W008 Cast removes const qualification
    334:    return const_cast< MsgPort* >(this);
C:\Users\Greg\Documents\rsc\rsc\src\sb\MsgPort.h
* W042 Member could be private
    53:    MsgPort(const Message& msg, Context& ctx);
* W092 Function could be free
    168:    static MsgPort* FindPeer(const GlobalAddress& remAddr); // PsmFactory.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.cpp
  W006 reinterpret_cast
    108:    auto fake = reinterpret_cast< const Parameter* >(&local);
* W106 Function does not invoke Debug::ft
    198: Parameter::Usage Parameter::GetUsage(SignalId sid) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\Parameter.h
  W005 Functional cast
    85:    Id Pid() const { return Id(pid_.GetId()); }
* W030 Unused enumerator
    121:       StreamContainsIllegalParm,
* W032 Unused function
    89:    ProtocolId Prid() const { return prid_; }
  W075 Virtual function is public
    99:    virtual void DisplayMsg(std::ostream& stream, const std::string& prefix,
    108:    virtual NodeBase::CliParm* CreateCliParm(Usage use) const;
    137:    virtual TestRc InjectMsg
    150:    virtual TestRc VerifyMsg
* W092 Function could be free
    155:    static NodeBase::c_string ExplainRc(TestRc rc); // StIncrement.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.cpp
  W006 reinterpret_cast
    88:    auto fake = reinterpret_cast< const Protocol* >(&local);
* W106 Function does not invoke Debug::ft
    129: Parameter* Protocol::FirstParm() const
    142: Signal* Protocol::FirstSignal() const
    155: Parameter* Protocol::GetParameter(ParameterId pid) const
    167: Signal* Protocol::GetSignal(SignalId sid) const
    179: void Protocol::NextParm(Parameter*& parm) const
    192: void Protocol::NextSignal(Signal*& sig) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\Protocol.h
  W075 Virtual function is public
    82:    virtual SignalId ExtractSignal(const SbIpBuffer& buff) const = 0;
    114:    virtual void DisplayMsg(std::ostream& stream,
C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolLayer.h
  W026 Unused argument
    150/1:    virtual ProtocolLayer* AllocLower(const Message* msg);
* W032 Unused function
    68:    bool IsLowermost() const { return lower_ == nullptr; }
* W042 Member could be private
    89:    virtual FactoryId GetFactory() const = 0;
* W043 Member could be protected
    64:    bool IsUppermost() const { return upper_ == nullptr; }
* W065 Base class virtual destructor is not public
    126:    virtual ~ProtocolLayer();
  W075 Virtual function is public
    52:    virtual MsgPort* Port() const = 0;
    56:    virtual ProtocolSM* UppermostPsm() const = 0;
    89:    virtual FactoryId GetFactory() const = 0;
    93:    virtual Message::Route Route() const = 0;
    102:    virtual NetworkBase::SysTcpSocket* CreateAppSocket();
* W090 Function could be const
    167:    virtual Message* UnwrapMsg(Message& msg);
    174:    virtual Message* WrapMsg(Message& msg);
C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolRegistry.cpp
* W106 Function does not invoke Debug::ft
    78: Protocol* ProtocolRegistry::GetProtocol(ProtocolId prid) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.cpp
  W007 Cast down the inheritance hierarchy
    404:       auto psm = static_cast< ProtocolSM* >(layer);
  W008 Cast removes const qualification
    637:    if(upper == nullptr) return const_cast< ProtocolSM* >(this);
C:\Users\Greg\Documents\rsc\rsc\src\sb\ProtocolSM.h
  W026 Unused argument
    286/1:    virtual void MsgHandled(Message& msg) { }
    292/1:    virtual void RestoreIcMsg(Message& msg) { }
    298/1:    virtual void RefreshMsg(Message& msg) { }
* W030 Unused enumerator
    95:       SignalUnknown,     // signal not recognized
    97:       ParameterUnknown,  // parameter not recognized
    98:       ParameterInvalid,  // parameter not valid for this signal
* W032 Unused function
    135:    Message* FirstSentMsg() const { return sentMsgq_.First(); }
    166:    bool DropPeer(const GlobalAddress& peerPrevRemAddr);
* W042 Member could be private
    143:    ProtocolId GetProtocol() const;
    251:    bool SendMsg(Message& msg) override;
* W043 Member could be protected
    75:    enum IncomingRc
    84:    enum OutgoingRc
    129:    Message* FirstOgMsg() const { return ogMsgq_.First(); }
* W077 Virtual function has no overrides
    237:    virtual void SetState(StateId stid);
    281:    virtual Priority GetPriority() const { return NormalPriority; }
    286:    virtual void MsgHandled(Message& msg) { }
    292:    virtual void RestoreIcMsg(Message& msg) { }
    298:    virtual void RefreshMsg(Message& msg) { }
* W090 Function could be const
    116:    void StopTimer(const Base& owner, TimerId tid);
C:\Users\Greg\Documents\rsc\rsc\src\sb\RootServiceSM.cpp
  W007 Cast down the inheritance hierarchy
    47:    ctx_ = static_cast< SsmContext* >(Context::RunningContext());
C:\Users\Greg\Documents\rsc\rsc\src\sb\RootServiceSM.h
  W026 Unused argument
    50/1:    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
  W075 Virtual function is public
    50:    virtual Event* RaiseProtocolError(ProtocolSM& psm, ProtocolSM::Error err);
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbDaemons.cpp
  W007 Cast down the inheritance hierarchy
    119:    auto daemon = static_cast< InvokerDaemon* >(reg->FindDaemon(name.c_str()));
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbDaemons.h
* W092 Function could be free
    43:    static InvokerDaemon* GetDaemon(NodeBase::Faction faction, size_t size); // InvokerPool.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbEvents.h
* W032 Unused function
    91:    StateId CurrState() const { return currState_; }
    131:    Message* SavedMsg() const { return savedMsg_; }
    227:    StateId CurrState() const { return currState_; }
    231:    StateId NextState() const { return nextState_; }
    372:    bool IsInitiation() const { return initiation_; }
    383:    Message* GetMessage() const { return message_; }
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbHandlers.cpp
  W007 Cast down the inheritance hierarchy
    50:    auto pid = ssm.CalcPort(static_cast< const AnalyzeMsgEvent& >(currEvent));
    120:    auto& fte = static_cast< ForceTransitionEvent& >(currEvent);
    134:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.cpp
  W004 C-style cast
    697:    ((ProtocolSM*) p)->Kill();
  W005 Functional cast
    655:       auto pool = reg->Pool(Faction(sc));
  W007 Cast down the inheritance hierarchy
    762:       auto msg = static_cast< Message* >(obj);
    847:       auto port = static_cast< MsgPort* >(obj);
    1053:       auto psm = static_cast< ProtocolSM* >(obj);
    1277:       auto ssm = static_cast< ServiceSM* >(obj);
    1484:       auto tmr = static_cast< Timer* >(obj);
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIncrement.h
* W028 Unused data
    55:    static const NodeBase::id_t LastSbIndex    = LastNwIndex + 9;
    85:    static const NodeBase::id_t LastSbIndex   = LastNwIndex + 6;
    115:    static const NodeBase::id_t LastSbIndex   = LastNwIndex + 5;
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbInputHandler.cpp
  W006 reinterpret_cast
    75:    auto header = reinterpret_cast< const MsgHeader* >(source);
  W007 Cast down the inheritance hierarchy
    103:    SbIpBufferPtr sbbuff(static_cast< SbIpBuffer* >(buff.release()));
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbInvokerPools.cpp
  W007 Cast down the inheritance hierarchy
    62:       (static_cast< CfgIntParm* >(reg->FindParm("NoIngressQueueLength")));
    73:       (static_cast< CfgIntParm* >(reg->FindParm("NoIngressMessageCount")));
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIpBuffer.cpp
* W023 Remove using statement
    36: using namespace NetworkBase;
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbIpBuffer.h
  W006 reinterpret_cast
    62:       { return reinterpret_cast< MsgHeader* >(HeaderPtr()); }
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.cpp
  W007 Cast down the inheritance hierarchy
    204:       auto port = static_cast< MsgPort* >(obj);
    261:    auto psm = static_cast< ProtocolSM* >(NextUsed(PsmToAudit_));
    278:       psm = static_cast< ProtocolSM* >(NextUsed(PsmToAudit_));
* W106 Function does not invoke Debug::ft
    370: void TimerPool::IncrTimeouts() const
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbPools.h
  W110 Override of Base.Display not found
    167: class TimerPool : public NodeBase::ObjectPool
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.cpp
  W005 Functional cast
    102:    width -= col_t(label.size());
    192:          stream << strClass(reg->GetService(ServiceId(cid_)), false);
    197:          stream << strClass(reg->GetFactory(FactoryId(cid_)), false);
  W007 Cast down the inheritance hierarchy
    402:          bt = static_cast< BuffTrace* >(rec);
    855:       curr_ = static_cast< const AnalyzeSapEvent& >(sxp).CurrEvent()->Eid();
    858:       curr_ = static_cast< const AnalyzeSnpEvent& >(sxp).CurrEvent()->Eid();
    885:    mod_((static_cast< const InitiationReqEvent& >(sip)).GetModifier())
  W082 Adjacent arguments have the same type
    68: static void DisplayEvent(ostream& stream, ServiceId sid, EventId eid)
  W119 Argument passed by value is modified
    386/1:    (BuffTrace* bt, FactoryId fid, SignalId sid, SkipInfo& skip)
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTrace.h
* W042 Member could be private
    520:    const StateId stid_;
  W050 Data is not private
    482:    ServiceId owner_;
    486:    const EventId eid_;
    516:    const ServiceId sid_;
    520:    const StateId stid_;
    524:    const EventHandler::Rc rc_;
* W060 Base class constructor is public
    462:    EventTrace(Id rid, const Event& evt);
    503:    HandlerTrace(ServiceId sid, const State& state, const Event& evt,
  W082 Adjacent arguments have the same type
    174:    static BuffTrace* NextIcMsg
  W121 Static member function has indirect argument for its class
    175/1:       (BuffTrace* bt, FactoryId fid, SignalId sid, SkipInfo& skip);
C:\Users\Greg\Documents\rsc\rsc\src\sb\SbTracer.h
  W082 Adjacent arguments have the same type
    136:    NodeBase::TraceRc SelectSignal
    190:       SignalFilter(ProtocolId p, SignalId s, NodeBase::TraceStatus ts);
  W110 Override of Base.Display not found
    113: class SbTracer : public NodeBase::Permanent
C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.cpp
  W006 reinterpret_cast
    287:    auto fake = reinterpret_cast< const Service* >(&local);
* W106 Function does not invoke Debug::ft
    377: Trigger* Service::GetTrigger(TriggerId tid) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\Service.h
  W005 Functional cast
    65:    Id Sid() const { return Id(sid_.GetId()); }
* W032 Unused function
    131:    bool Disable();
    135:    bool Enable();
* W042 Member could be private
    65:    Id Sid() const { return Id(sid_.GetId()); }
    79:    static bool IsValidPortId(PortId pid)
    121:    bool IsModifiable() const { return modifiable_; }
    125:    bool IsModifier() const { return modifier_; }
* W043 Member could be protected
    87:    virtual NodeBase::c_string PortName(PortId pid) const;
  W075 Virtual function is public
    87:    virtual NodeBase::c_string PortName(PortId pid) const;
    117:    virtual ServiceSM* AllocModifier() const;
  W082 Adjacent arguments have the same type
    181:    explicit Service(Id sid, bool modifiable = false, bool modifier = false);
* W092 Function could be free
    79:    static bool IsValidPortId(PortId pid) // State.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceRegistry.cpp
* W106 Function does not invoke Debug::ft
    78: Service* ServiceRegistry::GetService(ServiceId sid) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.cpp
  W007 Cast down the inheritance hierarchy
    447:             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
    451:          modifierSsm = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrSsm();
    452:          currEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
    503:             tid = static_cast< AnalyzeSapEvent* >(sapEvent)->GetTrigger();
    509:          currEvent = static_cast< AnalyzeSapEvent* >(sapEvent)->CurrEvent();
    510:          modifierInit = static_cast< AnalyzeSapEvent* >
    763:             else if(static_cast< AnalyzeSapEvent* >(nextEvent)
    766:             else if(static_cast< AnalyzeSapEvent* >(nextEvent)
    864:          initEvent = static_cast< InitiationReqEvent* >(nextEvent);
    868:             initEvent->SetSapEvent(static_cast< AnalyzeSapEvent& >(sapEvent));
    930:             auto sibling = static_cast< InitiationReqEvent* >
    971:    auto& initEvent = static_cast< InitiationReqEvent& >(currEvent);
* W106 Function does not invoke Debug::ft
    312: Service* ServiceSM::GetService() const
* W117 Line can merge with the next line and be under the length limit
    764:                   ->CurrInitiator() != nullptr)
    767:                   ->CurrSsm() != nullptr)
  W119 Argument passed by value is modified
    391/1: EventHandler::Rc ServiceSM::ProcessEvent(Event* currEvent, Event*& nextEvent)
    831/2:    (const Trigger* trigger, const Initiator* modifier, Event& sapEvent,
    899/2:    (const Trigger* trigger, const Initiator* modifier, Event& snpEvent)
C:\Users\Greg\Documents\rsc\rsc\src\sb\ServiceSM.h
  W026 Unused argument
    79/2:    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
    187/1:       (Event& currEvent, Event*& nextEvent);
    187/2:       (Event& currEvent, Event*& nextEvent);
* W032 Unused function
    132:    bool HasTriggered(TriggerId tid) const;
* W042 Member could be private
    95:    StateId NextState() const { return nextState_; }
* W065 Base class virtual destructor is not public
    167:    virtual ~ServiceSM();
  W075 Virtual function is public
    67:    virtual ServicePortId CalcPort(const AnalyzeMsgEvent& ame) = 0;
    73:    virtual EventHandler::Rc ProcessSap(Event& currEvent, Event*& nextEvent);
    79:    virtual EventHandler::Rc ProcessSnp(Event& currEvent, Event*& nextEvent);
    100:    virtual void SetNextState(StateId stid);
    107:    virtual void PsmDeleted(const ProtocolSM& exPsm);
    121:    virtual void SetNextSap(TriggerId sap);
    127:    virtual void SetNextSnp(TriggerId snp);
    139:    virtual void MorphToService(ServiceId sid);
* W077 Virtual function has no overrides
    139:    virtual void MorphToService(ServiceId sid);
* W090 Function could be const
    186:    virtual EventHandler::Rc ProcessInitNack
    235:    EventHandler::Rc ProcessSsmqSap
    246:    void ProcessSsmqSnp(ServiceSM* modifier, Event& snpEvent);
C:\Users\Greg\Documents\rsc\rsc\src\sb\Signal.cpp
  W006 reinterpret_cast
    81:    auto fake = reinterpret_cast< const Signal* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\sb\Signal.h
  W005 Functional cast
    81:    Id Sid() const { return Id(sid_.GetId()); }
* W032 Unused function
    85:    ProtocolId Prid() const { return prid_; }
  W075 Virtual function is public
    92:    virtual NodeBase::CliText* CreateText() const;
C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmContext.cpp
  W007 Cast down the inheritance hierarchy
    81:    return static_cast< SsmFactory* >(fac)->AllocRoot(msg, psm);
C:\Users\Greg\Documents\rsc\rsc\src\sb\SsmFactory.h
  W026 Unused argument
    48/1:    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  W075 Virtual function is public
    42:    virtual RootServiceSM* AllocRoot(const Message& msg, ProtocolSM& psm) const;
    48:    virtual ProtocolSM* AllocOgPsm(const Message& msg) const;
  W082 Adjacent arguments have the same type
    56:    SsmFactory(Id fid, ProtocolId prid, NodeBase::c_string name);
C:\Users\Greg\Documents\rsc\rsc\src\sb\State.cpp
  W006 reinterpret_cast
    197:    auto fake = reinterpret_cast< const State* >(&local);
* W106 Function does not invoke Debug::ft
    126: bool State::BindEventHandler(EventHandlerId ehid, EventId eid)
    161: bool State::BindMsgAnalyzer(EventHandlerId ehid, ServicePortId pid)
    244: EventHandlerId State::GetHandler(EventId eid) const
    252: EventHandlerId State::MsgAnalyzer(ServicePortId pid) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\State.h
  W005 Functional cast
    60:    Id Stid() const { return Id(stid_.GetId()); }
* W032 Unused function
    64:    ServiceId Sid() const { return sid_; }
C:\Users\Greg\Documents\rsc\rsc\src\sb\TextTlvMessage.h
  W027 Unused class
    37: class TextTlvMessage : public TlvMessage
* W032 Unused function
    58:    explicit TextTlvMessage(SbIpBufferPtr& buff);
    62:    TextTlvMessage(ProtocolSM* psm, size_t size);
    68:    bool Receive();
* W077 Virtual function has no overrides
    77:    virtual SbIpBufferPtr Parse() = 0;
    84:    virtual SbIpBufferPtr Build() = 0;
* W090 Function could be const
    77:    virtual SbIpBufferPtr Parse() = 0;
    84:    virtual SbIpBufferPtr Build() = 0;
C:\Users\Greg\Documents\rsc\rsc\src\sb\Timer.cpp
  W006 reinterpret_cast
    188:    auto fake = reinterpret_cast< const Timer* >(&local);
C:\Users\Greg\Documents\rsc\rsc\src\sb\Timer.h
  W037 Member hides inherited name
    105:    static ptrdiff_t LinkDiff();
* W053 Data could be const
    133:    TimerId tid_;
    145:    NodeBase::Q2Link link_;
C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerProtocol.cpp
  W006 reinterpret_cast
    106:    auto toi = reinterpret_cast< const TimeoutInfo* >(bytes);
C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerProtocol.h
* W111 Override of Object.Patch not found
    88: class TimeoutParameter : public TlvParameter
C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerRegistry.cpp
  W119 Argument passed by value is modified
    76/1: Timer::QId TimerRegistry::CalcQId(uint32_t secs) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\TimerThread.cpp
* W106 Function does not invoke Debug::ft
    62: TraceStatus TimerThread::CalcStatus(bool dynamic) const
C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvIntParameter.h
  W007 Cast down the inheritance hierarchy
    69:       auto& tlvmsg = static_cast< TlvMessage& >(msg);
    101:       auto& tlvmsg = static_cast< const TlvMessage& >(msg);
C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.cpp
  W004 C-style cast
    166:    auto pptr = (TlvParm*) (layout->bytes + layout->header.length);
    250:    return (Fence*) fence;
    395:    pit.pptr = (TlvParm*) &pit.mptr->bytes[nextIndex];
  W006 reinterpret_cast
    64:    auto encap = reinterpret_cast< const TlvMsgLayout* >(parm.bytes);
    459:    auto encap = reinterpret_cast< TlvMsgLayout* >(pptr->bytes);
  W008 Cast removes const qualification
    395:    pit.pptr = (TlvParm*) &pit.mptr->bytes[nextIndex];
  W009 Pointer arithmetic
    166:    auto pptr = (TlvParm*) (layout->bytes + layout->header.length);
    249:    auto fence = layout->bytes + layout->header.length;
  W119 Argument passed by value is modified
    223/2: TlvParm* TlvMessage::CopyParm(const TlvParm& src, ParameterId pid)
C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvMessage.h
  W006 reinterpret_cast
    79:       return reinterpret_cast< T* >(pptr->bytes);
    93:       auto dest = reinterpret_cast< T* >(pptr->bytes);
    128:       parm = (pptr == nullptr ? nullptr : reinterpret_cast< T* >(pptr->bytes));
    281:       { return reinterpret_cast< TlvMsgLayout* >(Buffer()->HeaderPtr()); }
* W032 Unused function
    58:    TlvMessage(const TlvParm& parm, ProtocolSM* psm);
    67:    virtual TlvParm* Wrap(const TlvMessage& msg, ParameterId pid);
    176:    size_t AllParms(const TlvParm* ptab[], size_t size) const;
    182:    size_t FindParms(ParameterId pid, const TlvParm* ptab[], size_t size) const;
    196:    TlvParm* AddBytes(const NodeBase::byte_t* src, size_t size, ParameterId pid);
    202:    TlvParm* CopyParm(const TlvParm& src, ParameterId pid = NodeBase::NIL_ID);
    263:    NodeBase::byte_t* FindBytes(size_t& size, ParameterId pid) const;
    270:    virtual bool MatchParm
    286:    size_t ParmOffset(const ParmIterator& pit) const;
* W042 Member could be private
    147:       ParmIterator() : mptr(nullptr), pptr(nullptr), pindex(0) { }
    150:       ParmIterator& operator=(const ParmIterator& that) = default;
    165:    TlvParm* FirstParm(ParmIterator& pit) const;
    170:    TlvParm* NextParm(ParmIterator& pit) const;
    191:    virtual TlvParm* AddParm(ParameterId pid, size_t plen);
    276:    virtual void AddFence();
    280:    TlvMsgLayout* TlvLayout() const
    291:    Fence* FencePtr() const;
    295:    void CheckFence() const;
* W060 Base class constructor is public
    50:    TlvMessage(ProtocolSM* psm, size_t size);
    58:    TlvMessage(const TlvParm& parm, ProtocolSM* psm);
  W075 Virtual function is public
    67:    virtual TlvParm* Wrap(const TlvMessage& msg, ParameterId pid);
    191:    virtual TlvParm* AddParm(ParameterId pid, size_t plen);
    206:    virtual void DeleteParm(TlvParm& parm);
* W077 Virtual function has no overrides
    67:    virtual TlvParm* Wrap(const TlvMessage& msg, ParameterId pid);
    191:    virtual TlvParm* AddParm(ParameterId pid, size_t plen);
    206:    virtual void DeleteParm(TlvParm& parm);
    270:    virtual bool MatchParm
    276:    virtual void AddFence();
  W082 Adjacent arguments have the same type
    104:    template< class T > T* CopyType
* W088 Argument could be const
    206/1:    virtual void DeleteParm(TlvParm& parm);
  W119 Argument passed by value is modified
    105/3:       (const TlvMessage& icMsg, ParameterId icPid, ParameterId ogPid = 0)
C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvParameter.cpp
  W007 Cast down the inheritance hierarchy
    67:    auto& tmsg = static_cast< const TlvMessage& >(msg);
C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvParameter.h
* W032 Unused function
    68:    static Id ExtractPid(const TlvParm& parm);
* W092 Function could be free
    68:    static Id ExtractPid(const TlvParm& parm); // TlvParameter.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sb\TlvProtocol.cpp
  W006 reinterpret_cast
    67:       auto pptr = reinterpret_cast< TlvParm* >(&bytes[index]);
C:\Users\Greg\Documents\rsc\rsc\src\sb\Trigger.h
* W042 Member could be private
    80:    static bool IsValidId(Id tid)
* W092 Function could be free
    80:    static bool IsValidId(Id tid) // ServiceSM.cpp
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.cpp
  W007 Cast down the inheritance hierarchy
    58:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    61:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    96:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    109:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    111:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    128:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    140:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    141:    auto& ode = static_cast< BcOriginationDeniedEvent& >(currEvent);
    156:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    158:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    164:       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    185:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    210:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    237:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    251:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    272:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    284:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    296:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    308:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    320:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    322:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    339:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    358:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    370:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    383:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    397:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    398:    auto& rre = static_cast< BcRemoteReleaseEvent& >(currEvent);
    412:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    424:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    426:    auto cmsg = static_cast< CipMessage* >(npsm->FirstRcvdMsg());
    453:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    465:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    466:    auto& tde = static_cast< BcTerminationDeniedEvent& >(currEvent);
    478:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    479:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    497:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    514:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    526:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    528:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    551:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    577:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    589:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    602:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    615:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    617:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    635:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    647:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    663:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    665:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    682:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    707:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    723:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    736:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    752:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    765:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    781:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    783:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    792:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    817:    auto& ate = static_cast< BcApplyTreatmentEvent& >(currEvent);
    818:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    854:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    868:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    882:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    883:    auto& lre = static_cast< BcLocalReleaseEvent& >(currEvent);
    896:    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
    897:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    929:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    950:    auto& rue = static_cast< ProxyBcReleaseUserEvent& >(currEvent);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcHandlers.h
* W020 Using statement in header
    28: using namespace NodeBase;
    29: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcService.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcSsm.cpp
  W007 Cast down the inheritance hierarchy
    75:       auto& ppsm = static_cast< PotsCallPsm& >(psm);
    80:       auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
    88:       SetNPsm(static_cast< CipPsm& >(psm));
    92:       SetUPsm(static_cast< MediaPsm& >(psm));
    128:    auto pmsg = static_cast< PotsMessage* >(ame.Msg());
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W106 Function does not invoke Debug::ft
    378: PotsProfile* PotsBcSsm::Profile() const
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBcStates.cpp
* W022 Add using statement
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.cpp
  W007 Cast down the inheritance hierarchy
    80:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBicService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.cpp
  W007 Cast down the inheritance hierarchy
    80:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsBocService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallFactory.cpp
  W007 Cast down the inheritance hierarchy
    49:    auto& icmsg = static_cast< const PotsMessage& >(msg1);
    116:    auto& pmsg = static_cast< const Pots_UN_Message& >(msg);
    194:       auto pmsg = static_cast< const PotsMessage* >(msg);
    196:       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
    200:       auto ppsm = static_cast< const PotsCallPsm* >(port.Upper());
    201:       cct = static_cast< PotsCircuit* >(tsw->GetCircuit(ppsm->TsPort()));
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallHandler.cpp
  W006 reinterpret_cast
    89:    auto pptr = reinterpret_cast< TlvParm* >(sbuff->PayloadPtr());
    90:    auto phi = reinterpret_cast< PotsHeaderInfo* >(pptr->bytes);
  W007 Cast down the inheritance hierarchy
    87:    auto sbuff = static_cast< SbIpBuffer* >(buff.get());
    108:    auto prof = static_cast< PotsCircuit* >(cct)->Profile();
* W022 Add using statement
    0:  // namespace MediaBase
    0:  // namespace NetworkBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallIpService.cpp
* W022 Add using statement
    0:  // namespace NetworkBase
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCallPsm.cpp
  W007 Cast down the inheritance hierarchy
    96:       return static_cast< PotsCallPsm* >(psm);
    162:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    197:    auto& pmsg = static_cast< Pots_NU_Message& >(msg);
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.cpp
  W007 Cast down the inheritance hierarchy
    186:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    244:       auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    265:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    278:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCcwService.h
* W020 Using statement in header
    28: using namespace NodeBase;
    29: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.cpp
  W007 Cast down the inheritance hierarchy
    53:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    55:    auto cfbp = static_cast< PotsCfbFeatureProfile* >(prof->FindFeature(CFB));
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfbService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.cpp
  W007 Cast down the inheritance hierarchy
    53:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    55:    auto cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfnService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.cpp
  W007 Cast down the inheritance hierarchy
    53:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    55:    auto cfup = static_cast< PotsCfuFeatureProfile* >(prof->FindFeature(CFU));
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfuService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.cpp
  W007 Cast down the inheritance hierarchy
    264:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    269:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    271:       auto& cssm = static_cast< PotsCfxSsm& >(ssm);
    290:    auto& cssm = static_cast< PotsCfxSsm& >(ssm);
    291:    auto& pssm = static_cast< PotsBcSsm& >(*cssm.Parent());
    335:       auto pssm = static_cast< PotsBcSsm* >(Parent());
    360:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    437:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    439:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    452:          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
    474:          cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
    488:       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFU));
    494:       cfxp = static_cast< DnRouteFeatureProfile* >(prof->FindFeature(CFB));
    500:       cfnp = static_cast< PotsCfnFeatureProfile* >(prof->FindFeature(CFN));
    529:    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
    532:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    587:       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    594:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    608:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    616:       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
    632:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCfxService.h
* W020 Using statement in header
    42: using namespace NodeBase;
    43: using namespace SessionBase;
    44: using namespace CallBase;
  W026 Unused argument
    61/1:    explicit PotsCfxSsm(ServiceId sid);
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwmService.cpp
  W006 reinterpret_cast
    1381:          auto ring = reinterpret_cast< PotsRingInfo* >(pptr->bytes);
  W007 Cast down the inheritance hierarchy
    468:    PotsMuxSsm* Mux() const { return static_cast< PotsMuxSsm* >(Parent()); }
    1094:    auto hldNPsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
    1131:          auto bcUPsm = static_cast< PotsCallPsm* >(psm);
    1201:    auto msg = static_cast< PotsMessage* >(Context::ContextMsg());
    1226:    auto npsm = static_cast< PotsMuxPsm* >(Context::ContextPsm());
    1238:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    1298:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    1340:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    1860:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    1861:    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
    1888:    auto& mux = static_cast< PotsCwmSsm& >(ssm);
    1900:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    1902:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    1909:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    2003:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2005:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    2006:    auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    2007:    auto npsm = static_cast< PotsMuxPsm* >(pmsg->Psm());
    2100:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2112:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2124:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2136:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2150:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2162:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2174:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2186:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2198:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2199:    auto& are = static_cast< PotsCwmActiveReleaseEvent& >(currEvent);
    2211:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2212:    auto& ire = static_cast< PotsCwmInactiveReleaseEvent& >(currEvent);
    2224:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
    2244:    auto& cwt = static_cast< PotsCwmSsm& >(ssm);
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
  W026 Unused argument
    455/2:    EventHandler::Rc ReleaseInactive(Cause::Ind cause, Event*& nextEvent);
* W053 Data could be const
    190:    Cause::Ind cause_;
* W117 Line can merge with the next line and be under the length limit
    611:    BindEventHandler
    625:    BindEventHandler
    629:    BindEventHandler
    631:    BindEventHandler
    633:    BindEventHandler
    637:    BindEventHandler
    645:    BindEventHandler
    647:    BindEventHandler
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.cpp
  W007 Cast down the inheritance hierarchy
    297:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    569:    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
    574:       auto pssm = static_cast< PotsBcSsm* >(Parent());
    575:       auto ate = static_cast< BcApplyTreatmentEvent* >(sap.CurrEvent());
    590:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    598:       auto& snp = static_cast< AnalyzeSnpEvent& >(currEvent);
    629:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    657:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    743:    auto& init = static_cast< InitiationReqEvent& >(currEvent);
    745:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    838:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    860:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    880:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    882:    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
    888:       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    911:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    934:    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
    935:    auto& pssm = static_cast< PotsBcSsm& >(*ssm.Parent());
    953:    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
    954:    auto& cwtssm = static_cast< PotsCwbSsm& >(ssm);
    958:       auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
    977:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    979:    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
    983:       auto pmsg = static_cast< Pots_UN_Message* >(ame.Msg());
    1024:    auto& cwtssm = static_cast< PotsCwtSsm& >(ssm);
    1025:    auto& relevt = static_cast< PotsCwtReleaseEvent& >(currEvent);
    1027:    auto pssm = static_cast< PotsBcSsm* >(cwtssm.Parent());
    1072:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W042 Member could be private
    263:    void StartTimer(TimerId tid, uint32_t secs);
* W053 Data could be const
    154:    Facility::Ind ind_;
  W075 Virtual function is public
    268:    void Cancel() override;
* W117 Line can merge with the next line and be under the length limit
    426:    BindEventHandler
    459:    BindEventHandler
    461:    BindEventHandler
    473:    BindEventHandler
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsCwtService.h
* W020 Using statement in header
    30: using namespace NodeBase;
    31: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsDiscService.cpp
  W007 Cast down the inheritance hierarchy
    115:    auto& pssm = static_cast< BcSsm& >(*Parent());
    117:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.cpp
  W007 Cast down the inheritance hierarchy
    81:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    154:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    160:       auto htlp = static_cast< PotsHtlFeatureProfile* >(prof->FindFeature(HTL));
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsHtlService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.cpp
  W007 Cast down the inheritance hierarchy
    183:    auto& pmsg = static_cast< const PotsMessage& >(msg);
    229:    auto& pmsg = static_cast< const PotsMessage& >(msg);
    232:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(phi->port));
    332:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    385:    auto& pmsg = static_cast< Pots_UN_Message& >(msg);
    684:    auto& npsm = static_cast< PotsMuxPsm& >(psm);
    687:    auto cct = static_cast< PotsCircuit* >(tsw->GetCircuit(port));
    752:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    814:    auto pmsg = static_cast< PotsMessage* >(Context::ContextMsg());
    910:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    911:    auto pmsg = static_cast< Pots_NU_Message* >(ame.Msg());
    931:    auto& mux = static_cast< PotsMuxSsm& >(ssm);
    956:    auto& mux = static_cast< PotsMuxSsm& >(ssm);
    957:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    978:    auto& mux = static_cast< PotsMuxSsm& >(ssm);
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W117 Line can merge with the next line and be under the length limit
    612:    BindEventHandler
    626:    BindEventHandler
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsMultiplexer.h
* W020 Using statement in header
    45: using namespace MediaBase;
    46: using namespace CallBase;
    47: using namespace NodeBase;
    48: using namespace SessionBase;
  W026 Unused argument
    158/1:    PotsMuxSsm(const Message& msg, ProtocolSM& psm);
* W032 Unused function
    77:    PotsMuxPsm(ProtocolLayer& adj, bool upper, Switch::PortId port);
* W042 Member could be private
    160:    void SetProfile(PotsProfile* prof) { prof_ = prof; }
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.cpp
  W007 Cast down the inheritance hierarchy
    56:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    57:    auto msg = static_cast< CipMessage* >(ame.Msg());
    59:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    91:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    105:    auto msg = static_cast< CipMessage* >(Context::ContextMsg());
    107:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    132:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    133:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    135:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    171:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    181:    auto upsm = static_cast< ProxyBcPsm* >(pssm.UPsm());
    202:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    217:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    236:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    237:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    239:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    282:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    300:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    301:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    303:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    346:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    347:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    349:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    398:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    413:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    428:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    443:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    458:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    489:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    490:    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
    517:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    533:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    534:    auto upsm = static_cast< MediaPsm* >(Context::ContextPsm());
    561:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
    579:    auto& cte = static_cast< BcReleaseCallEvent& >(currEvent);
    580:    auto& pssm = static_cast< PotsBcSsm& >(ssm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W099 Line contains adjacent spaces
    132:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    133:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    134:    auto          sid = msg->GetSignal();
    135:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    137:    CauseInfo*    cci;
    236:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    237:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    238:    auto          sid = msg->GetSignal();
    239:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    241:    CauseInfo*    cci;
    300:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    301:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    302:    auto          sid = msg->GetSignal();
    303:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    305:    CauseInfo*    cci;
    346:    auto&         ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    347:    auto          msg = static_cast< CipMessage* >(ame.Msg());
    348:    auto          sid = msg->GetSignal();
    349:    auto&         pssm = static_cast< PotsBcSsm& >(ssm);
    351:    CauseInfo*    cci;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxyHandlers.h
* W020 Using statement in header
    28: using namespace NodeBase;
    29: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxySessions.cpp
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsProxySessions.h
* W020 Using statement in header
    28: using namespace CallBase;
    29: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSessions.h
* W020 Using statement in header
    44: using namespace CallBase;
    45: using namespace NetworkBase;
    46: using namespace NodeBase;
    47: using namespace SessionBase;
* W042 Member could be private
    410:    ProtocolSM* TimerPsm(TimerId tid) const;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsStatistics.cpp
* W022 Add using statement
    0:  // namespace CallBase::Cause
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsStatistics.h
* W020 Using statement in header
    30: using namespace NodeBase;
    31: using namespace CallBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.cpp
  W007 Cast down the inheritance hierarchy
    79:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsSusService.h
* W020 Using statement in header
    30: using namespace NodeBase;
    31: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.cpp
* W022 Add using statement
    0:  // namespace CallBase::Cause
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    118: void PotsTreatmentRegistry::SetCauseToTreatmentQ
    199: PotsTreatmentQueue* PotsTreatmentRegistry::TreatmentQ
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatmentRegistry.h
* W020 Using statement in header
    31: using namespace NodeBase;
    32: using namespace CallBase;
* W042 Member could be private
    58:    void SetCauseToTreatmentQ(Cause::Ind cause, PotsTreatmentQueue::QId qid);
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.cpp
  W006 reinterpret_cast
    79:    auto fake = reinterpret_cast< const PotsTreatmentQueue* >(&local);
    188:    auto fake = reinterpret_cast< const PotsTreatment* >(&local);
  W007 Cast down the inheritance hierarchy
    235:    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
    274:    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
    300:    auto pssm = static_cast< PotsBcSsm* >(ate.Owner());
* W022 Add using statement
    0:  // namespace CallBase
    0:  // namespace MediaBase
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsTreatments.h
* W020 Using statement in header
    45: using namespace NodeBase;
    46: using namespace SessionBase;
    47: using namespace MediaBase;
    48: using namespace CallBase;
* W042 Member could be private
    96:    PotsTreatment* NextTreatment(const PotsTreatment& treatment) const;
* W053 Data could be const
    168:    PotsTreatmentQueue::QId qid_;
    172:    Q1Link link_;
    201:    Tone::Id tone_;
    205:    uint32_t secs_;
  W075 Virtual function is public
    149:    virtual EventHandler::Rc ApplyTreatment
* W117 Line can merge with the next line and be under the length limit
    186:    PotsToneTreatment
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.cpp
  W007 Cast down the inheritance hierarchy
    193:    auto& pssm = static_cast< const PotsBcSsm& >(parentSsm);
    195:    auto wmlp = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
    391:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    415:    auto& ire = static_cast< InitiationReqEvent& >(currEvent);
    417:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    422:    wmlp_ = static_cast< PotsWmlFeatureProfile* >(prof->FindFeature(WML));
    489:    auto& sap = static_cast< AnalyzeSapEvent& >(currEvent);
    492:    auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    552:       auto& pssm = static_cast< PotsBcSsm& >(*Parent());
    570:    auto pssm = static_cast< PotsBcSsm* >(Parent());
    593:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    598:       auto tmsg = static_cast< TlvMessage* >(ame.Msg());
    600:       auto& wssm = static_cast< PotsWmlSsm& >(ssm);
    619:    auto& wssm = static_cast< PotsWmlSsm& >(ssm);
    620:    auto& pssm = static_cast< PotsBcSsm& >(*wssm.Parent());
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\PotsWmlService.h
* W020 Using statement in header
    29: using namespace NodeBase;
    30: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\SnIncrement.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\SnIncrement.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\sn\SnModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\sn\SnModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.cpp
  W006 reinterpret_cast
    85:    auto fake = reinterpret_cast< const MscAddress* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W106 Function does not invoke Debug::ft
    73: bool MscAddress::ExternalFid(FactoryId& fid) const
C:\Users\Greg\Documents\rsc\rsc\src\st\MscAddress.h
* W020 Using statement in header
    41: using namespace NodeBase;
    42: using namespace SessionBase;
* W053 Data could be const
    128:    Q1Link link_;
C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.cpp
  W007 Cast down the inheritance hierarchy
    139:          tt = static_cast< const TransTrace* >(rec);
    147:          auto mt = static_cast< const MsgTrace* >(rec);
    674:    auto rxnet = static_cast< const TransTrace* >(events_[index]);
    691:             trans = static_cast< const TransTrace* >(rec);
    703:             return static_cast< const MsgTrace* >(rec);
    718:    auto txmsg = static_cast< const MsgTrace* >(events_[index]);
    739:             trans = static_cast< const TransTrace* >(rec);
    746:             auto rxmsg = static_cast< const MsgTrace* >(rec);
    899:          tt = static_cast< const TransTrace* >(rec);
    935:             mt = static_cast< const MsgTrace* >(rec);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
  W119 Argument passed by value is modified
    1024/1:    (const MscContext* active, const MsgTrace& mt, const TransTrace* tt)
C:\Users\Greg\Documents\rsc\rsc\src\st\MscBuilder.h
* W020 Using statement in header
    54: using namespace NodeBase;
    55: using namespace SessionBase;
C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.cpp
  W006 reinterpret_cast
    91:    auto fake = reinterpret_cast< const MscContext* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W106 Function does not invoke Debug::ft
    80: bool MscContext::IsEqualTo(const void* rcvr, uint16_t cid) const
C:\Users\Greg\Documents\rsc\rsc\src\st\MscContext.h
* W020 Using statement in header
    33: using namespace NodeBase;
    34: using namespace SessionBase;
* W053 Data could be const
    145:    Q1Link link_;
C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.cpp
  W006 reinterpret_cast
    87:    auto fake = reinterpret_cast< const MscContextPair* >(&local);
* W022 Add using statement
    0:  // namespace NodeBase
* W106 Function does not invoke Debug::ft
    53: void MscContextPair::Contexts(MscContext*& ctx1, MscContext*& ctx2) const
C:\Users\Greg\Documents\rsc\rsc\src\st\MscContextPair.h
* W020 Using statement in header
    34: using namespace NodeBase;
* W053 Data could be const
    85:    Q1Link link_;
C:\Users\Greg\Documents\rsc\rsc\src\st\StIncrement.cpp
  W007 Cast down the inheritance hierarchy
    112:    auto ctx = static_cast< Context* >(pool->FirstUsed(bid));
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\st\StIncrement.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\st\StModule.cpp
* W022 Add using statement
    0:  // namespace NodeBase
C:\Users\Greg\Documents\rsc\rsc\src\st\StModule.h
* W020 Using statement in header
    28: using namespace NodeBase;
C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.cpp
  W007 Cast down the inheritance hierarchy
    63:    return static_cast< StTestData* >(data);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
C:\Users\Greg\Documents\rsc\rsc\src\st\StTestData.h
* W020 Using statement in header
    32: using namespace NodeBase;
    33: using namespace SessionBase;
  W082 Adjacent arguments have the same type
    78:    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.cpp
  W007 Cast down the inheritance hierarchy
    480:    auto tpsm = static_cast< TestPsm* >(Psm());
    495:    auto tssm = static_cast< TestSsm* >(RootSsm());
    543:       if(p->GetFactory() == TestFactoryId) return static_cast< TestPsm* >(p);
    785:       SetTestPsm(static_cast< TestPsm* >(&psm));
    890:    auto& ame = static_cast< AnalyzeMsgEvent& >(currEvent);
    891:    auto tmsg = static_cast< TestMessage* >(ame.Msg());
    924:    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
    933:    auto apsm = static_cast< SsmFactory* >(afac)->AllocOgPsm(*amsg);
    944:    auto& tssm = static_cast< TestSsm& >(ssm);
    960:    auto& tssm = static_cast< TestSsm& >(ssm);
    975:    auto tmsg = static_cast< TestMessage* >(Context::ContextMsg());
    976:    auto& tssm = static_cast< TestSsm& >(ssm);
* W022 Add using statement
    0:  // namespace NodeBase
    0:  // namespace SessionBase
* W117 Line can merge with the next line and be under the length limit
    706:    BindMsgAnalyzer
    710:    BindEventHandler
    712:    BindEventHandler
    722:    BindMsgAnalyzer
    726:    BindEventHandler
    728:    BindEventHandler
C:\Users\Greg\Documents\rsc\rsc\src\st\TestSessions.h
* W020 Using statement in header
    43: using namespace NodeBase;
    44: using namespace SessionBase;
* W042 Member could be private
    265:    void UpdateTestPsm();
    348:    TestPsm* GetTestPsm() const { return testPsm_; }
  W082 Adjacent arguments have the same type
    354:    Message* NextIcMsg(FactoryId fid, SignalId sid, SkipInfo& skip);
* W090 Function could be const
    265:    void UpdateTestPsm();
* W092 Function could be free
    113:    static TestPsm* Find(const MsgPort& port); // TestSessions.cpp
